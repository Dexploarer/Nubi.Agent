---
title: Socket.IO Server Setup
description: Learn how to configure NUBI's Socket.IO server with advanced middleware, connection management, and real-time communication.
---

import {
  Card,
  CardGrid,
  Aside,
  Code,
  Tabs,
  TabItem,
} from "@astrojs/starlight/components";

# Socket.IO Server Setup

NUBI's Socket.IO server implementation provides **enterprise-grade real-time communication** with advanced middleware, connection management, and seamless integration with ElizaOS core systems.

## üöÄ Server Architecture

<div class="interactive-demo">
  <h3>üì° Connection Flow</h3>
  <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin: 2rem 0;">
    <div style="padding: 1rem; background: var(--nubi-spirit-blue); color: white; border-radius: 8px; text-align: center;">
      <strong>1. Connect</strong>
      <br />
      <small>Client ‚Üí Server</small>
      <br />
      <code>socket.connect()</code>
    </div>
    <div style="padding: 1rem; background: var(--nubi-jackal-gold); color: var(--nubi-shadow-black); border-radius: 8px; text-align: center;">
      <strong>2. Auth</strong>
      <br />
      <small>Session Creation</small>
      <br />
      <code>authenticate()</code>
    </div>
    <div style="padding: 1rem; background: var(--nubi-ancient-bronze); color: white; border-radius: 8px; text-align: center;">
      <strong>3. Process</strong>
      <br />
      <small>Two-Layer Pipeline</small>
      <br />
      <code>process(message)</code>
    </div>
    <div style="padding: 1rem; background: var(--nubi-mystic-purple); color: white; border-radius: 8px; text-align: center;">
      <strong>4. Respond</strong>
      <br />
      <small>AI ‚Üí Broadcast</small>
      <br />
      <code>emit(response)</code>
    </div>
  </div>
</div>

## ‚öôÔ∏è Server Configuration

<Tabs>
  <TabItem label="Basic Setup">
```typescript
import { Server } from "socket.io";
import { createServer } from "http";
import { SessionManager } from "../services/sessions-service";
import { MessageRouter } from "../messaging/message-router";

export class SocketIOServer {
  private io: Server;
  private sessionManager: SessionManager;
  private messageRouter: MessageRouter;
  
  constructor(httpServer: any, runtime: IAgentRuntime) {
    this.io = new Server(httpServer, {
      cors: {
        origin: this.getAllowedOrigins(),
        methods: ["GET", "POST"],
        credentials: true
      },
      transports: ['websocket', 'polling'],
      pingTimeout: 60000,
      pingInterval: 25000
    });
    
    this.sessionManager = new SessionManager(runtime);
    this.messageRouter = new MessageRouter(runtime);
    this.setupEventHandlers();
  }
  
  private getAllowedOrigins(): string[] {
    return process.env.ALLOWED_ORIGINS?.split(',') || [
      "http://localhost:3000",
      "https://anubis.chat",
      "https://app.anubis.chat"
    ];
  }
}
```
  </TabItem>
  
  <TabItem label="Advanced Configuration">
```typescript
// Production-ready configuration with clustering support
export const socketConfig = {
  // Connection settings
  pingTimeout: 60000,           // 60 seconds
  pingInterval: 25000,          // 25 seconds
  maxHttpBufferSize: 1e6,       // 1MB
  allowEIO3: false,             // Force Engine.IO v4
  
  // Clustering support
  adapter: process.env.REDIS_URL ? 
    createAdapter(process.env.REDIS_URL) : undefined,
    
  // Security settings
  cors: {
    origin: getAllowedOrigins(),
    credentials: true,
    optionsSuccessStatus: 200
  },
  
  // Transport configuration
  transports: ['websocket', 'polling'],
  allowUpgrades: true,
  perMessageDeflate: {
    threshold: 1024,
    concurrencyLimit: 10,
    memLevel: 7
  }
};

// Connection limiting
const connectionLimiter = rateLimit({
windowMs: 15 _ 60 _ 1000, // 15 minutes
max: 100, // 100 connections per IP
message: "Too many connections from this IP"
});

````
  </TabItem>

  <TabItem label="Environment Variables">
```bash
# Socket.IO Server Configuration
SOCKET_PORT=3001
SOCKET_HOST=0.0.0.0

# CORS Configuration
ALLOWED_ORIGINS=http://localhost:3000,https://anubis.chat,https://app.anubis.chat

# Redis Adapter (for clustering)
REDIS_URL=redis://localhost:6379

# Connection Limits
MAX_CONNECTIONS_PER_IP=100
CONNECTION_RATE_LIMIT_WINDOW=900000  # 15 minutes

# Session Management
SESSION_TIMEOUT=1800000              # 30 minutes
SESSION_CLEANUP_INTERVAL=300000      # 5 minutes

# Performance Tuning
SOCKET_PING_TIMEOUT=60000
SOCKET_PING_INTERVAL=25000
MAX_HTTP_BUFFER_SIZE=1048576         # 1MB
````

  </TabItem>
</Tabs>

## üîå Connection Management

### Session Lifecycle

<CardGrid>
  <Card title="üîó Connection Established" icon="rocket">
    **Automatic session creation** with unique ID generation
    
    ```typescript
    socket.on('connect', async () => {
      const sessionId = crypto.randomUUID();
      socket.data.sessionId = sessionId;
      
      await sessionManager.createSession({
        sessionId,
        socketId: socket.id,
        connectedAt: new Date(),
        platform: 'websocket'
      });
    });
    ```
  </Card>
  
  <Card title="üè† Room Management" icon="setting">
    **Dynamic room joining** with automatic user tracking
    
    ```typescript
    socket.on('join-room', async (data) => {
      await socket.join(data.roomId);
      
      socket.broadcast.to(data.roomId).emit('user-joined', {
        userId: data.userId,
        username: data.username,
        timestamp: new Date()
      });
    });
    ```
  </Card>
  
  <Card title="üí¨ Message Processing" icon="approve-check">
    **Two-layer pipeline** with security and classification
    
    ```typescript
    socket.on('send-message', async (data) => {
      const result = await processMessage(data, socket);
      
      io.to(data.roomId).emit('message-received', {
        ...result,
        timestamp: new Date()
      });
    });
    ```
  </Card>
  
  <Card title="üîÑ State Synchronization" icon="puzzle">
    **Real-time world state** broadcasting
    
    ```typescript
    socket.on('request-world-state', async () => {
      const worldState = await getWorldState();
      
      socket.emit('world-state', {
        users: worldState.activeUsers,
        rooms: worldState.activeRooms,
        stats: worldState.metrics
      });
    });
    ```
  </Card>
</CardGrid>

### Connection Monitoring

<Tabs>
  <TabItem label="Health Checks">
```typescript
export class ConnectionMonitor {
  private healthCheckInterval: NodeJS.Timeout;
  
  constructor(private io: Server) {
    this.startHealthChecks();
  }
  
  private startHealthChecks(): void {
    this.healthCheckInterval = setInterval(() => {
      const stats = {
        totalConnections: this.io.sockets.sockets.size,
        totalRooms: this.io.sockets.adapter.rooms.size,
        timestamp: new Date()
      };
      
      logger.debug(`[SOCKET_MONITOR] ${stats.totalConnections} active connections`);
      
      // Emit to monitoring clients
      this.io.emit('server-stats', stats);
    }, 30000); // Every 30 seconds
  }
  
  getConnectionStats() {
    return {
      connections: this.io.sockets.sockets.size,
      rooms: this.io.sockets.adapter.rooms.size,
      namespaces: Object.keys(this.io._nsps).length
    };
  }
}
```
  </TabItem>
  
  <TabItem label="Error Handling">
```typescript
// Global error handling for Socket.IO
export function setupErrorHandling(io: Server) {
  io.engine.on("connection_error", (err) => {
    logger.error(`[SOCKET_ERROR] Connection failed:`, {
      code: err.code,
      message: err.message,
      context: err.context,
      type: err.type
    });
  });
  
  // Handle individual socket errors
  io.on("connection", (socket) => {
    socket.on("error", (error) => {
      logger.error(`[SOCKET_ERROR] Socket ${socket.id}:`, error);
      
      socket.emit("error", {
        message: "An error occurred",
        code: error.code || "UNKNOWN",
        timestamp: new Date()
      });
    });
    
    socket.on("disconnect", (reason) => {
      logger.info(`[SOCKET_DISCONNECT] ${socket.id}: ${reason}`);
      
      // Cleanup session
      if (socket.data.sessionId) {
        sessionManager.endSession(socket.data.sessionId);
      }
    });
  });
}
```
  </TabItem>
</Tabs>

## üõ°Ô∏è Middleware Pipeline

NUBI implements a sophisticated middleware system for request processing:

<div class="interactive-demo">
  <h3>üîÑ Middleware Chain</h3>
  <div style="font-family: monospace; background: var(--nubi-shadow-black); color: var(--nubi-jackal-gold); padding: 2rem; border-radius: 8px; margin: 2rem 0;">
    Request ‚Üí Authentication ‚Üí Rate Limiting ‚Üí Validation ‚Üí Security ‚Üí
    Processing ‚Üí Response
  </div>
</div>

<Tabs>
  <TabItem label="Authentication Middleware">
```typescript
export function authenticationMiddleware() {
  return async (socket: Socket, next: (err?: ExtendedError) => void) => {
    try {
      const token = socket.handshake.auth.token;
      
      if (!token && process.env.NODE_ENV === 'production') {
        return next(new Error('Authentication required'));
      }
      
      // Verify token if provided
      if (token) {
        const payload = await verifyJWT(token);
        socket.data.userId = payload.userId;
        socket.data.userRole = payload.role;
      }
      
      // Generate anonymous session if no auth
      socket.data.sessionId = crypto.randomUUID();
      socket.data.connectedAt = new Date();
      
      logger.debug(`[AUTH] Socket ${socket.id} authenticated`);
      next();
    } catch (error) {
      logger.error(`[AUTH] Authentication failed:`, error);
      next(new Error('Authentication failed'));
    }
  };
}
```
  </TabItem>
  
  <TabItem label="Rate Limiting Middleware">
```typescript
interface RateLimitStore {
  [socketId: string]: {
    count: number;
    resetTime: number;
    violations: number;
  };
}

export function rateLimitMiddleware(options: RateLimitOptions = {}) {
  const store: RateLimitStore = {};
  const limit = options.maxRequests || 30;
  const window = options.windowMs || 60000; // 1 minute
  
  return async (socket: Socket, next: (err?: ExtendedError) => void) => {
    const now = Date.now();
    const key = socket.id;
    
    if (!store[key]) {
      store[key] = {
        count: 0,
        resetTime: now + window,
        violations: 0
      };
    }
    
    const record = store[key];
    
    if (now > record.resetTime) {
      record.count = 0;
      record.resetTime = now + window;
    }
    
    record.count++;
    
    if (record.count > limit) {
      record.violations++;
      logger.warn(`[RATE_LIMIT] Socket ${socket.id} exceeded limit`);
      
      return next(new Error('Rate limit exceeded'));
    }
    
    next();
  };
}
```
  </TabItem>
  
  <TabItem label="Validation Middleware">
```typescript
export function validationMiddleware() {
  return async (socket: Socket, next: (err?: ExtendedError) => void) => {
    // Validate socket data
    if (!socket.data.sessionId) {
      return next(new Error('Invalid session'));
    }
    
    // Validate origin
    const origin = socket.handshake.headers.origin;
    const allowedOrigins = getAllowedOrigins();
    
    if (process.env.NODE_ENV === 'production' && 
        !allowedOrigins.includes(origin)) {
      logger.warn(`[VALIDATION] Invalid origin: ${origin}`);
      return next(new Error('Invalid origin'));
    }
    
    // Validate user agent (basic bot detection)
    const userAgent = socket.handshake.headers['user-agent'];
    if (isSuspiciousUserAgent(userAgent)) {
      logger.warn(`[VALIDATION] Suspicious user agent: ${userAgent}`);
      return next(new Error('Invalid client'));
    }
    
    next();
  };
}

function isSuspiciousUserAgent(userAgent?: string): boolean {
if (!userAgent) return true;

const suspiciousPatterns = [
/bot/i,
/crawler/i,
/spider/i,
/scraper/i
];

return suspiciousPatterns.some(pattern => pattern.test(userAgent));
}

````
  </TabItem>
</Tabs>

## üì° Event System

### Core Events

<CardGrid>
  <Card title="üîó Connection Events" icon="rocket">
    **connection**, **disconnect**, **connect_error**

    ```typescript
    io.on('connection', (socket) => {
      logger.info(`Client connected: ${socket.id}`);
    });

    socket.on('disconnect', (reason) => {
      logger.info(`Client disconnected: ${reason}`);
    });
    ```
  </Card>

  <Card title="üí¨ Message Events" icon="approve-check">
    **send-message**, **message-received**, **typing**

    ```typescript
    socket.on('send-message', async (data) => {
      const response = await processMessage(data);
      io.to(data.roomId).emit('message-received', response);
    });
    ```
  </Card>

  <Card title="üè† Room Events" icon="setting">
    **join-room**, **leave-room**, **user-joined**, **user-left**

    ```typescript
    socket.on('join-room', async ({ roomId, userId }) => {
      await socket.join(roomId);
      socket.broadcast.to(roomId).emit('user-joined', userId);
    });
    ```
  </Card>

  <Card title="üìä State Events" icon="chart">
    **request-world-state**, **world-state**, **server-stats**

    ```typescript
    socket.on('request-world-state', () => {
      socket.emit('world-state', getCurrentState());
    });
    ```
  </Card>
</CardGrid>

### Custom Event Emitters

<Tabs>
  <TabItem label="Message Processing Events">
```typescript
export class MessageEventEmitter extends EventEmitter {
  constructor(private io: Server) {
    super();
    this.setupEventListeners();
  }

  private setupEventListeners(): void {
    this.on('message-processed', (data) => {
      this.io.to(data.roomId).emit('message-received', {
        id: data.id,
        content: data.content,
        author: data.author,
        timestamp: data.timestamp,
        classification: data.classification
      });
    });

    this.on('ai-thinking', (data) => {
      this.io.to(data.roomId).emit('typing-indicator', {
        userId: 'nubi',
        isTyping: true
      });
    });

    this.on('ai-response-ready', (data) => {
      this.io.to(data.roomId).emit('typing-indicator', {
        userId: 'nubi',
        isTyping: false
      });
    });
  }
}
````

  </TabItem>
  
  <TabItem label="System Events">
```typescript
export class SystemEventEmitter extends EventEmitter {
  constructor(private io: Server) {
    super();
    this.setupSystemEvents();
  }
  
  private setupSystemEvents(): void {
    // Server health events
    this.on('server-overload', (data) => {
      this.io.emit('server-status', {
        status: 'overloaded',
        message: 'Server experiencing high load',
        timestamp: new Date()
      });
    });
    
    // Emergency events
    this.on('emergency-broadcast', (data) => {
      this.io.emit('emergency', {
        type: data.type,
        message: data.message,
        action: data.action,
        timestamp: new Date()
      });
    });
    
    // Maintenance events
    this.on('maintenance-mode', (enabled: boolean) => {
      this.io.emit('maintenance', {
        enabled,
        message: enabled ? 
          'Server entering maintenance mode' : 
          'Server maintenance completed',
        timestamp: new Date()
      });
    });
  }
}
```
  </TabItem>
</Tabs>

## üöÄ Performance Optimization

<Aside type="tip">
  **Performance Tip**: NUBI's Socket.IO server can handle **10,000+ concurrent
  connections** with proper configuration and clustering.
</Aside>

### Connection Pooling

```typescript
export class SocketConnectionPool {
  private connections = new Map<string, SocketConnection>();
  private readonly maxConnections: number;

  constructor(maxConnections = 10000) {
    this.maxConnections = maxConnections;
    this.startCleanupTimer();
  }

  addConnection(socket: Socket): boolean {
    if (this.connections.size >= this.maxConnections) {
      logger.warn("Max connections reached, rejecting new connection");
      return false;
    }

    this.connections.set(socket.id, {
      socket,
      connectedAt: Date.now(),
      lastActivity: Date.now(),
    });

    return true;
  }

  private startCleanupTimer(): void {
    setInterval(
      () => {
        const now = Date.now();
        const timeout = 30 * 60 * 1000; // 30 minutes

        for (const [id, connection] of this.connections) {
          if (now - connection.lastActivity > timeout) {
            connection.socket.disconnect(true);
            this.connections.delete(id);
          }
        }
      },
      5 * 60 * 1000,
    ); // Check every 5 minutes
  }
}
```

### Message Broadcasting Optimization

```typescript
export class BroadcastManager {
  private messageQueues = new Map<string, MessageQueue>();

  async broadcastToRoom(
    roomId: string,
    event: string,
    data: any,
  ): Promise<void> {
    const queue = this.getOrCreateQueue(roomId);

    // Batch messages for efficiency
    queue.add({
      event,
      data,
      timestamp: Date.now(),
    });

    // Process queue if not already processing
    if (!queue.processing) {
      await this.processQueue(roomId);
    }
  }

  private async processQueue(roomId: string): Promise<void> {
    const queue = this.messageQueues.get(roomId);
    if (!queue || queue.processing) return;

    queue.processing = true;

    try {
      while (queue.messages.length > 0) {
        const batch = queue.messages.splice(0, 10); // Process 10 at a time

        for (const message of batch) {
          this.io.to(roomId).emit(message.event, message.data);
        }

        // Small delay to prevent overwhelming clients
        await new Promise((resolve) => setTimeout(resolve, 10));
      }
    } finally {
      queue.processing = false;
    }
  }
}
```

---

<div class="nubi-note">
  <strong>üîó Ready for real-time communication?</strong> Your Socket.IO server
  is now configured with enterprise-grade features. Next, explore{" "}
  <a href="/ux-integration/processing/">Two-Layer Processing</a> to understand
  how messages flow through NUBI's security and classification pipeline.
</div>

## Next Steps

<CardGrid>
  <Card title="üõ°Ô∏è Two-Layer Processing" icon="approve-check">
    Learn about NUBI's advanced security and classification system. [Deep Dive
    ‚Üí](/ux-integration/processing/)
  </Card>

<Card title="üß† Message Classification" icon="puzzle">
  Understand how messages are routed to AI personas. [Explore
  ‚Üí](/ux-integration/classification/)
</Card>

<Card title="üìä Real-time Analytics" icon="chart">
  Monitor Socket.IO performance and user engagement. [Monitor
  ‚Üí](/observability/realtime/)
</Card>

  <Card title="üîß Troubleshooting" icon="warning">
    Common Socket.IO issues and solutions. [Debug ‚Üí](/troubleshooting/socketio/)
  </Card>
</CardGrid>
