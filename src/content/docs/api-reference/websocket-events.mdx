---
title: WebSocket Events
description: Complete WebSocket API reference for real-time communication with NUBI's multi-transport messaging system
sidebar:
  order: 1
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

NUBI's WebSocket API provides real-time bidirectional communication for raid coordination, live updates, and interactive features across all supported platforms.

## Connection Management

### Establishing Connection

Connect to NUBI's WebSocket server using the following endpoint patterns:

<Tabs>
  <TabItem label="Connection URLs">
```typescript
// Development
const devSocket = io('ws://localhost:3000', {
  transports: ['websocket', 'polling'],
  forceNew: true
})

// Production
const prodSocket = io('wss://api.anubis.chat', {
  transports: ['websocket'],
  secure: true,
  rejectUnauthorized: true
})

// With authentication
const authSocket = io('wss://api.anubis.chat', {
  auth: {
    token: 'your-jwt-token',
    userId: 'user-id',
    platform: 'telegram|discord|twitter|web'
  },
  query: {
    version: '1.0',
    features: ['raids', 'leaderboards', 'realtime']
  }
})
```
  </TabItem>
  
  <TabItem label="Connection Events">
```typescript
// Connection lifecycle events
socket.on('connect', () => {
  console.log('Connected to NUBI WebSocket')
  console.log('Socket ID:', socket.id)
})

socket.on('disconnect', (reason) => {
  console.log('Disconnected:', reason)
  // Reasons: 'io server disconnect', 'io client disconnect', 
  //          'ping timeout', 'transport close', 'transport error'
})

socket.on('connect_error', (error) => {
  console.error('Connection error:', error.message)
  // Handle authentication failures, network issues, etc.
})

socket.on('reconnect', (attemptNumber) => {
  console.log('Reconnected after', attemptNumber, 'attempts')
})

// Authentication events
socket.on('authenticated', (userData) => {
  console.log('Authentication successful:', userData)
  // userData contains user profile, permissions, session info
})

socket.on('authentication_error', (error) => {
  console.error('Authentication failed:', error)
  // Handle invalid tokens, expired sessions, etc.
})
```
  </TabItem>
  
  <TabItem label="Client Configuration">
```typescript
interface SocketConfig {
  // Connection options
  url: string
  transports: ('websocket' | 'polling')[]
  timeout: number
  forceNew: boolean
  
  // Authentication
  auth?: {
    token: string
    userId: string
    platform: string
    permissions?: string[]
  }
  
  // Features to enable
  features: {
    raids: boolean
    leaderboards: boolean
    realtime: boolean
    analytics: boolean
  }
  
  // Retry configuration
  reconnection: boolean
  reconnectionAttempts: number
  reconnectionDelay: number
}

// Example configuration
const socketConfig: SocketConfig = {
  url: process.env.WEBSOCKET_URL || 'ws://localhost:3000',
  transports: ['websocket', 'polling'],
  timeout: 20000,
  forceNew: false,
  
  auth: {
    token: await getAuthToken(),
    userId: getCurrentUserId(),
    platform: 'web',
    permissions: ['raids:join', 'leaderboards:view']
  },
  
  features: {
    raids: true,
    leaderboards: true,
    realtime: true,
    analytics: false
  },
  
  reconnection: true,
  reconnectionAttempts: 5,
  reconnectionDelay: 1000
}
```
  </TabItem>
</Tabs>

## Raid Coordination Events

### Raid Lifecycle Events

Real-time raid coordination through WebSocket events:

<Tabs>
  <TabItem label="Raid Management">
```typescript
// Join a raid room for coordination
socket.emit('raid:join', {
  raidId: 'raid_abc123',
  userId: 'user_456',
  capabilities: {
    platforms: ['telegram', 'twitter'],
    timezone: 'UTC-5',
    availableUntil: '2024-01-01T20:00:00Z'
  }
})

// Server response
socket.on('raid:joined', (data) => {
  console.log('Joined raid:', data)
  // data: { raidId, participantCount, strategy, timing, instructions }
})

// Leave raid room
socket.emit('raid:leave', {
  raidId: 'raid_abc123',
  userId: 'user_456',
  reason: 'voluntary' // 'voluntary', 'timeout', 'removed'
})

// Real-time raid updates
socket.on('raid:update', (update) => {
  switch (update.type) {
    case 'participant_joined':
      console.log('New participant:', update.participant)
      break
    case 'participant_left':
      console.log('Participant left:', update.participant)
      break
    case 'strategy_updated':
      console.log('Strategy changed:', update.strategy)
      break
    case 'timing_changed':
      console.log('Timing updated:', update.timing)
      break
    case 'phase_changed':
      console.log('Raid phase:', update.phase)
      break
  }
})
```
  </TabItem>
  
  <TabItem label="Raid Execution">
```typescript
// Pre-raid countdown events
socket.on('raid:countdown', (data) => {
  const { secondsRemaining, message, phase } = data
  
  if (phase === 'preparation') {
    displayCountdown(secondsRemaining, 'Preparing...')
  } else if (phase === 'execution') {
    displayCountdown(secondsRemaining, 'Get ready!')
  }
})

// Raid execution commands
socket.on('raid:execute', (command) => {
  switch (command.action) {
    case 'engage_now':
      executeEngagement(command.target, command.strategy)
      break
    case 'pause_engagement':
      pauseCurrentEngagement()
      break
    case 'adjust_strategy':
      updateEngagementStrategy(command.newStrategy)
      break
    case 'emergency_stop':
      stopAllEngagement(command.reason)
      break
  }
})

// Report engagement completion
socket.emit('raid:engagement_completed', {
  raidId: 'raid_abc123',
  userId: 'user_456',
  engagement: {
    platform: 'twitter',
    targetId: 'tweet_123',
    action: 'like_and_retweet',
    timestamp: Date.now(),
    success: true,
    response: 'Successfully liked and retweeted'
  }
})

// Receive engagement feedback
socket.on('raid:engagement_feedback', (feedback) => {
  const { score, quality, bonuses, nextAction } = feedback
  updateUserScore(score)
  displayQualityFeedback(quality)
  if (nextAction) {
    scheduleNextAction(nextAction)
  }
})
```
  </TabItem>
  
  <TabItem label="Raid Monitoring">
```typescript
// Real-time raid metrics
socket.on('raid:metrics', (metrics) => {
  const {
    participationRate,
    engagementRate,
    qualityScore,
    effectivenessScore,
    timeRemaining,
    currentPhase
  } = metrics
  
  updateRaidDashboard({
    participation: `${participationRate}%`,
    engagement: `${engagementRate}/min`,
    quality: qualityScore.toFixed(2),
    effectiveness: `${effectivenessScore}%`,
    timeLeft: formatTimeRemaining(timeRemaining),
    phase: currentPhase
  })
})

// Individual performance updates
socket.on('raid:performance_update', (performance) => {
  const {
    userId,
    currentScore,
    rank,
    qualityRating,
    streakCount,
    achievements
  } = performance
  
  if (userId === getCurrentUserId()) {
    updatePersonalStats({
      score: currentScore,
      rank: `#${rank}`,
      quality: qualityRating,
      streak: streakCount
    })
    
    // Handle new achievements
    achievements.forEach(achievement => {
      showAchievementUnlock(achievement)
    })
  }
})

// Raid completion events
socket.on('raid:completed', (results) => {
  const {
    raidId,
    success,
    finalMetrics,
    leaderboard,
    rewards,
    summary
  } = results
  
  displayRaidResults({
    success,
    metrics: finalMetrics,
    yourRank: leaderboard.find(p => p.userId === getCurrentUserId())?.rank,
    rewards: rewards.filter(r => r.userId === getCurrentUserId()),
    summary
  })
})
```
  </TabItem>
</Tabs>

## Leaderboard Events

### Real-Time Rankings

Live leaderboard updates and competitive features:

<Tabs>
  <TabItem label="Leaderboard Subscriptions">
```typescript
// Subscribe to leaderboard updates
socket.emit('leaderboard:subscribe', {
  types: ['global', 'weekly', 'seasonal'],
  userId: 'user_456',
  updateFrequency: 'realtime' // 'realtime', 'moderate', 'low'
})

// Unsubscribe from updates
socket.emit('leaderboard:unsubscribe', {
  types: ['global'],
  userId: 'user_456'
})

// Leaderboard update events
socket.on('leaderboard:update', (update) => {
  const { type, entries, userRank, changes } = update
  
  switch (type) {
    case 'global':
      updateGlobalLeaderboard(entries)
      updateUserRank(userRank)
      break
    case 'weekly':
      updateWeeklyLeaderboard(entries)
      break
    case 'seasonal':
      updateSeasonalLeaderboard(entries)
      break
  }
  
  // Highlight ranking changes
  changes.forEach(change => {
    highlightRankingChange(change.userId, change.direction, change.positions)
  })
})

// User-specific ranking events
socket.on('ranking:changed', (rankingChange) => {
  const {
    oldRank,
    newRank,
    leaderboardType,
    pointsGained,
    cause
  } = rankingChange
  
  showRankingNotification({
    direction: newRank < oldRank ? 'up' : 'down',
    positions: Math.abs(newRank - oldRank),
    points: pointsGained,
    reason: cause,
    boardType: leaderboardType
  })
})
```
  </TabItem>
  
  <TabItem label="Achievement Events">
```typescript
// Achievement unlock events
socket.on('achievement:unlocked', (achievement) => {
  const {
    id,
    name,
    description,
    category,
    difficulty,
    pointValue,
    badge,
    rarity
  } = achievement
  
  // Show achievement celebration
  showAchievementCelebration({
    title: name,
    description,
    points: `+${pointValue} points`,
    rarity: `${rarity}% of users have this`,
    badge: badge?.iconUrl
  })
  
  // Update user's achievement collection
  addToAchievementCollection(achievement)
})

// Achievement progress updates
socket.on('achievement:progress', (progress) => {
  const {
    achievementId,
    currentProgress,
    totalRequired,
    percentComplete
  } = progress
  
  updateAchievementProgress(achievementId, {
    current: currentProgress,
    total: totalRequired,
    percent: percentComplete
  })
  
  // Show progress milestone notifications
  if (percentComplete >= 50 && percentComplete < 75) {
    showProgressNotification(achievementId, 'halfway')
  } else if (percentComplete >= 75 && percentComplete < 100) {
    showProgressNotification(achievementId, 'almost_complete')
  }
})

// Badge collection events
socket.on('badge:earned', (badge) => {
  const { id, name, iconUrl, category, earnedAt } = badge
  
  showBadgeEarned({
    name,
    icon: iconUrl,
    category,
    timestamp: earnedAt
  })
  
  addToBadgeCollection(badge)
})
```
  </TabItem>
  
  <TabItem label="Competition Events">
```typescript
// Tournament events
socket.on('tournament:started', (tournament) => {
  const {
    id,
    name,
    participants,
    brackets,
    rules,
    schedule
  } = tournament
  
  showTournamentNotification({
    title: `${name} has started!`,
    participants: participants.length,
    yourBracket: brackets.find(b => 
      b.participants.includes(getCurrentUserId())
    ),
    nextMatch: schedule.nextMatch
  })
})

socket.on('tournament:match_ready', (match) => {
  const { tournamentId, matchId, opponent, deadline } = match
  
  showMatchNotification({
    tournamentName: tournament.name,
    opponent: opponent.username,
    deadline: formatDeadline(deadline),
    action: 'Join match room'
  })
})

// Seasonal competition events
socket.on('season:phase_change', (phaseData) => {
  const { season, newPhase, timeRemaining, rewards } = phaseData
  
  switch (newPhase) {
    case 'final_week':
      showSeasonAlert('Final week! Push for rewards!')
      break
    case 'playoffs':
      showSeasonAlert('Playoffs begin! Elite competition starts now.')
      break
    case 'ended':
      showSeasonEnded(season.results, rewards)
      break
  }
})
```
  </TabItem>
</Tabs>

## Platform Integration Events

### Multi-Platform Synchronization

Cross-platform messaging and coordination events:

<Tabs>
  <TabItem label="Message Broadcasting">
```typescript
// Send message to multiple platforms
socket.emit('message:broadcast', {
  content: 'Check out this amazing project! 🚀',
  platforms: ['telegram', 'discord', 'twitter'],
  targeting: {
    telegram: { chatId: '@anubis_community' },
    discord: { channelId: '123456789' },
    twitter: { hashtags: ['#AnubisChat', '#AI'] }
  },
  scheduling: {
    immediate: false,
    scheduledTime: '2024-01-01T15:00:00Z',
    timezone: 'UTC'
  }
})

// Message delivery confirmations
socket.on('message:delivered', (delivery) => {
  const { messageId, platform, success, timestamp, response } = delivery
  
  updateMessageStatus(messageId, platform, {
    status: success ? 'delivered' : 'failed',
    deliveredAt: timestamp,
    platformResponse: response
  })
})

// Cross-platform message synchronization
socket.on('message:sync', (syncData) => {
  const {
    originalPlatform,
    targetPlatforms,
    messageContent,
    conversationContext
  } = syncData
  
  // Sync conversation across platforms
  syncConversationState(originalPlatform, targetPlatforms, {
    content: messageContent,
    context: conversationContext
  })
})
```
  </TabItem>
  
  <TabItem label="Identity Linking">
```typescript
// Link platform identities
socket.emit('identity:link', {
  primaryUserId: 'user_456',
  platform: 'discord',
  platformUserId: 'discord_789',
  verificationCode: 'ABC123'
})

// Identity linking confirmation
socket.on('identity:linked', (linkData) => {
  const {
    userId,
    platform,
    platformUserId,
    linkedAt,
    totalPlatforms
  } = linkData
  
  showIdentityLinked({
    platform,
    platformId: platformUserId,
    totalConnected: totalPlatforms,
    timestamp: linkedAt
  })
  
  // Update user's connected platforms
  updateConnectedPlatforms(linkData)
})

// Identity verification events
socket.on('identity:verification_required', (verification) => {
  const { platform, verificationMethod, code, expiresAt } = verification
  
  showVerificationPrompt({
    platform,
    method: verificationMethod, // 'dm', 'mention', 'reaction'
    code,
    expiresIn: expiresAt - Date.now()
  })
})
```
  </TabItem>
  
  <TabItem label="Platform Status">
```typescript
// Platform connectivity status
socket.on('platform:status_change', (statusUpdate) => {
  const { platform, status, lastSeen, capabilities } = statusUpdate
  
  updatePlatformStatus(platform, {
    online: status === 'online',
    lastActive: lastSeen,
    features: capabilities
  })
  
  // Show connectivity alerts
  if (status === 'offline') {
    showPlatformOfflineAlert(platform)
  } else if (status === 'online') {
    showPlatformOnlineAlert(platform)
  }
})

// Platform rate limit warnings
socket.on('platform:rate_limit_warning', (warning) => {
  const { platform, limitType, usage, resetAt } = warning
  
  showRateLimitWarning({
    platform,
    type: limitType, // 'messages', 'requests', 'actions'
    currentUsage: usage,
    resetTime: resetAt
  })
})

// Feature availability updates
socket.on('platform:features_updated', (featureUpdate) => {
  const { platform, availableFeatures, disabledFeatures } = featureUpdate
  
  updatePlatformFeatures(platform, {
    available: availableFeatures,
    disabled: disabledFeatures
  })
})
```
  </TabItem>
</Tabs>

## Analytics & Monitoring Events

### Performance Tracking

Real-time analytics and system monitoring:

<Tabs>
  <TabItem label="Performance Metrics">
```typescript
// Subscribe to performance metrics
socket.emit('analytics:subscribe', {
  metrics: ['response_time', 'success_rate', 'user_activity'],
  interval: 30000, // 30 seconds
  userId: 'user_456'
})

// Real-time performance data
socket.on('analytics:metrics', (metrics) => {
  const {
    responseTime,
    successRate,
    activeUsers,
    raidEffectiveness,
    systemHealth
  } = metrics
  
  updatePerformanceDashboard({
    avgResponseTime: `${responseTime}ms`,
    successRate: `${successRate}%`,
    activeUsers: activeUsers.count,
    raidSuccess: `${raidEffectiveness}%`,
    systemStatus: systemHealth.overall
  })
})

// User activity analytics
socket.on('analytics:user_activity', (activity) => {
  const {
    totalEngagements,
    platformBreakdown,
    qualityTrends,
    performanceInsights
  } = activity
  
  updateActivityDashboard({
    engagements: totalEngagements,
    platforms: platformBreakdown,
    qualityTrend: qualityTrends.direction,
    insights: performanceInsights
  })
})
```
  </TabItem>
  
  <TabItem label="System Alerts">
```typescript
// System health alerts
socket.on('system:alert', (alert) => {
  const { level, component, message, timestamp, actionRequired } = alert
  
  switch (level) {
    case 'critical':
      showCriticalAlert(message, actionRequired)
      break
    case 'warning':
      showWarningAlert(message)
      break
    case 'info':
      showInfoAlert(message)
      break
  }
  
  // Log alert for debugging
  console[level](`[${component}] ${message}`, { timestamp, alert })
})

// Maintenance notifications
socket.on('system:maintenance', (maintenance) => {
  const { type, startTime, duration, affectedServices } = maintenance
  
  showMaintenanceNotification({
    type, // 'scheduled', 'emergency', 'completed'
    when: startTime,
    duration: formatDuration(duration),
    services: affectedServices
  })
})

// Service availability updates
socket.on('system:service_status', (serviceStatus) => {
  const { service, status, responseTime, errorRate } = serviceStatus
  
  updateServiceIndicator(service, {
    online: status === 'operational',
    latency: responseTime,
    errors: errorRate
  })
})
```
  </TabItem>
</Tabs>

## Error Handling & Recovery

### Connection Recovery

Robust error handling and automatic recovery mechanisms:

```typescript
class WebSocketManager {
  private socket: Socket
  private reconnectAttempts = 0
  private maxReconnectAttempts = 5
  private eventQueue: QueuedEvent[] = []
  
  constructor(config: SocketConfig) {
    this.initializeSocket(config)
    this.setupErrorHandling()
    this.setupReconnection()
  }
  
  private setupErrorHandling(): void {
    // Handle connection errors
    this.socket.on('connect_error', (error) => {
      console.error('Connection error:', error)
      this.handleConnectionError(error)
    })
    
    // Handle authentication errors
    this.socket.on('authentication_error', (error) => {
      console.error('Authentication failed:', error)
      this.handleAuthError(error)
    })
    
    // Handle server errors
    this.socket.on('error', (error) => {
      console.error('Server error:', error)
      this.handleServerError(error)
    })
    
    // Handle rate limiting
    this.socket.on('rate_limited', (limitInfo) => {
      console.warn('Rate limited:', limitInfo)
      this.handleRateLimit(limitInfo)
    })
  }
  
  private setupReconnection(): void {
    this.socket.on('disconnect', (reason) => {
      console.log('Disconnected:', reason)
      
      if (reason === 'io server disconnect') {
        // Server disconnected us - don't reconnect automatically
        this.handleServerDisconnect()
      } else {
        // Network/client issues - attempt reconnection
        this.attemptReconnection()
      }
    })
    
    this.socket.on('reconnect', (attemptNumber) => {
      console.log(`Reconnected after ${attemptNumber} attempts`)
      this.onSuccessfulReconnect()
    })
    
    this.socket.on('reconnect_failed', () => {
      console.error('Reconnection failed after maximum attempts')
      this.handleReconnectionFailure()
    })
  }
  
  private async onSuccessfulReconnect(): Promise<void> {
    // Re-authenticate if necessary
    await this.reAuthenticate()
    
    // Restore subscriptions
    await this.restoreSubscriptions()
    
    // Process queued events
    await this.processEventQueue()
    
    // Sync any missed state
    await this.syncMissedState()
  }
  
  private async processEventQueue(): Promise<void> {
    while (this.eventQueue.length > 0) {
      const event = this.eventQueue.shift()
      if (event && Date.now() - event.timestamp < 300000) { // 5 minutes
        try {
          this.socket.emit(event.type, event.data)
        } catch (error) {
          console.error('Failed to replay queued event:', error)
        }
      }
    }
  }
}
```

The WebSocket API provides comprehensive real-time capabilities for all aspects of NUBI's functionality, enabling seamless coordination, live updates, and interactive features across all supported platforms.