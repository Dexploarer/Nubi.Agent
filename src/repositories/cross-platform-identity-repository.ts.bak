import { eq, and, or } from "drizzle-orm";
import { type PostgresJsDatabase } from "drizzle-orm/postgres-js";
import { UUID, logger } from "@elizaos/core";
import { cross_platform_identities } from "../schemas/elizaos-schemas";

export interface CrossPlatformIdentity {
  id: UUID;
  userUuid: UUID;
  platform: string;
  platformUserId: string;
  username?: string;
  displayName?: string;
  metadata?: Record<string, any>;
  verified: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export class CrossPlatformIdentityRepository {
  constructor(private readonly db: PostgresJsDatabase<any>) {}

  /**
   * Create or update a platform identity
   */
  async upsert(params: {
    userUuid: UUID;
    platform: string;
    platformUserId: string;
    username?: string;
    displayName?: string;
    metadata?: Record<string, any>;
    verified?: boolean;
  }): Promise<CrossPlatformIdentity> {
    try {
      // Check if identity exists
      const existing = await this.findByPlatformUser(
        params.platform,
        params.platformUserId
      );

      if (existing) {
        // Update existing identity
        const [updated] = await this.db
          .update(cross_platform_identities)
          .set({
            username: params.username || existing.username,
            display_name: params.displayName || existing.displayName,
            metadata: { ...existing.metadata, ...params.metadata },
            verified: params.verified ?? existing.verified,
            updated_at: new Date(),
          })
          .where(
            and(
              eq(cross_platform_identities.platform, params.platform),
              eq(cross_platform_identities.platform_user_id, params.platformUserId)
            )
          )
          .returning();

        return this.mapToIdentity(updated);
      } else {
        // Create new identity
        const [created] = await this.db
          .insert(cross_platform_identities)
          .values({
            user_uuid: params.userUuid,
            platform: params.platform,
            platform_user_id: params.platformUserId,
            username: params.username,
            display_name: params.displayName,
            metadata: params.metadata || {},
            verified: params.verified || false,
            created_at: new Date(),
            updated_at: new Date(),
          })
          .returning();

        return this.mapToIdentity(created);
      }
    } catch (error) {
      logger.error("[CrossPlatformIdentityRepository] Upsert failed:", error);
      throw error;
    }
  }

  /**
   * Find identity by platform and user ID
   */
  async findByPlatformUser(
    platform: string,
    platformUserId: string
  ): Promise<CrossPlatformIdentity | null> {
    const result = await this.db
      .select()
      .from(cross_platform_identities)
      .where(
        and(
          eq(cross_platform_identities.platform, platform),
          eq(cross_platform_identities.platform_user_id, platformUserId)
        )
      )
      .limit(1);

    return result.length > 0 ? this.mapToIdentity(result[0]) : null;
  }

  /**
   * Find all identities for a user
   */
  async findByUserUuid(userUuid: UUID): Promise<CrossPlatformIdentity[]> {
    const results = await this.db
      .select()
      .from(cross_platform_identities)
      .where(eq(cross_platform_identities.user_uuid, userUuid));

    return results.map((r) => this.mapToIdentity(r));
  }

  /**
   * Find user UUID by any platform identity
   */
  async findUserUuid(
    platform: string,
    platformUserId: string
  ): Promise<UUID | null> {
    const identity = await this.findByPlatformUser(platform, platformUserId);
    return identity?.userUuid || null;
  }

  /**
   * Link two platform identities together
   */
  async linkIdentities(
    platform1: string,
    userId1: string,
    platform2: string,
    userId2: string
  ): Promise<boolean> {
    try {
      // Find both identities
      const identity1 = await this.findByPlatformUser(platform1, userId1);
      const identity2 = await this.findByPlatformUser(platform2, userId2);

      if (!identity1 || !identity2) {
        return false;
      }

      // Use the first identity's userUuid as the primary
      const primaryUuid = identity1.userUuid;

      // Update second identity to use same userUuid
      await this.db
        .update(cross_platform_identities)
        .set({
          user_uuid: primaryUuid,
          updated_at: new Date(),
        })
        .where(
          and(
            eq(cross_platform_identities.platform, platform2),
            eq(cross_platform_identities.platform_user_id, userId2)
          )
        );

      return true;
    } catch (error) {
      logger.error("[CrossPlatformIdentityRepository] Link failed:", error);
      return false;
    }
  }

  /**
   * Verify an identity
   */
  async verify(platform: string, platformUserId: string): Promise<boolean> {
    const [updated] = await this.db
      .update(cross_platform_identities)
      .set({
        verified: true,
        updated_at: new Date(),
      })
      .where(
        and(
          eq(cross_platform_identities.platform, platform),
          eq(cross_platform_identities.platform_user_id, platformUserId)
        )
      )
      .returning();

    return !!updated;
  }

  /**
   * Search identities by username
   */
  async searchByUsername(
    username: string,
    platform?: string
  ): Promise<CrossPlatformIdentity[]> {
    let query = this.db
      .select()
      .from(cross_platform_identities)
      .where(
        or(
          eq(cross_platform_identities.username, username),
          eq(cross_platform_identities.display_name, username)
        )
      );

    if (platform) {
      query = query.where(eq(cross_platform_identities.platform, platform));
    }

    const results = await query;
    return results.map((r) => this.mapToIdentity(r));
  }

  /**
   * Delete an identity
   */
  async delete(id: UUID): Promise<boolean> {
    const result = await this.db
      .delete(cross_platform_identities)
      .where(eq(cross_platform_identities.id, id))
      .returning();

    return result.length > 0;
  }

  /**
   * Map database row to domain type
   */
  private mapToIdentity(row: any): CrossPlatformIdentity {
    return {
      id: row.id as UUID,
      userUuid: row.user_uuid as UUID,
      platform: row.platform,
      platformUserId: row.platform_user_id,
      username: row.username,
      displayName: row.display_name,
      metadata: row.metadata || {},
      verified: row.verified,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    };
  }
}
