/**
 * NUBI Raid System - Consolidated E2E Integration
 * Single source of truth for all raid operations
 * @module nubi-raid-system
 */

import { EventEmitter } from 'events';
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { Server as SocketServer } from 'socket.io';
import { z } from 'zod';
import type { 
    IAgentRuntime, 
    Memory, 
    State, 
    Action,
    HandlerCallback 
} from '@elizaos/core';

// ============================================================================
// SCHEMAS & TYPES
// ============================================================================

/**
 * Core raid session schema
 */
export const RaidSessionSchema = z.object({
    id: z.string().uuid(),
    sessionId: z.string(),
    targetUrl: z.string().url(),
    platform: z.enum(['telegram', 'discord', 'slack']),
    targetPlatform: z.enum(['twitter', 'x', 'instagram', 'youtube', 'tiktok']),
    status: z.enum(['pending', 'active', 'completed', 'cancelled']),
    startedAt: z.date(),
    endedAt: z.date().optional(),
    scheduledFor: z.date().optional(),
    durationMinutes: z.number().min(5).max(120),
    createdBy: z.string().uuid().optional(),
    metadata: z.record(z.any()).optional()
});

export type RaidSession = z.infer<typeof RaidSessionSchema>;

/**
 * Participant schema
 */
export const RaidParticipantSchema = z.object({
    id: z.string().uuid(),
    raidId: z.string().uuid(),
    userId: z.string().uuid().optional(),
    telegramId: z.string(),
    username: z.string(),
    joinedAt: z.date(),
    leftAt: z.date().optional(),
    isActive: z.boolean(),
    role: z.enum(['leader', 'elite', 'veteran', 'member', 'rookie']),
    actionsCount: z.number().default(0),
    pointsEarned: z.number().default(0),
    qualityScore: z.number().min(0).max(1).default(0.5)
});

export type RaidParticipant = z.infer<typeof RaidParticipantSchema>;

/**
 * Engagement action schema
 */
export const EngagementSchema = z.object({
    id: z.string().uuid(),
    raidId: z.string().uuid(),
    participantId: z.string().uuid(),
    actionType: z.enum(['like', 'retweet', 'comment', 'share', 'quote', 'view']),
    content: z.string().optional(),
    verified: z.boolean().default(false),
    pointsAwarded: z.number().min(0),
    timestamp: z.date()
});

export type Engagement = z.infer<typeof EngagementSchema>;

/**
 * Raid configuration
 */
export interface RaidConfig {
    supabase: {
        url: string;
        anonKey: string;
        serviceKey?: string;
    };
    telegram: {
        botToken: string;
        chatId: string;
    };
    socketIO: {
        port: number;
        namespace: string;
    };
    points: {
        like: number;
        retweet: number;
        comment: number;
        share: number;
        quote: number;
        view: number;
    };
        view: number;
    limits: {
        maxParticipants: number;
        minParticipants: number;
        defaultDuration: number;
    };
}

// ============================================================================
// MAIN RAID SYSTEM CLASS
// ============================================================================

/**
 * Consolidated NUBI Raid System
 * Handles all raid operations with no duplicates
 */
export class NUBIRaidSystem extends EventEmitter {
    private runtime: IAgentRuntime;
    private supabase: SupabaseClient;
    private io: SocketServer | null = null;
    private config: RaidConfig;
    private activeRaids: Map<string, RaidSession>;
    private participants: Map<string, Set<string>>; // raidId -> participantIds

    constructor(runtime: IAgentRuntime, config: RaidConfig) {
        super();
        this.runtime = runtime;
        this.config = config;
        this.activeRaids = new Map();
        this.participants = new Map();

        // Initialize Supabase
        this.supabase = createClient(
            config.supabase.url,
            config.supabase.serviceKey || config.supabase.anonKey
        );

        this.setupRealtimeSubscriptions();
    }

    /**
     * Initialize Socket.IO server
     */
    initializeSocketIO(server: any): void {
        this.io = new SocketServer(server, {
            cors: {
                origin: "*",
                methods: ["GET", "POST"]
            }
        });

        const raidNamespace = this.io.of(this.config.socketIO.namespace);
        
        raidNamespace.on('connection', (socket) => {
            console.log(`[NUBI] Client connected: ${socket.id}`);
            
            socket.on('raid:join', (data) => this.handleSocketJoin(socket, data));
            socket.on('raid:engagement', (data) => this.handleSocketEngagement(socket, data));
            socket.on('raid:status', (data) => this.handleSocketStatus(socket, data));
            
            socket.on('disconnect', () => {
                console.log(`[NUBI] Client disconnected: ${socket.id}`);
            });
        });
    }

    /**
     * Setup Supabase realtime subscriptions
     */
    private setupRealtimeSubscriptions(): void {
        // Subscribe to raid updates
        this.supabase
            .channel('raids-channel')
            .on(
                'postgres_changes',
                { event: '*', schema: 'public', table: 'raids' },
                (payload) => this.handleDatabaseChange('raids', payload)
            )
            .on(
                'postgres_changes',
                { event: '*', schema: 'public', table: 'raid_participants' },
                (payload) => this.handleDatabaseChange('participants', payload)
            )
            .subscribe();
    }

    // ========================================================================
    // CORE RAID OPERATIONS
    // ========================================================================

    /**
     * Start a new raid
     */
    async startRaid(params: {
        targetUrl: string;
        initiator: {
            id: string;
            username: string;
            telegramId?: string;
        };
        duration?: number;
        scheduled?: Date;
    }): Promise<RaidSession> {
        try {
            // Generate session ID
            const sessionId = `raid_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
            
            // Extract target platform from URL
            const targetPlatform = this.extractPlatform(params.targetUrl);
            
            // Create raid in database
            const { data: raid, error } = await this.supabase
                .from('raids')
                .insert({
                    session_id: sessionId,
                    target_url: params.targetUrl,
                    target_platform: targetPlatform,
                    platform: 'telegram',
                    status: params.scheduled ? 'pending' : 'active',
                    duration_minutes: params.duration || this.config.limits.defaultDuration,
                    scheduled_for: params.scheduled,
                    created_by: params.initiator.id,
                    metadata: {
                        initiator_username: params.initiator.username,
                        initiator_telegram_id: params.initiator.telegramId
                    }
                })
                .select()
                .single();

            if (error) throw error;

            // Cache active raid
            const raidSession = this.transformDatabaseRaid(raid);
            this.activeRaids.set(sessionId, raidSession);
            this.participants.set(raid.id, new Set());

            // Emit events
            this.emit('raid:started', raidSession);
            this.broadcastToSocket('raid:started', raidSession);

            // Schedule auto-end if not scheduled
            if (!params.scheduled) {
                setTimeout(() => {
                    this.endRaid(sessionId, 'time_expired');
                }, (params.duration || this.config.limits.defaultDuration) * 60 * 1000);
            }

            return raidSession;

        } catch (error) {
            console.error('[NUBI] Failed to start raid:', error);
            throw error;
        }
    }

    /**
     * Join an active raid
     */
    async joinRaid(
        sessionId: string,
        participant: {
            telegramId: string;
            username: string;
            userId?: string;
        }
    ): Promise<RaidParticipant> {
        try {
            // Get raid
            const raid = this.activeRaids.get(sessionId);
            if (!raid) {
                throw new Error('Raid not found or not active');
            }

            // Check participant limit
            const participantCount = this.participants.get(raid.id)?.size || 0;
            if (participantCount >= this.config.limits.maxParticipants) {
                throw new Error('Raid is full');
            }

            // Determine role based on experience
            const role = await this.determineParticipantRole(participant.telegramId);

            // Add to database
            const { data: dbParticipant, error } = await this.supabase
                .from('raid_participants')
                .upsert({
                    raid_id: raid.id,
                    telegram_id: participant.telegramId,
                    username: participant.username,
                    user_id: participant.userId || "",
                    role,
                    is_active: true
                }, {
                    onConflict: 'raid_id,telegram_id'
                })
                .select()
                .single();

            if (error) throw error;

            // Update cache
            this.participants.get(raid.id)?.add(dbParticipant.id);

            // Emit events
            const raidParticipant = this.transformDatabaseParticipant(dbParticipant);
            this.emit('participant:joined', { raid, participant: raidParticipant });
            this.broadcastToSocket('participant:joined', { 
                sessionId, 
                participant: raidParticipant 
            });

            return raidParticipant;

        } catch (error) {
            console.error('[NUBI] Failed to join raid:', error);
            throw error;
        }
    }

    /**
     * Submit an engagement action
     */
    async submitEngagement(params: {
        sessionId: string;
        participantId: string;
        actionType: 'like' | 'retweet' | 'comment' | 'share' | 'quote' | 'view';
        content?: string;
        proofUrl?: string;
    }): Promise<{
        valid: boolean;
        points: number;
        feedback: string;
        newRank?: number;
    }> {
        try {
            const raid = this.activeRaids.get(params.sessionId);
            if (!raid || raid.status !== 'active') {
                throw new Error('Raid not active');
            }

            // Validate engagement
            const isValid = await this.validateEngagement(params);
            if (!isValid) {
                return {
                    valid: false,
                    points: 0,
                    feedback: 'Engagement validation failed'
                };
            }

            // Calculate points
            const points = this.config.points[params.actionType] || 10;
            
            // Record engagement
            const { error } = await this.supabase
                .from('raid_engagements')
                .insert({
                    raid_id: raid.id,
                    participant_id: params.participantId,
                    action_type: params.actionType,
                    content: params.content,
                    verified: true,
                    points_awarded: points
                });

            if (error) throw error;

            // Update participant points
            await this.supabase
                .from('raid_participants')
                .update({
                    actions_count: this.supabase.rpc('actions_count + 1'),
                    points_earned: this.supabase.rpc(`points_earned + ${points}`),
                    last_action_at: new Date().toISOString()
                })
                .eq('id', params.participantId);

            // Get new rank
            const newRank = await this.getParticipantRank(raid.id, params.participantId);

            // Emit events
            this.emit('engagement:validated', {
                raid,
                participantId: params.participantId,
                actionType: params.actionType,
                points
            });

            this.broadcastToSocket('engagement:validated', {
                sessionId: params.sessionId,
                participantId: params.participantId,
                points,
                newRank
            });

            return {
                valid: true,
                points,
                feedback: `Great ${params.actionType}! +${points} points`,
                newRank
            };

        } catch (error) {
            console.error('[NUBI] Failed to submit engagement:', error);
            throw error;
        }
    }

    /**
     * Get raid status and analytics
     */
    async getRaidStatus(sessionId: string): Promise<{
        raid: RaidSession;
        participants: number;
        totalEngagements: number;
        totalPoints: number;
        leaderboard: Array<{
            rank: number;
            username: string;
            points: number;
        }>;
    }> {
        try {
            const raid = this.activeRaids.get(sessionId);
            if (!raid) {
                // Try to fetch from database
                const { data } = await this.supabase
                    .from('raids')
                    .select('*')
                    .eq('session_id', sessionId)
                    .single();
                
                if (!data) throw new Error('Raid not found');
                return this.getRaidStatusFromDatabase(data.id);
            }

            // Get stats from database
            const stats = await this.getRaidStatusFromDatabase(raid.id);
            return { ...stats, raid };

        } catch (error) {
            console.error('[NUBI] Failed to get raid status:', error);
            throw error;
        }
    }

    /**
     * End a raid
     */
    async endRaid(
        sessionId: string, 
        reason: 'completed' | 'cancelled' | 'time_expired' = 'completed'
    ): Promise<{
        finalStats: any;
        topPerformers: any[];
    }> {
        try {
            const raid = this.activeRaids.get(sessionId);
            if (!raid) {
                throw new Error('Raid not found');
            }

            // Update database
            const { error } = await this.supabase
                .from('raids')
                .update({
                    status: reason === 'cancelled' ? 'cancelled' : 'completed',
                    ended_at: new Date().toISOString()
                })
                .eq('id', raid.id);

            if (error) throw error;

            // Get final stats
            const finalStats = await this.getRaidStatusFromDatabase(raid.id);
            
            // Get top performers
            const { data: topPerformers } = await this.supabase
                .from('raid_participants')
                .select('username, points_earned, actions_count')
                .eq('raid_id', raid.id)
                .order('points_earned', { ascending: false })
                .limit(10);

            // Clean up cache
            this.activeRaids.delete(sessionId);
            this.participants.delete(raid.id);

            // Emit events
            this.emit('raid:ended', {
                raid,
                reason,
                finalStats,
                topPerformers
            });

            this.broadcastToSocket('raid:ended', {
                sessionId,
                reason,
                finalStats,
                topPerformers
            });

            return {
                finalStats,
                topPerformers: topPerformers || []
            };

        } catch (error) {
            console.error('[NUBI] Failed to end raid:', error);
            throw error;
        }
    }

    // ========================================================================
    // HELPER METHODS
    // ========================================================================

    private extractPlatform(url: string): string {
        if (url.includes('twitter.com') || url.includes('x.com')) return 'twitter';
        if (url.includes('instagram.com')) return 'instagram';
        if (url.includes('youtube.com')) return 'youtube';
        if (url.includes('tiktok.com')) return 'tiktok';
        return 'unknown';
    }

    private async determineParticipantRole(telegramId: string): Promise<string> {
        // Check history
        const { data } = await this.supabase
            .from('raid_participants')
            .select('points_earned')
            .eq('telegram_id', telegramId);

        const totalPoints = data?.reduce((sum, p) => sum + (p.points_earned || 0), 0) || 0;
        
        if (totalPoints >= 10000) return 'legend';
        if (totalPoints >= 5000) return 'elite';
        if (totalPoints >= 1000) return 'veteran';
        if (totalPoints >= 100) return 'member';
        return 'rookie';
    }

    private async validateEngagement(params: any): Promise<boolean> {
        // Check for duplicate
        const { data } = await this.supabase
            .from('raid_engagements')
            .select('id')
            .eq('raid_id', this.activeRaids.get(params.sessionId)?.id)
            .eq('participant_id', params.participantId)
            .eq('action_type', params.actionType)
            .single();

        return !data; // Valid if no duplicate found
    }

    private async getParticipantRank(raidId: string, participantId: string): Promise<number> {
        const { data } = await this.supabase
            .from('raid_participants')
            .select('id, points_earned')
            .eq('raid_id', raidId)
            .order('points_earned', { ascending: false });

        const index = data?.findIndex(p => p.id === participantId) ?? -1;
        return index + 1;
    }

    private async getRaidStatusFromDatabase(raidId: string): Promise<any> {
        const [raidData, participantsData, engagementsData] = await Promise.all([
            this.supabase.from('raids').select('*').eq('id', raidId).single(),
            this.supabase.from('raid_participants').select('*').eq('raid_id', raidId),
            this.supabase.from('raid_engagements').select('*').eq('raid_id', raidId)
        ]);

        const participants = participantsData.data?.length || 0;
        const totalEngagements = engagementsData.data?.length || 0;
        const totalPoints = participantsData.data?.reduce(
            (sum, p) => sum + (p.points_earned || 0), 0
        ) || 0;

        const leaderboard = (participantsData.data || [])
            .sort((a, b) => (b.points_earned || 0) - (a.points_earned || 0))
            .slice(0, 10)
            .map((p, i) => ({
                rank: i + 1,
                username: p.username,
                points: p.points_earned || 0
            }));

        return {
            participants,
            totalEngagements,
            totalPoints,
            leaderboard
        };
    }

    private transformDatabaseRaid(dbRaid: any): RaidSession {
        return {
            id: dbRaid.id,
            sessionId: dbRaid.session_id,
            targetUrl: dbRaid.target_url,
            platform: dbRaid.platform,
            targetPlatform: dbRaid.target_platform,
            status: dbRaid.status,
            startedAt: new Date(dbRaid.started_at),
            endedAt: dbRaid.ended_at ? new Date(dbRaid.ended_at) : undefined,
            scheduledFor: dbRaid.scheduled_for ? new Date(dbRaid.scheduled_for) : undefined,
            durationMinutes: dbRaid.duration_minutes,
            createdBy: dbRaid.created_by,
            metadata: dbRaid.metadata
        };
    }

    private transformDatabaseParticipant(dbParticipant: any): RaidParticipant {
        return {
            id: dbParticipant.id,
            raidId: dbParticipant.raid_id,
            userId: dbParticipant.user_id,
            telegramId: dbParticipant.telegram_id,
            username: dbParticipant.username,
            joinedAt: new Date(dbParticipant.joined_at),
            leftAt: dbParticipant.left_at ? new Date(dbParticipant.left_at) : undefined,
            isActive: dbParticipant.is_active,
            role: dbParticipant.role,
            actionsCount: dbParticipant.actions_count || 0,
            pointsEarned: dbParticipant.points_earned || 0,
            qualityScore: dbParticipant.quality_score || 0.5
        };
    }

    private handleDatabaseChange(table: string, payload: any): void {
        console.log(`[NUBI] Database change in ${table}:`, payload.eventType);
        this.emit(`db:${table}:${payload.eventType}`, payload);
    }

    private handleSocketJoin(socket: any, data: any): void {
        socket.join(`raid:${data.sessionId}`);
        this.joinRaid(data.sessionId, data.participant);
    }

    private handleSocketEngagement(socket: any, data: any): void {
        this.submitEngagement(data);
    }

    private handleSocketStatus(socket: any, data: any): void {
        this.getRaidStatus(data.sessionId).then(status => {
            socket.emit('raid:status:response', status);
        });
    }

    private broadcastToSocket(event: string, data: any): void {
        if (this.io) {
            this.io.of(this.config.socketIO.namespace).emit(event, data);
        }
    }

    /**
     * Get all active raids
     */
    getActiveRaids(): RaidSession[] {
        return Array.from(this.activeRaids.values());
    }

    /**
     * Clean up resources
     */
    async cleanup(): Promise<void> {
        // End all active raids
        for (const [sessionId, raid] of this.activeRaids) {
            await this.endRaid(sessionId, 'cancelled');
        }

        // Close connections
        if (this.io) {
            this.io.close();
        }

        await this.supabase.removeAllChannels();
    }
}

// ============================================================================
// ELIZA ACTION INTEGRATION
// ============================================================================

/**
 * ElizaOS Action for starting raids
 */
export const startRaidAction: Action = {
    name: 'START_RAID',
    similes: ['RAID', 'BEGIN_RAID', 'INITIATE_RAID'],
    description: 'Start a new raid campaign',
    
    validate: async (runtime: IAgentRuntime, message: Memory) => {
        const text = message.content.text;
        return text.includes('/raid') || text.includes('!raid');
    },

    handler: async (
        runtime: IAgentRuntime,
        message: Memory,
        state: State,
        options: any,
        callback?: HandlerCallback
    ) => {
        try {
            // Extract URL from message
            const urlMatch = message.content.text.match(/https?:\/\/[^\s]+/);
            if (!urlMatch) {
                callback?.(false, 'Please provide a target URL');
                return;
            }

            // Get raid system instance
            const raidSystem = runtime.getSetting('raidSystem') as NUBIRaidSystem;
            if (!raidSystem) {
                callback?.(false, 'Raid system not initialized');
                return;
            }

            // Start raid
            const raid = await raidSystem.startRaid({
                targetUrl: urlMatch[0],
                initiator: {
                    id: message.userId || "",
                    username: message.userId || "",
                    telegramId: message.userId || ""
                }
            });

            const response = `🚀 Raid Started!\nSession: ${raid.sessionId}\nTarget: ${raid.targetUrl}\nJoin with /join ${raid.sessionId}`;
            
            callback?.(true, response);
        } catch (error) {
            console.error('Failed to start raid:', error);
            callback?.(false, 'Failed to start raid');
        }
    },

    examples: [
        [
            {
                user: '{{user1}}',
                content: { text: '/raid https://x.com/elonmusk/status/123456' }
            },
            {
                user: '{{agentName}}',
                content: { text: '🚀 Raid Started! Session: raid_2024_abc123' }
            }
        ]
    ]
};

/**
 * Factory function to create and initialize the raid system
 */
export async function createNUBIRaidSystem(
    runtime: IAgentRuntime,
    config?: Partial<RaidConfig>
): Promise<NUBIRaidSystem> {
    const defaultConfig: RaidConfig = {
        supabase: {
            url: process.env.SUPABASE_URL || '',
            anonKey: process.env.SUPABASE_ANON_KEY || '',
            serviceKey: process.env.SUPABASE_SERVICE_ROLE_KEY
        },
        telegram: {
            botToken: process.env.TELEGRAM_BOT_TOKEN || '',
            chatId: process.env.TELEGRAM_CHAT_ID || ''
        },
        socketIO: {
            port: 3001,
            namespace: '/raids'
        },
        points: {
            like: 10,
            retweet: 20,
            comment: 30,
            share: 25,
            quote: 40,
            view: 1,
        },
        limits: {
            maxParticipants: 100,
            minParticipants: 5,
            defaultDuration: 30
        }
    };

    const finalConfig = { ...defaultConfig, ...config };
    const raidSystem = new NUBIRaidSystem(runtime, finalConfig);
    
    // Store in runtime for access by actions
    runtime.setSetting('raidSystem', raidSystem);
    
    return raidSystem;
}

export default NUBIRaidSystem;
