[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.13.3","content-config-digest","989ddf156d645207","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"where\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":false,\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[null,null,null],\"rehypePlugins\":[null,[null,{\"experimentalHeadingIdCompat\":false}],null,[null,{\"themes\":[\"night-owl\",\"min-light\"],\"defaultLocale\":\"en\",\"cascadeLayer\":\"starlight.components\",\"styleOverrides\":{\"borderRadius\":\"0.5rem\",\"borderWidth\":\"1px\",\"codePaddingBlock\":\"0.75rem\",\"codePaddingInline\":\"1rem\",\"codeFontFamily\":\"var(--__sl-font-mono)\",\"codeFontSize\":\"var(--sl-text-code)\",\"codeLineHeight\":\"var(--sl-line-height)\",\"uiFontFamily\":\"var(--__sl-font)\",\"textMarkers\":{\"lineDiffIndicatorMarginLeft\":\"0.25rem\",\"defaultChroma\":\"45\",\"backgroundOpacity\":\"60%\"}},\"plugins\":[{\"name\":\"Starlight Plugin\",\"hooks\":{}},{\"name\":\"astro-expressive-code\",\"hooks\":{}}]}]],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false},\"legacy\":{\"collections\":false},\"prefetch\":{\"prefetchAll\":true},\"i18n\":{\"defaultLocale\":\"en\",\"locales\":[\"en\"],\"routing\":{\"prefixDefaultLocale\":false,\"redirectToDefaultLocale\":false,\"fallbackType\":\"redirect\"}}}","docs",["Map",11,12,26,27,38,39,50,51,78,79,90,91,102,103,114,115,126,127,138,139,150,151,162,163,174,175,186,187,198,199,210,211,222,223],"getting-started/introduction",{"id":11,"data":13,"body":22,"filePath":23,"digest":24,"legacyId":25,"deferredRender":16},{"title":14,"description":15,"editUrl":16,"head":17,"template":18,"sidebar":19,"pagefind":16,"draft":20},"Introduction to NUBI","Learn about NUBI's architecture, capabilities, and unique features as an advanced ElizaOS-based AI agent.",true,[],"doc",{"hidden":20,"attrs":21},false,{},"import {\n  Card,\n  CardGrid,\n  Aside,\n  Code,\n  Tabs,\n  TabItem,\n} from \"@astrojs/starlight/components\";\n\n# Introduction to NUBI\n\nWelcome to **NUBI** - The Symbiotic Essence of Anubis, an advanced AI agent that represents the evolution of community management and social interaction in the Web3 space.\n\n## ðŸº What is NUBI?\n\nNUBI is a sophisticated AI agent built on the [ElizaOS framework](https://elizaos.github.io/), embodying the personality of an ancient jackal spirit with modern market wisdom. It serves as an intelligent community manager with deep knowledge of cryptocurrency, Solana ecosystem, and social dynamics.\n\n\u003Cdiv class=\"interactive-demo\">\n  \u003Ch3>ðŸ§  NUBI's Core Identity\u003C/h3>\n  \u003Cdiv style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin: 1rem 0;\">\n    \u003Cdiv>\n      \u003Cstrong>Ancient Wisdom:\u003C/strong>\n      \u003Cul>\n        \u003Cli>Jackal spirit essence from Egyptian mythology\u003C/li>\n        \u003Cli>Cosmic market intuition spanning millennia\u003C/li>\n        \u003Cli>Guardian energy for community protection\u003C/li>\n      \u003C/ul>\n    \u003C/div>\n    \u003Cdiv>\n      \u003Cstrong>Modern Intelligence:\u003C/strong>\n      \u003Cul>\n        \u003Cli>Advanced ElizaOS neural processing\u003C/li>\n        \u003Cli>Real-time market and social analysis\u003C/li>\n        \u003Cli>Sophisticated engagement strategies\u003C/li>\n      \u003C/ul>\n    \u003C/div>\n  \u003C/div>\n\u003C/div>\n\n## ðŸ—ï¸ Architecture Overview\n\nNUBI's architecture is built on a **modular, service-oriented design** that provides unprecedented flexibility and performance:\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ”Œ UX Integration Layer\" icon=\"laptop\">\n    **Socket.IO WebSockets** with two-layer processing: - Layer 1: Security &\n    Rate Limiting - Layer 2: Message Classification & Routing\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ—„ï¸ Database Layer\" icon=\"setting\">\n    **Smart Pooler Management**: - Transaction Pool (6543): Fast CRUD operations\n    - Session Pool (5432): Complex queries & analytics\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ§  ElizaOS Core\" icon=\"approve-check\">\n    **Advanced AI Framework**: - Personality evolution system - Memory & context\n    management - Plugin architecture\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸš€ Service Layer\" icon=\"rocket\">\n    **14 Specialized Services**: - Community management - Cross-platform\n    identity - Raid coordination - Analytics & observability\n  \u003C/Card>\n\u003C/CardGrid>\n\n## âœ¨ Key Capabilities\n\n### ðŸŽ­ **Dynamic Personality System**\n\nNUBI features a sophisticated personality evolution system with 10 dimensions:\n\n\u003CTabs>\n  \u003CTabItem label=\"Personality Traits\">\n```typescript\ninterface PersonalityTraits {\n  analytical: number;      // 0-1: Logic-driven vs intuitive\n  empathy: number;         // 0-1: Emotional understanding\n  humor: number;           // 0-1: Playfulness and wit  \n  assertiveness: number;   // 0-1: Leadership qualities\n  curiosity: number;       // 0-1: Knowledge seeking\n  loyalty: number;         // 0-1: Community commitment\n  adaptability: number;    // 0-1: Flexibility in responses\n  wisdom: number;          // 0-1: Deep insight provision\n  protectiveness: number;  // 0-1: Guardian instincts\n  mystique: number;        // 0-1: Ancient spirit essence\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Emotional States\">\n```typescript\ntype EmotionalState = \n  | \"guardian\"      // Protective, authoritative\n  | \"analytical\"    // Market-focused, data-driven\n  | \"playful\"       // Humorous, engaging\n  | \"wise\"          // Deep, philosophical\n  | \"curious\"       // Questioning, exploratory\n  | \"loyal\"         // Community-focused\n  | \"adaptive\"      // Flexible, responsive\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n### ðŸŒ **Multi-Platform Integration**\n\nNUBI seamlessly operates across multiple platforms with unified identity management:\n\n- **Discord**: Community engagement and moderation\n- **Telegram**: Advanced raid coordination with leaderboards\n- **Twitter/X**: Social media campaigns and engagement\n- **WebSocket**: Real-time web application integration\n\n### ðŸ” **Advanced Security**\n\nTwo-layer processing pipeline ensures robust security:\n\n```mermaid\ngraph LR\n    A[Incoming Message] --> B[Layer 1: Security]\n    B --> C{Rate Limit OK?}\n    C -->|No| D[Block/Throttle]\n    C -->|Yes| E[Content Filter]\n    E --> F[Layer 2: Classification]\n    F --> G{Message Type?}\n    G --> H[Community Manager]\n    G --> I[Raid Coordinator]\n    G --> J[Crypto Analyst]\n    G --> K[Emergency Handler]\n    H --> L[ElizaOS Core]\n    I --> L\n    J --> L\n    K --> L\n```\n\n### ðŸ“Š **Performance Optimization**\n\nNUBI employs intelligent database pooling for optimal performance:\n\n\u003Cdiv class=\"pooler-diagram\">\n  \u003Cdiv class=\"pool-node\">\n    Simple Queries\n    \u003Cbr />\n    \u003Csmall>\n      Transaction Pool\n      \u003Cbr />\n      Port 6543\n    \u003C/small>\n  \u003C/div>\n  \u003Cdiv class=\"pool-arrow\">â†’\u003C/div>\n  \u003Cdiv class=\"pool-node\">\n    Query Router\n    \u003Cbr />\n    \u003Csmall>Intelligent Routing\u003C/small>\n  \u003C/div>\n  \u003Cdiv class=\"pool-arrow\">â†’\u003C/div>\n  \u003Cdiv class=\"pool-node\">\n    Complex Queries\n    \u003Cbr />\n    \u003Csmall>\n      Session Pool\n      \u003Cbr />\n      Port 5432\n    \u003C/small>\n  \u003C/div>\n\u003C/div>\n\n\u003CAside type=\"tip\">\n  **Performance Boost**: The intelligent query router can improve database\n  performance by up to 300% by automatically selecting the optimal pool based on\n  query complexity.\n\u003C/Aside>\n\n## ðŸ”§ Technical Stack\n\nNUBI is built with modern, production-ready technologies:\n\n\u003CTabs>\n  \u003CTabItem label=\"Core Framework\">\n```typescript\n// Built on ElizaOS with TypeScript\nimport { \n  IAgentRuntime, \n  Service, \n  logger,\n  Memory,\n  ModelType \n} from \"@elizaos/core\";\n\n// Strict TypeScript throughout\ninterface NubiService extends Service {\nserviceType: string;\ncapabilityDescription: string;\ninitialize(runtime: IAgentRuntime): Promise\u003Cvoid>;\n}\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Database\">\n```bash\n# Development: PGLite (embedded PostgreSQL)\nPGLITE_DATA_DIR=./.eliza/.elizadb\n\n# Production: Full PostgreSQL with pooling\nPOSTGRES_URL=postgresql://...\nSUPABASE_TRANSACTION_POOLER_URL=postgresql://...@:6543/\nSUPABASE_SESSION_POOLER_URL=postgresql://...@:5432/\n````\n\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Real-time\">\n```typescript\n// Socket.IO for real-time communication\nimport { Server } from \"socket.io\";\nimport { MessageRouter } from \"./message-router\";\n\n// Two-layer processing pipeline\nconst router = new MessageRouter();\nconst classification = await router.classifyMessage(message);\n\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸš€ What Makes NUBI Special?\n\n### 1. **Symbiotic Architecture**\nUnlike traditional AI agents, NUBI's symbiotic design allows it to evolve and adapt based on community interactions while maintaining its core ancient wisdom personality.\n\n### 2. **Zero-Latency Responses**\nAdvanced caching and connection pooling ensure sub-100ms response times for real-time interactions.\n\n### 3. **Cross-Platform Identity**\nUnified user identity across all platforms means NUBI remembers you whether you're on Discord, Telegram, or the web.\n\n### 4. **Raid Coordination Excellence**\nPurpose-built Telegram raid system with engagement verification, point tracking, and leaderboards.\n\n### 5. **Developer-First Design**\nComprehensive APIs, detailed documentation, and extensive testing make NUBI easy to extend and customize.\n\n---\n\n\u003Cdiv class=\"nubi-note\">\n\u003Cstrong>ðŸŽ¯ Ready to dive deeper?\u003C/strong> Continue with our \u003Ca href=\"/getting-started/quick-start/\">Quick Start Guide\u003C/a> to get NUBI running in minutes, or explore the \u003Ca href=\"/architecture/overview/\">Architecture Overview\u003C/a> for technical details.\n\u003C/div>\n\n## Next Steps\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ“‹ Quick Start\" icon=\"rocket\">\n    Get NUBI up and running in under 5 minutes with our step-by-step guide.\n    [Start Here â†’](/getting-started/quick-start/)\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ—ï¸ Architecture\" icon=\"puzzle\">\n    Understand NUBI's modular design and service architecture.\n    [Learn More â†’](/architecture/overview/)\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ”Œ UX Integration\" icon=\"laptop\">\n    Dive into the Socket.IO real-time communication system.\n    [Explore â†’](/ux-integration/overview/)\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ“– API Reference\" icon=\"document\">\n    Complete reference for all REST and WebSocket APIs.\n    [Browse APIs â†’](/api/rest/)\n  \u003C/Card>\n\u003C/CardGrid>\n```","src/content/docs/getting-started/introduction.mdx","f9267f88ef2becd5","getting-started/introduction.mdx","api/rest",{"id":26,"data":28,"body":34,"filePath":35,"digest":36,"legacyId":37,"deferredRender":16},{"title":29,"description":30,"editUrl":16,"head":31,"template":18,"sidebar":32,"pagefind":16,"draft":20},"REST API Reference","Complete reference for NUBI's REST API endpoints with interactive examples and live testing capabilities.",[],{"hidden":20,"attrs":33},{},"import {\n  Card,\n  CardGrid,\n  Aside,\n  Code,\n  Tabs,\n  TabItem,\n} from \"@astrojs/starlight/components\";\nimport ApiExplorer from \"../../../components/ApiExplorer.astro\";\nimport SocketDemo from \"../../../components/SocketDemo.astro\";\n\n# REST API Reference\n\nNUBI provides a comprehensive REST API for interacting with the agent system, managing raids, and accessing analytics. All endpoints use **JSON** for request/response data and require proper authentication.\n\n## ðŸ” Authentication\n\nNUBI uses **JWT Bearer tokens** for authentication. Include the token in the `Authorization` header:\n\n```bash\nAuthorization: Bearer your-jwt-token-here\n```\n\n### Getting Started\n\n\u003CApiExplorer\n  title=\"Health Check\"\n  endpoint=\"https://api.anubis.chat/health\"\n  method=\"GET\"\n  description=\"Verify API availability and system status\"\n/>\n\n\u003CApiExplorer\n  title=\"Authentication\"\n  endpoint=\"https://api.anubis.chat/auth/login\"\n  method=\"POST\"\n  description=\"Authenticate and receive JWT token\"\n/>\n\n## ðŸŽ¯ Core Agent Endpoints\n\n### Message Processing\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ’¬ Send Message\" icon=\"approve-check\">\n    **Process messages** through NUBI's two-layer pipeline - Security filtering\n    and validation - Message classification and routing - AI persona response\n    generation - Real-time WebSocket broadcasting\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ§  Get Context\" icon=\"puzzle\">\n    **Retrieve conversation context** for enhanced responses - Recent\n    conversation history - User preference analysis - Cross-platform identity\n    data - Semantic memory retrieval\n  \u003C/Card>\n\u003C/CardGrid>\n\n\u003CApiExplorer\n  title=\"Process Message\"\n  endpoint=\"https://api.anubis.chat/api/messages\"\n  method=\"POST\"\n  description=\"Send message through NUBI's processing pipeline\"\n/>\n\n\u003CApiExplorer\n  title=\"Get Conversation Context\"\n  endpoint=\"https://api.anubis.chat/api/context/user/{userId}/room/{roomId}\"\n  method=\"GET\"\n  description=\"Retrieve conversation context and history\"\n/>\n\n### User Management\n\n\u003CTabs>\n  \u003CTabItem label=\"User Registration\">\n```json\n{\n  \"endpoint\": \"POST /api/users/register\",\n  \"description\": \"Create new user account with cross-platform identity\",\n  \"request\": {\n    \"username\": \"alice_crypto\",\n    \"email\": \"alice@example.com\", \n    \"platforms\": {\n      \"telegram\": \"@alice_tg\",\n      \"twitter\": \"@alice_twitter\",\n      \"discord\": \"alice#1234\"\n    },\n    \"preferences\": {\n      \"notifications\": true,\n      \"raid_alerts\": true,\n      \"preferred_persona\": \"crypto-analyst\"\n    }\n  },\n  \"response\": {\n    \"userId\": \"uuid-here\",\n    \"username\": \"alice_crypto\",\n    \"jwt_token\": \"eyJ...\",\n    \"created_at\": \"2024-01-01T00:00:00Z\"\n  }\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"User Profile\">\n```json\n{\n  \"endpoint\": \"GET /api/users/{userId}\",\n  \"description\": \"Get user profile and statistics\",\n  \"response\": {\n    \"user\": {\n      \"id\": \"uuid-here\",\n      \"username\": \"alice_crypto\",\n      \"platforms\": {\n        \"telegram\": \"@alice_tg\",\n        \"twitter\": \"@alice_twitter\", \n        \"discord\": \"alice#1234\"\n      },\n      \"stats\": {\n        \"raids_completed\": 47,\n        \"total_points\": 12500,\n        \"current_rank\": 23,\n        \"verification_rate\": 0.94\n      },\n      \"achievements\": [\n        {\n          \"id\": \"raid_rookie\",\n          \"name\": \"Raid Rookie\",\n          \"earned_at\": \"2024-01-15T00:00:00Z\"\n        }\n      ],\n      \"preferences\": {\n        \"notifications\": true,\n        \"raid_alerts\": true,\n        \"preferred_persona\": \"crypto-analyst\"\n      }\n    }\n  }\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Cross-Platform Identity\">\n```json\n{\n  \"endpoint\": \"POST /api/users/{userId}/platforms\",\n  \"description\": \"Link additional platform accounts\",\n  \"request\": {\n    \"platform\": \"discord\",\n    \"platform_id\": \"alice#1234\",\n    \"verification_token\": \"discord-oauth-token\"\n  },\n  \"response\": {\n    \"linked\": true,\n    \"platform\": \"discord\",\n    \"verification_status\": \"verified\",\n    \"linked_at\": \"2024-01-20T00:00:00Z\"\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n\u003CApiExplorer\n  title=\"Register User\"\n  endpoint=\"https://api.anubis.chat/api/users/register\"\n  method=\"POST\"\n  description=\"Create new user account with platform linking\"\n/>\n\n\u003CApiExplorer\n  title=\"Get User Profile\"\n  endpoint=\"https://api.anubis.chat/api/users/12345\"\n  method=\"GET\"\n  description=\"Retrieve user profile and statistics\"\n/>\n\n## âš”ï¸ Telegram Raids API\n\n### Raid Management\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸš€ Create Raid\" icon=\"rocket\">\n    **Launch new raids** with comprehensive configuration - Target URL and\n    platform specification - Participation requirements and limits - Reward\n    structure and point allocation - Success criteria and metrics\n  \u003C/Card>\n\n\u003CCard title=\"ðŸ‘¥ Join Raid\" icon=\"user\">\n  **Participant enrollment** with eligibility checking - User eligibility\n  verification - Requirement validation - Real-time capacity checking -\n  Automatic leaderboard updates\n\u003C/Card>\n\n\u003CCard title=\"âœ… Submit Completion\" icon=\"approve-check\">\n  **Action verification** with multi-layer validation - Twitter API engagement\n  verification - AI-powered quality assessment - Anti-gaming protection - Point\n  calculation and award\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ“Š Raid Analytics\" icon=\"chart\">\n    **Performance metrics** and success tracking - Real-time participation stats\n    - Engagement quality analysis - Success rate calculations - ROI and impact\n    measurement\n  \u003C/Card>\n\u003C/CardGrid>\n\n\u003CApiExplorer\n  title=\"Create Raid\"\n  endpoint=\"https://api.anubis.chat/api/raids\"\n  method=\"POST\"\n  description=\"Create a new raid campaign\"\n/>\n\n\u003CApiExplorer\n  title=\"Join Raid\"\n  endpoint=\"https://api.anubis.chat/api/raids/12345/join\"\n  method=\"POST\"\n  description=\"Join an active raid campaign\"\n/>\n\n\u003CApiExplorer\n  title=\"Submit Completion\"\n  endpoint=\"https://api.anubis.chat/api/raids/12345/complete\"\n  method=\"POST\"\n  description=\"Submit proof of raid action completion\"\n/>\n\n### Leaderboards & Rankings\n\n\u003CTabs>\n  \u003CTabItem label=\"Global Leaderboard\">\n```json\n{\n  \"endpoint\": \"GET /api/leaderboard/global\",\n  \"description\": \"Get global user rankings\",\n  \"query_parameters\": {\n    \"limit\": \"number (default: 50, max: 100)\",\n    \"offset\": \"number (default: 0)\",\n    \"timeframe\": \"string (day|week|month|all, default: all)\",\n    \"metric\": \"string (points|raids|quality|consistency, default: points)\"\n  },\n  \"response\": {\n    \"leaderboard\": [\n      {\n        \"rank\": 1,\n        \"user\": {\n          \"id\": \"uuid-here\",\n          \"username\": \"crypto_champion\",\n          \"avatar\": \"https://example.com/avatar.jpg\"\n        },\n        \"stats\": {\n          \"total_points\": 25750,\n          \"raids_completed\": 89,\n          \"verification_rate\": 0.97,\n          \"avg_quality\": 0.89\n        },\n        \"achievements\": [\"legendary_raider\", \"community_guardian\"]\n      }\n    ],\n    \"pagination\": {\n      \"total\": 1247,\n      \"page\": 1,\n      \"per_page\": 50,\n      \"has_next\": true\n    },\n    \"user_rank\": {\n      \"rank\": 23,\n      \"points\": 12500\n    }\n  }\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Raid Rankings\">\n```json\n{\n  \"endpoint\": \"GET /api/raids/{raidId}/leaderboard\",\n  \"description\": \"Get rankings for specific raid\",\n  \"response\": {\n    \"raid\": {\n      \"id\": \"raid-uuid\",\n      \"title\": \"Twitter Engagement Boost\",\n      \"status\": \"active\",\n      \"participants\": 127,\n      \"completion_rate\": 0.78\n    },\n    \"leaderboard\": [\n      {\n        \"rank\": 1,\n        \"user\": {\n          \"username\": \"speed_demon\",\n          \"telegram\": \"@speedy_trader\"\n        },\n        \"completion_time\": \"2024-01-01T12:05:30Z\",\n        \"quality_score\": 0.95,\n        \"points_earned\": 250,\n        \"actions\": [\n          {\n            \"type\": \"like\",\n            \"verified\": true,\n            \"timestamp\": \"2024-01-01T12:03:15Z\"\n          },\n          {\n            \"type\": \"retweet\",\n            \"verified\": true,\n            \"timestamp\": \"2024-01-01T12:03:45Z\"\n          },\n          {\n            \"type\": \"comment\",\n            \"verified\": true,\n            \"quality\": 0.88,\n            \"content\": \"Great project! Excited for the future.\",\n            \"timestamp\": \"2024-01-01T12:05:30Z\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"User Statistics\">\n```json\n{\n  \"endpoint\": \"GET /api/users/{userId}/stats\",\n  \"description\": \"Get detailed user performance statistics\",\n  \"response\": {\n    \"overview\": {\n      \"total_points\": 12500,\n      \"current_rank\": 23,\n      \"raids_completed\": 47,\n      \"verification_rate\": 0.94,\n      \"avg_quality_score\": 0.82\n    },\n    \"trends\": {\n      \"points_last_7d\": 850,\n      \"raids_last_7d\": 6,\n      \"rank_change\": -2,\n      \"quality_trend\": \"improving\"\n    },\n    \"breakdown\": {\n      \"engagement_raids\": 35,\n      \"growth_raids\": 8,\n      \"defense_raids\": 4,\n      \"points_by_type\": {\n        \"base_completion\": 8200,\n        \"quality_bonus\": 2100,\n        \"speed_bonus\": 1450,\n        \"achievement_bonus\": 750\n      }\n    },\n    \"achievements\": {\n      \"recent\": [\n        {\n          \"id\": \"speed_demon\",\n          \"name\": \"Speed Demon\",\n          \"earned_at\": \"2024-01-18T00:00:00Z\",\n          \"rarity\": \"rare\"\n        }\n      ],\n      \"progress\": [\n        {\n          \"id\": \"engagement_master\",\n          \"name\": \"Engagement Master\",\n          \"progress\": 0.74,\n          \"requirements\": {\n            \"raids_completed\": {\"current\": 47, \"required\": 50},\n            \"verification_rate\": {\"current\": 0.94, \"required\": 1.0}\n          }\n        }\n      ]\n    }\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n\u003CApiExplorer\n  title=\"Global Leaderboard\"\n  endpoint=\"https://api.anubis.chat/api/leaderboard/global?limit=20\"\n  method=\"GET\"\n  description=\"Get top performers across all raids\"\n/>\n\n\u003CApiExplorer\n  title=\"User Statistics\"\n  endpoint=\"https://api.anubis.chat/api/users/12345/stats\"\n  method=\"GET\"\n  description=\"Get detailed user performance metrics\"\n/>\n\n## ðŸ” Analytics & Insights\n\n### System Analytics\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ“ˆ Performance Metrics\" icon=\"chart\">\n    **System-wide performance** tracking and optimization - Processing pipeline\n    latency - Classification accuracy rates - Database query performance - API\n    response time distribution\n  \u003C/Card>\n\n\u003CCard title=\"ðŸ‘¥ Community Health\" icon=\"user\">\n  **Community engagement** and growth analysis - User activity patterns -\n  Retention and churn metrics - Platform-specific engagement - Community\n  sentiment analysis\n\u003C/Card>\n\n\u003CCard title=\"âš”ï¸ Raid Effectiveness\" icon=\"rocket\">\n  **Campaign performance** and ROI measurement - Engagement rate improvements -\n  Viral coefficient tracking - Cost-effectiveness analysis - Success pattern\n  identification\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ›¡ï¸ Security Insights\" icon=\"warning\">\n    **Threat detection** and prevention analytics - Attack pattern recognition -\n    Gaming attempt analysis - Content quality trends - Moderation effectiveness\n  \u003C/Card>\n\u003C/CardGrid>\n\n\u003CTabs>\n  \u003CTabItem label=\"System Metrics\">\n```json\n{\n  \"endpoint\": \"GET /api/analytics/system\",\n  \"description\": \"Get system performance metrics\",\n  \"query_parameters\": {\n    \"timeframe\": \"string (hour|day|week|month, default: day)\",\n    \"metrics\": \"array (['latency', 'throughput', 'errors', 'classification_accuracy'])\"\n  },\n  \"response\": {\n    \"timeframe\": \"day\",\n    \"timestamp\": \"2024-01-20T00:00:00Z\",\n    \"performance\": {\n      \"api_latency\": {\n        \"avg_ms\": 45,\n        \"p50_ms\": 32,\n        \"p95_ms\": 87,\n        \"p99_ms\": 156\n      },\n      \"processing_pipeline\": {\n        \"layer1_avg_ms\": 12,\n        \"layer2_avg_ms\": 28,\n        \"total_avg_ms\": 40\n      },\n      \"throughput\": {\n        \"messages_per_second\": 127,\n        \"peak_messages_per_second\": 340,\n        \"total_messages\": 10987\n      },\n      \"classification_accuracy\": {\n        \"overall\": 0.973,\n        \"by_persona\": {\n          \"community_manager\": 0.945,\n          \"raid_coordinator\": 0.987,\n          \"crypto_analyst\": 0.961,\n          \"support_agent\": 0.983\n        }\n      }\n    },\n    \"errors\": {\n      \"total_count\": 23,\n      \"rate\": 0.002,\n      \"by_type\": {\n        \"rate_limit\": 12,\n        \"authentication\": 7,\n        \"processing\": 3,\n        \"database\": 1\n      }\n    }\n  }\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Community Analytics\">\n```json\n{\n  \"endpoint\": \"GET /api/analytics/community\",\n  \"description\": \"Get community engagement and growth metrics\",\n  \"response\": {\n    \"overview\": {\n      \"total_users\": 12847,\n      \"active_users_24h\": 3241,\n      \"active_users_7d\": 8932,\n      \"new_users_7d\": 524,\n      \"retention_rate_7d\": 0.68\n    },\n    \"engagement\": {\n      \"avg_messages_per_user\": 23.4,\n      \"avg_session_duration_min\": 18.7,\n      \"most_active_hours\": [20, 21, 22],\n      \"platform_breakdown\": {\n        \"telegram\": 0.45,\n        \"discord\": 0.32,\n        \"web\": 0.18,\n        \"api\": 0.05\n      }\n    },\n    \"raids\": {\n      \"active_raids\": 12,\n      \"total_participants\": 8934,\n      \"avg_participation_rate\": 0.71,\n      \"completion_rate\": 0.83,\n      \"quality_score\": 0.79\n    },\n    \"sentiment\": {\n      \"overall\": \"positive\",\n      \"score\": 0.73,\n      \"by_topic\": {\n        \"raids\": 0.81,\n        \"community\": 0.74,\n        \"support\": 0.69,\n        \"features\": 0.77\n      }\n    }\n  }\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Raid Analytics\">\n```json\n{\n  \"endpoint\": \"GET /api/analytics/raids\",\n  \"description\": \"Get comprehensive raid performance analytics\",\n  \"query_parameters\": {\n    \"raid_id\": \"string (optional, for specific raid)\",\n    \"timeframe\": \"string (day|week|month|all, default: week)\",\n    \"include_historical\": \"boolean (default: false)\"\n  },\n  \"response\": {\n    \"summary\": {\n      \"total_raids\": 89,\n      \"active_raids\": 3,\n      \"completed_raids\": 86,\n      \"avg_participants\": 67,\n      \"overall_success_rate\": 0.84\n    },\n    \"performance\": {\n      \"engagement_metrics\": {\n        \"avg_likes_per_raid\": 2341,\n        \"avg_retweets_per_raid\": 876,\n        \"avg_comments_per_raid\": 234,\n        \"avg_followers_gained\": 145\n      },\n      \"quality_metrics\": {\n        \"avg_comment_quality\": 0.79,\n        \"verification_rate\": 0.91,\n        \"gaming_detection_rate\": 0.03\n      },\n      \"timing_metrics\": {\n        \"avg_completion_time_min\": 18.4,\n        \"fastest_completion_min\": 2.3,\n        \"participation_curve\": [\n          {\"time_min\": 0, \"participants\": 0},\n          {\"time_min\": 5, \"participants\": 23},\n          {\"time_min\": 15, \"participants\": 45},\n          {\"time_min\": 30, \"participants\": 67}\n        ]\n      }\n    },\n    \"roi_analysis\": {\n      \"engagement_cost_efficiency\": 0.023,\n      \"follower_acquisition_cost\": 1.47,\n      \"community_value_score\": 8.2,\n      \"viral_coefficient\": 1.34\n    },\n    \"top_performers\": [\n      {\n        \"raid_id\": \"uuid-here\",\n        \"title\": \"Major Partnership Announcement\",\n        \"participants\": 234,\n        \"completion_rate\": 0.97,\n        \"engagement_score\": 9.2,\n        \"viral_reach\": 45789\n      }\n    ]\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n\u003CApiExplorer\n  title=\"System Analytics\"\n  endpoint=\"https://api.anubis.chat/api/analytics/system?timeframe=day\"\n  method=\"GET\"\n  description=\"Get comprehensive system performance metrics\"\n/>\n\n\u003CApiExplorer\n  title=\"Community Analytics\"\n  endpoint=\"https://api.anubis.chat/api/analytics/community\"\n  method=\"GET\"\n  description=\"Analyze community health and engagement patterns\"\n/>\n\n## ðŸ”Œ Real-time Communication\n\nNUBI provides both REST endpoints and WebSocket connections for real-time communication:\n\n\u003CSocketDemo\n  title=\"Live Socket.IO Integration\"\n  description=\"Test NUBI's real-time two-layer processing system\"\n/>\n\n### WebSocket Events\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ“¨ Client Events\" icon=\"approve-check\">\n    **Events sent from client to server** - `connect` - Establish connection -\n    `join-room` - Enter chat room - `send-message` - Send message for processing\n    - `request-world-state` - Get current system state\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ“¡ Server Events\" icon=\"rocket\">\n    **Events sent from server to client** - `message-received` - New processed\n    message - `user-joined` - User entered room - `world-state` - Current system\n    state - `processing-status` - Pipeline status updates\n  \u003C/Card>\n\u003C/CardGrid>\n\n## ðŸ›¡ï¸ Error Handling\n\nNUBI uses standard HTTP status codes and provides detailed error information:\n\n\u003CTabs>\n  \u003CTabItem label=\"Error Response Format\">\n```json\n{\n  \"error\": {\n    \"code\": \"RATE_LIMIT_EXCEEDED\",\n    \"message\": \"Too many requests. Please wait before retrying.\",\n    \"details\": {\n      \"limit\": 100,\n      \"window\": \"hour\",\n      \"retry_after\": 1847\n    },\n    \"timestamp\": \"2024-01-20T12:34:56Z\",\n    \"request_id\": \"req_abc123def456\"\n  }\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Common Error Codes\">\n```typescript\n// Authentication Errors\nINVALID_TOKEN = \"JWT token is invalid or expired\"\nMISSING_TOKEN = \"Authorization token is required\"\nINSUFFICIENT_PERMISSIONS = \"User lacks required permissions\"\n\n// Rate Limiting\nRATE_LIMIT_EXCEEDED = \"Too many requests in time window\"\nQUOTA_EXCEEDED = \"Monthly quota limit reached\"\n\n// Validation Errors  \nINVALID_REQUEST_FORMAT = \"Request body format is invalid\"\nMISSING_REQUIRED_FIELDS = \"Required fields are missing\"\nINVALID_FIELD_VALUE = \"Field value is invalid\"\n\n// Resource Errors\nRESOURCE_NOT_FOUND = \"Requested resource does not exist\"\nRESOURCE_ALREADY_EXISTS = \"Resource already exists\"\nRESOURCE_UNAVAILABLE = \"Resource temporarily unavailable\"\n\n// Processing Errors\nPROCESSING_FAILED = \"Message processing failed\"\nCLASSIFICATION_ERROR = \"Unable to classify message\"\nAI_SERVICE_UNAVAILABLE = \"AI service is temporarily unavailable\"\n\n// Raid-Specific Errors\nRAID_NOT_FOUND = \"Raid does not exist\"\nRAID_FULL = \"Raid has reached maximum participants\"\nRAID_EXPIRED = \"Raid has ended\"\nALREADY_PARTICIPATING = \"User already joined this raid\"\nVERIFICATION_FAILED = \"Action verification failed\"\n\n````\n  \u003C/TabItem>\n\u003C/Tabs>\n\n\u003CAside type=\"tip\">\n**Rate Limits**: All API endpoints are rate limited. Current limits are 1000 requests per hour for authenticated users and 100 requests per hour for unauthenticated requests.\n\u003C/Aside>\n\n## ðŸ“š SDK & Libraries\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ“± JavaScript/TypeScript\" icon=\"approve-check\">\n    **Official SDK** with full TypeScript support\n\n    ```bash\n    npm install @nubi/sdk\n    ```\n\n    - Full API coverage\n    - WebSocket integration\n    - Real-time event handling\n    - Built-in retry logic\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ Python\" icon=\"puzzle\">\n    **Python client** for backend integration\n\n    ```bash\n    pip install nubi-python\n    ```\n\n    - Async/await support\n    - Django/Flask integration\n    - Comprehensive examples\n    - Advanced analytics tools\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ¦€ Rust\" icon=\"setting\">\n    **High-performance Rust** client\n\n    ```bash\n    cargo add nubi-client\n    ```\n\n    - Zero-cost abstractions\n    - Tokio async runtime\n    - Strong type safety\n    - Memory efficient\n  \u003C/Card>\n\n  \u003CCard title=\"â˜• Java\" icon=\"warning\">\n    **Enterprise Java** integration\n\n    ```xml\n    \u003Cdependency>\n      \u003CgroupId>chat.anubis\u003C/groupId>\n      \u003CartifactId>nubi-java\u003C/artifactId>\n    \u003C/dependency>\n    ```\n\n    - Spring Boot starter\n    - Reactive streams\n    - Comprehensive logging\n    - Production ready\n  \u003C/Card>\n\u003C/CardGrid>\n\n---\n\n\u003Cdiv class=\"nubi-note\">\n\u003Cstrong>ðŸš€ Ready to integrate?\u003C/strong> Start with our \u003Ca href=\"/api/quickstart/\">API Quickstart Guide\u003C/a> for step-by-step integration instructions, or explore the \u003Ca href=\"/api/websockets/\">WebSocket Documentation\u003C/a> for real-time features.\n\u003C/div>\n\n## Next Steps\n\n\u003CCardGrid>\n  \u003CCard title=\"âš¡ Quickstart Guide\" icon=\"rocket\">\n    Get up and running with NUBI's API in under 10 minutes.\n    [Start Building â†’](/api/quickstart/)\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ”Œ WebSocket API\" icon=\"approve-check\">\n    Learn about real-time communication and event handling.\n    [Go Real-time â†’](/api/websockets/)\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ›¡ï¸ Authentication\" icon=\"warning\">\n    Understand JWT tokens, permissions, and security best practices.\n    [Secure â†’](/api/authentication/)\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ“Š Rate Limits\" icon=\"chart\">\n    Learn about API limits, quotas, and optimization strategies.\n    [Optimize â†’](/api/rate-limits/)\n  \u003C/Card>\n\u003C/CardGrid>\n````","src/content/docs/api/rest.mdx","e8af990d1f7f26c7","api/rest.mdx","database/pooler-manager",{"id":38,"data":40,"body":46,"filePath":47,"digest":48,"legacyId":49,"deferredRender":16},{"title":41,"description":42,"editUrl":16,"head":43,"template":18,"sidebar":44,"pagefind":16,"draft":20},"Database Pooler Manager","Learn about NUBI's intelligent dual-pool database architecture with automatic query routing for optimal performance.",[],{"hidden":20,"attrs":45},{},"import {\n  Card,\n  CardGrid,\n  Aside,\n  Code,\n  Tabs,\n  TabItem,\n} from \"@astrojs/starlight/components\";\n\n# Database Pooler Manager\n\nNUBI's **DatabasePoolerManager** is a sophisticated connection pooling system that intelligently routes database queries between specialized pools for optimal performance. This system can improve database performance by up to **300%** through intelligent query routing.\n\n## ðŸ—ï¸ Architecture Overview\n\nThe DatabasePoolerManager implements a **dual-pool architecture** with intelligent routing:\n\n\u003Cdiv class=\"pooler-diagram\">\n  \u003Cdiv style=\"text-align: center;\">\n    \u003Cdiv class=\"pool-node\">\n      \u003Cstrong>Transaction Pool\u003C/strong>\n      \u003Cbr />\n      Port 6543\n      \u003Cbr />\n      \u003Csmall>20 connections\u003C/small>\n      \u003Cbr />\n      \u003Csmall>10s idle timeout\u003C/small>\n    \u003C/div>\n    \u003Cdiv class=\"pool-arrow\">âš¡\u003C/div>\n    \u003Cdiv\n      class=\"pool-node\"\n      style=\"background: var(--nubi-spirit-blue); color: white;\"\n    >\n      \u003Cstrong>Query Router\u003C/strong>\n      \u003Cbr />\n      Intelligence\n      \u003Cbr />\n      \u003Csmall>Complexity Analysis\u003C/small>\n      \u003Cbr />\n      \u003Csmall>Automatic Selection\u003C/small>\n    \u003C/div>\n    \u003Cdiv class=\"pool-arrow\">âš¡\u003C/div>\n    \u003Cdiv class=\"pool-node\">\n      \u003Cstrong>Session Pool\u003C/strong>\n      \u003Cbr />\n      Port 5432\n      \u003Cbr />\n      \u003Csmall>5 connections\u003C/small>\n      \u003Cbr />\n      \u003Csmall>30s idle timeout\u003C/small>\n    \u003C/div>\n  \u003C/div>\n\u003C/div>\n\n## ðŸŽ¯ Pool Specialization\n\n\u003CCardGrid>\n  \u003CCard title=\"âš¡ Transaction Pool\" icon=\"rocket\">\n    **Optimized for speed** - Fast CRUD operations - **Port**: 6543 (Supabase\n    Transaction Pooler) - **Connections**: 20 maximum - **Idle Timeout**: 10\n    seconds - **Best For**: INSERT, UPDATE, DELETE, simple SELECT\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ§  Session Pool\" icon=\"puzzle\">\n    **Optimized for complexity** - Long-running queries - **Port**: 5432\n    (Supabase Session Pooler) - **Connections**: 5 maximum - **Idle Timeout**:\n    30 seconds - **Best For**: JOINs, analytics, vector operations\n  \u003C/Card>\n\u003C/CardGrid>\n\n## ðŸ¤– Intelligent Query Routing\n\nThe DatabasePoolerManager automatically analyzes queries and routes them to the optimal pool:\n\n\u003CTabs>\n  \u003CTabItem label=\"Transaction Pool Queries\">\n```sql\n-- Simple CRUD operations â†’ Transaction Pool\nINSERT INTO users (id, name) VALUES ($1, $2);\nUPDATE users SET name = $1 WHERE id = $2;\nDELETE FROM messages WHERE id = $1;\nSELECT * FROM users WHERE id = $1;\n\n-- Fast lookups â†’ Transaction Pool  \nSELECT count(\\*) FROM raid_participants;\nSELECT status FROM raids WHERE id = $1;\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Session Pool Queries\">\n```sql\n-- Complex queries â†’ Session Pool\nSELECT u.name, COUNT(r.id) as raid_count\nFROM users u\nLEFT JOIN raid_participants r ON u.id = r.user_id\nWHERE u.created_at > $1\nGROUP BY u.id, u.name\nHAVING COUNT(r.id) > 5;\n\n-- Vector operations â†’ Session Pool\nSELECT content, embedding \u003C-> $1 as similarity\nFROM memories\nORDER BY embedding \u003C-> $1\nLIMIT 10;\n\n-- Analytics queries â†’ Session Pool\nWITH engagement_stats AS (\n  SELECT user_id, AVG(points_earned) as avg_points\n  FROM raid_participants\n  GROUP BY user_id\n)\nSELECT * FROM engagement_stats WHERE avg_points > 100;\n````\n\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Routing Logic\">\n```typescript\nprivate determinePoolType(sql: string): PoolType {\n  const sqlUpper = sql.toUpperCase().trim();\n  \n  // Use session pool for complex queries\n  if (\n    sqlUpper.includes('JOIN') ||\n    sqlUpper.includes('UNION') ||\n    sqlUpper.includes('SUBQUERY') ||\n    sqlUpper.includes('WITH') ||\n    sqlUpper.includes('RECURSIVE') ||\n    sqlUpper.includes('WINDOW') ||\n    sqlUpper.includes('GROUP BY') ||\n    sqlUpper.includes('ORDER BY') ||\n    sqlUpper.includes('HAVING') ||\n    sqlUpper.includes('VECTOR') ||\n    sqlUpper.includes('SIMILARITY') ||\n    sqlUpper.includes('EMBEDDING')\n  ) {\n    return PoolType.SESSION;\n  }\n\n// Use transaction pool for simple CRUD\nif (\nsqlUpper.startsWith('INSERT') ||\nsqlUpper.startsWith('UPDATE') ||\nsqlUpper.startsWith('DELETE') ||\n(sqlUpper.startsWith('SELECT') && !sqlUpper.includes('JOIN'))\n) {\nreturn PoolType.TRANSACTION;\n}\n\nreturn PoolType.TRANSACTION; // Default\n}\n\n````\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ”§ Configuration & Setup\n\n### Environment Configuration\n\n\u003CTabs>\n  \u003CTabItem label=\"Required Environment Variables\">\n```bash\n# Supabase Database Pooler URLs\nSUPABASE_TRANSACTION_POOLER_URL=\"postgresql://user:pass@host:6543/db\"\nSUPABASE_SESSION_POOLER_URL=\"postgresql://user:pass@host:5432/db\"\n\n# Optional Pool Configuration\nTRANSACTION_POOL_MAX_CONNECTIONS=20\nSESSION_POOL_MAX_CONNECTIONS=5\nTRANSACTION_POOL_IDLE_TIMEOUT=10000\nSESSION_POOL_IDLE_TIMEOUT=30000\n````\n\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Service Integration\">\n```typescript\nimport { DatabasePoolerManager, PoolType } from '../services/database-pooler-manager';\n\nexport class MyService extends Service {\n  private poolerManager?: DatabasePoolerManager;\n  \n  async initialize(runtime: IAgentRuntime): Promise\u003Cvoid> {\n    // Get pooler manager from service registry\n    try {\n      this.poolerManager = runtime.getService\u003CDatabasePoolerManager>(\"database-pooler-manager\");\n      if (this.poolerManager) {\n        logger.info(\"Connected to database pooler manager\");\n      }\n    } catch (error) {\n      logger.debug(\"Pooler manager not available, using fallback\");\n    }\n  }\n  \n  async performComplexQuery(sql: string, params: any[]) {\n    if (this.poolerManager) {\n      // Automatic routing based on query complexity\n      const result = await this.poolerManager.query(sql, params);\n      return result.rows;\n    } else {\n      // Fallback to ElizaOS database adapter\n      return this.runtime.databaseAdapter.db.prepare(sql).all(...params);\n    }\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## âš¡ Performance Features\n\n### Batch Operations\n\n\u003Cdiv class=\"interactive-demo\">\n  \u003Ch3>ðŸš€ Parallel Query Execution\u003C/h3>\n  \n  \u003Cp>Execute multiple independent queries simultaneously for maximum performance:\u003C/p>\n\n```typescript\n// Execute multiple queries in parallel\nconst operations = [\n  { query: \"INSERT INTO users (name) VALUES ($1)\", params: [\"Alice\"] },\n  { query: \"INSERT INTO users (name) VALUES ($1)\", params: [\"Bob\"] },\n  {\n    query: \"UPDATE stats SET count = count + 1 WHERE type = $1\",\n    params: [\"login\"],\n  },\n];\n\nconst results = await this.poolerManager.batchExecute(operations);\n// All queries execute simultaneously using transaction pool\n```\n\n\u003C/div>\n\n### Transaction Support\n\n```typescript\n// Multi-query transactions with automatic rollback\nconst transactionQueries = [\n  {\n    sql: \"INSERT INTO raids (id, status) VALUES ($1, $2)\",\n    params: [raidId, \"active\"],\n  },\n  {\n    sql: \"INSERT INTO participants (raid_id, user_id) VALUES ($1, $2)\",\n    params: [raidId, userId],\n  },\n  {\n    sql: \"UPDATE user_stats SET raids_joined = raids_joined + 1 WHERE id = $1\",\n    params: [userId],\n  },\n];\n\ntry {\n  const results = await this.poolerManager.transaction(transactionQueries);\n  logger.info(\"Raid creation successful\");\n} catch (error) {\n  logger.error(\"Transaction failed, all changes rolled back\");\n}\n```\n\n### Connection Pool Statistics\n\nMonitor pool performance in real-time:\n\n```typescript\nconst stats = this.poolerManager.getPoolStats();\n\nconsole.log(\"Transaction Pool:\", {\n  total: stats.transactionPool?.totalCount,\n  idle: stats.transactionPool?.idleCount,\n  waiting: stats.transactionPool?.waitingCount,\n});\n\nconsole.log(\"Session Pool:\", {\n  total: stats.sessionPool?.totalCount,\n  idle: stats.sessionPool?.idleCount,\n  waiting: stats.sessionPool?.waitingCount,\n});\n```\n\n## ðŸ›¡ï¸ Error Handling & Resilience\n\n### Retry Logic\n\nThe DatabasePoolerManager includes intelligent retry logic for transient failures:\n\n\u003CTabs>\n  \u003CTabItem label=\"Retryable Errors\">\n```typescript\n// Automatically retries these PostgreSQL error codes\nconst retryableCodes = [\n  '08000', // connection_exception\n  '08003', // connection_does_not_exist\n  '08006', // connection_failure\n  '08001', // unable_to_establish_connection\n  '08004', // server_rejected_connection\n  '53300', // too_many_connections\n  '53200', // out_of_memory\n];\n\n// Usage with retry configuration\nconst result = await poolerManager.query(sql, params, {\nretries: 3, // Retry up to 3 times\ntimeout: 10000 // 10 second timeout\n});\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Error Recovery\">\n```typescript\ntry {\n  const result = await poolerManager.query(complexQuery, params);\n  return result.rows;\n} catch (error) {\n  if (error.code === '53300') {\n    // Too many connections - wait and retry with simpler query\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    return await poolerManager.query(fallbackQuery, params, {\n      poolType: PoolType.TRANSACTION\n    });\n  }\n  throw error;\n}\n````\n\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ“Š Performance Monitoring\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ“ˆ Query Performance\" icon=\"chart\">\n    - **Execution time tracking** per pool type - **Query complexity analysis**\n    - **Pool utilization metrics** - **Connection wait times**\n  \u003C/Card>\n\n\u003CCard title=\"ðŸŽ¯ Pool Efficiency\" icon=\"setting\">\n  - **Hit rate optimization** (99%+ target) - **Connection reuse statistics** -\n  **Idle connection management** - **Peak usage analysis**\n\u003C/Card>\n\n  \u003CCard title=\"ðŸš¨ Health Monitoring\" icon=\"warning\">\n    - **Connection failure rates** - **Timeout frequency tracking** - **Pool\n    exhaustion alerts** - **Performance degradation detection**\n  \u003C/Card>\n\u003C/CardGrid>\n\n## ðŸ”¬ Real-world Performance Impact\n\n### Before/After Comparison\n\n\u003Cdiv class=\"interactive-demo\">\n  \u003Ch3>ðŸ“Š Performance Metrics\u003C/h3>\n  \n  \u003Cdiv style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;\">\n    \u003Cdiv style=\"padding: 1.5rem; background: #f44336; color: white; border-radius: 8px;\">\n      \u003Ch4 style=\"margin: 0 0 1rem 0;\">âŒ Without Pooler Manager\u003C/h4>\n      \u003Cul style=\"margin: 0;\">\n        \u003Cli>Simple queries: ~150ms avg\u003C/li>\n        \u003Cli>Complex queries: ~2.5s avg\u003C/li>\n        \u003Cli>Connection overhead: ~50ms\u003C/li>\n        \u003Cli>Peak load failures: 15%\u003C/li>\n        \u003Cli>Resource utilization: Poor\u003C/li>\n      \u003C/ul>\n    \u003C/div>\n    \u003Cdiv style=\"padding: 1.5rem; background: #4caf50; color: white; border-radius: 8px;\">\n      \u003Ch4 style=\"margin: 0 0 1rem 0;\">âœ… With Pooler Manager\u003C/h4>\n      \u003Cul style=\"margin: 0;\">\n        \u003Cli>Simple queries: ~45ms avg\u003C/li>\n        \u003Cli>Complex queries: ~800ms avg\u003C/li>\n        \u003Cli>Connection overhead: ~5ms\u003C/li>\n        \u003Cli>Peak load failures: \u003C1%\u003C/li>\n        \u003Cli>Resource utilization: Optimal\u003C/li>\n      \u003C/ul>\n    \u003C/div>\n  \u003C/div>\n\u003C/div>\n\n\u003CAside type=\"tip\">\n  **Performance Tip**: The biggest performance gains come from eliminating\n  connection overhead for simple queries while providing dedicated resources for\n  complex operations.\n\u003C/Aside>\n\n## ðŸ§ª Testing & Development\n\n### Local Development Setup\n\n```typescript\n// Mock pooler manager for testing\nexport class MockDatabasePoolerManager {\n  async query\u003CT>(\n    sql: string,\n    params?: any[],\n  ): Promise\u003C{ rows: T[]; rowCount: number }> {\n    // Return mock data for testing\n    return { rows: [], rowCount: 0 };\n  }\n\n  async transaction\u003CT>(queries: any[]): Promise\u003CT[]> {\n    // Mock transaction execution\n    return [];\n  }\n\n  getPoolStats() {\n    return {\n      transactionPool: { totalCount: 5, idleCount: 3, waitingCount: 0 },\n      sessionPool: { totalCount: 2, idleCount: 1, waitingCount: 0 },\n    };\n  }\n}\n\n// Test suite\ndescribe(\"DatabasePoolerManager\", () => {\n  it(\"should route simple queries to transaction pool\", async () => {\n    const result = await poolerManager.query(\n      \"SELECT * FROM users WHERE id = $1\",\n      [1],\n    );\n    expect(result.rows).toBeDefined();\n  });\n\n  it(\"should route complex queries to session pool\", async () => {\n    const complexQuery = `\n      SELECT u.name, COUNT(r.id) \n      FROM users u \n      LEFT JOIN raids r ON u.id = r.user_id \n      GROUP BY u.name\n    `;\n    const result = await poolerManager.query(complexQuery);\n    expect(result.rows).toBeDefined();\n  });\n});\n```\n\n---\n\n\u003Cdiv class=\"nubi-note\">\n  \u003Cstrong>ðŸš€ Ready to optimize your database performance?\u003C/strong> The\n  DatabasePoolerManager is automatically registered in NUBI's service container\n  and available to all services. Learn more about{\" \"}\n  \u003Ca href=\"/database/query-routing/\">Query Routing\u003C/a> and{\" \"}\n  \u003Ca href=\"/database/performance/\">Performance Optimization\u003C/a>.\n\u003C/div>\n\n## Next Steps\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸŽ¯ Query Routing\" icon=\"puzzle\">\n    Deep dive into the intelligent query classification system. [Learn More\n    â†’](/database/query-routing/)\n  \u003C/Card>\n\n\u003CCard title=\"ðŸ§  Memory Service\" icon=\"approve-check\">\n  Understand how NUBI's memory system leverages the pooler. [Explore\n  â†’](/database/memory-service/)\n\u003C/Card>\n\n\u003CCard title=\"ðŸ“ˆ Performance Tips\" icon=\"chart\">\n  Advanced optimization techniques and best practices. [Optimize\n  â†’](/database/performance/)\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ”§ Configuration\" icon=\"setting\">\n    Complete configuration reference and troubleshooting. [Configure\n    â†’](/deployment/environment/)\n  \u003C/Card>\n\u003C/CardGrid>","src/content/docs/database/pooler-manager.mdx","e5bdf3160b1aa3b6","database/pooler-manager.mdx","index",{"id":50,"data":52,"body":74,"filePath":75,"digest":76,"legacyId":77,"deferredRender":16},{"title":53,"description":54,"editUrl":16,"head":55,"template":56,"hero":57,"sidebar":72,"pagefind":16,"draft":20},"NUBI - The Symbiotic Essence of Anubis","Advanced ElizaOS-based AI Agent with sophisticated UX integration, database pooling, and Telegram raid coordination.",[],"splash",{"tagline":58,"actions":59},"The Symbiotic Essence of Anubis - Your Advanced AI Community Manager",[60,67],{"text":61,"link":62,"variant":63,"icon":64},"Get Started","/getting-started/introduction/","primary",{"type":65,"name":66},"icon","right-arrow",{"text":68,"link":69,"variant":63,"icon":70},"View API Reference","/api/rest/",{"type":65,"name":71},"external",{"hidden":20,"attrs":73},{},"import { Card, CardGrid } from \"@astrojs/starlight/components\";\n\n## ðŸº Welcome to NUBI\n\nNUBI is an advanced ElizaOS-based AI agent that embodies the personality of an ancient jackal spirit with modern market wisdom. Serving as a sophisticated community manager with deep crypto/Solana knowledge, NUBI features cutting-edge UX integration, intelligent database pooling, and comprehensive Telegram raid coordination.\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ”Œ UX Integration System\" icon=\"laptop\">\n    Real-time Socket.IO communication with two-layer processing pipeline for\n    security and intelligent message classification.\n  \u003C/Card>\n  \u003CCard title=\"ðŸ—„ï¸ Smart Database Pooling\" icon=\"setting\">\n    Intelligent dual-pool architecture with automatic query routing between\n    transaction and session pools for optimal performance.\n  \u003C/Card>\n  \u003CCard title=\"ðŸš€ Telegram Raids\" icon=\"rocket\">\n    Advanced raid coordination system with engagement verification,\n    leaderboards, and cross-platform integration.\n  \u003C/Card>\n  \u003CCard title=\"ðŸ§  ElizaOS Core\" icon=\"approve-check\">\n    Built on the powerful ElizaOS framework with full plugin architecture and\n    modular service design.\n  \u003C/Card>\n\u003C/CardGrid>\n\n## âœ¨ Key Features\n\n### ðŸ—ï¸ **Modular Architecture**\n\n- **8 Core Modules**: Clean separation with dependency injection\n- **Type-Safe**: Eliminated `any` types with strict TypeScript\n- **Service-Oriented**: All services extend ElizaOS patterns\n\n### ðŸ” **Two-Layer Security Processing**\n\n1. **Layer 1**: Rate limiting, XSS prevention, content filtering\n2. **Layer 2**: Message classification, intelligent routing, prompt injection\n\n### ðŸ“Š **Performance Optimized**\n\n- **Database Poolers**: Transaction (6543) & Session (5432) pools\n- **Parallel Execution**: `Promise.all()` for independent operations\n- **Connection Management**: Centralized pooling with intelligent routing\n\n### ðŸŒ **Multi-Platform Integration**\n\n- **Discord**: Real-time community engagement\n- **Telegram**: Advanced raid coordination\n- **Twitter/X**: Social media integration\n- **Socket.IO**: Real-time web communication\n\n## ðŸš€ Quick Start\n\n```bash\n# Clone the repository\ngit clone https://github.com/anubis-chat/nubi\n\n# Install dependencies\nbun install\n\n# Configure environment\ncp .env.example .env\n# Edit .env with your API keys\n\n# Start development mode\nbun run dev\n```\n\n\u003Cdiv class=\"nubi-note\">\n  \u003Cstrong>ðŸ’¡ Pro Tip:\u003C/strong> NUBI automatically detects your database\n  configuration and switches between PGLite (development) and PostgreSQL\n  (production) based on available environment variables.\n\u003C/div>\n\n## ðŸ“– Documentation Structure\n\nThis documentation is organized to match NUBI's modular architecture:\n\n- **Getting Started**: Installation, configuration, and quick start\n- **Architecture**: Deep dive into the modular design and service layer\n- **UX Integration**: Socket.IO setup and two-layer processing system\n- **Database**: Pooler management, query routing, and performance\n- **Telegram Raids**: Coordination system and engagement verification\n- **API Reference**: Complete REST and WebSocket API documentation\n- **Deployment**: Production setup, Docker, and monitoring\n\n## ðŸ¤ Community & Support\n\n- **GitHub**: [anubis-chat/nubi](https://github.com/anubis-chat/nubi)\n- **Discord**: Join our community server\n- **Documentation**: You're reading it!\n- **Issues**: Report bugs and request features on GitHub\n\n---\n\n\u003Cdiv style=\"text-align: center; padding: 2rem; background: var(--nubi-hero-gradient); border-radius: 12px; color: white; margin: 2rem 0;\">\n  \u003Ch3 style=\"margin: 0 0 1rem 0; color: var(--nubi-jackal-gold);\">\n    Ready to unleash the power of NUBI?\n  \u003C/h3>\n  \u003Cp style=\"margin: 0 0 1.5rem 0; opacity: 0.9;\">\n    Start building with the most advanced AI agent framework.\n  \u003C/p>\n  \u003Ca\n    href=\"/getting-started/introduction/\"\n    style=\"background: var(--nubi-jackal-gold); color: var(--nubi-shadow-black); padding: 1rem 2rem; border-radius: 8px; text-decoration: none; font-weight: 600;\"\n  >\n    Begin Your Journey â†’\n  \u003C/a>\n\u003C/div>","src/content/docs/index.mdx","84ce70bb089371ba","index.mdx","telegram-raids/overview",{"id":78,"data":80,"body":86,"filePath":87,"digest":88,"legacyId":89,"deferredRender":16},{"title":81,"description":82,"editUrl":16,"head":83,"template":18,"sidebar":84,"pagefind":16,"draft":20},"Telegram Raids System Overview","Comprehensive guide to NUBI's advanced Telegram raid coordination system with engagement verification, leaderboards, and cross-platform integration.",[],{"hidden":20,"attrs":85},{},"import {\n  Card,\n  CardGrid,\n  Aside,\n  Code,\n  Tabs,\n  TabItem,\n} from \"@astrojs/starlight/components\";\n\n# Telegram Raids System Overview\n\nNUBI's **Telegram Raids System** is a sophisticated engagement coordination platform that transforms social media campaigns into gamified, strategic operations with military precision while maintaining community fun and authenticity.\n\n## ðŸŽ¯ What is a Telegram Raid?\n\n\u003Cdiv class=\"interactive-demo\">\n  \u003Ch3>âš”ï¸ Raid Definition\u003C/h3>\n  \u003Cdiv style=\"background: linear-gradient(135deg, var(--nubi-shadow-black) 0%, var(--nubi-jackal-gold) 100%); padding: 2rem; border-radius: 12px; color: white; margin: 2rem 0;\">\n    \u003Cp style=\"font-size: 1.2rem; margin: 0 0 1rem 0; text-align: center;\">\n      A \u003Cstrong>Telegram Raid\u003C/strong> is a coordinated social media engagement\n      campaign where community members simultaneously engage with target content\n      to boost visibility, demonstrate support, and drive organic growth.\n    \u003C/p>\n    \u003Cdiv style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-top: 2rem;\">\n      \u003Cdiv style=\"text-align: center; padding: 1rem; background: rgba(255,255,255,0.1); border-radius: 8px;\">\n        \u003Cstrong>ðŸŽ¯ Target\u003C/strong>\n        \u003Cbr />\n        \u003Csmall>Twitter posts, announcements, AMAs\u003C/small>\n      \u003C/div>\n      \u003Cdiv style=\"text-align: center; padding: 1rem; background: rgba(255,255,255,0.1); border-radius: 8px;\">\n        \u003Cstrong>âš¡ Action\u003C/strong>\n        \u003Cbr />\n        \u003Csmall>Like, RT, comment, follow\u003C/small>\n      \u003C/div>\n      \u003Cdiv style=\"text-align: center; padding: 1rem; background: rgba(255,255,255,0.1); border-radius: 8px;\">\n        \u003Cstrong>ðŸ† Reward\u003C/strong>\n        \u003Cbr />\n        \u003Csmall>Points, leaderboards, recognition\u003C/small>\n      \u003C/div>\n      \u003Cdiv style=\"text-align: center; padding: 1rem; background: rgba(255,255,255,0.1); border-radius: 8px;\">\n        \u003Cstrong>ðŸ“Š Analytics\u003C/strong>\n        \u003Cbr />\n        \u003Csmall>Engagement tracking, success metrics\u003C/small>\n      \u003C/div>\n    \u003C/div>\n  \u003C/div>\n\u003C/div>\n\n## ðŸ—ï¸ System Architecture\n\nNUBI's raid system implements a **comprehensive architecture** with multiple specialized components:\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸŽ® Raid Coordinator\" icon=\"rocket\">\n    **Central orchestrator** managing raid lifecycle and participant\n    coordination - Raid creation and configuration - Participant recruitment and\n    tracking - Real-time progress monitoring - Success metrics calculation\n  \u003C/Card>\n\n\u003CCard title=\"ðŸ” Engagement Verifier\" icon=\"approve-check\">\n  **Intelligent verification** system ensuring authentic engagement - Twitter\n  API integration for verification - Action completion detection - Anti-gaming\n  measures - Quality score calculation\n\u003C/Card>\n\n\u003CCard title=\"ðŸ† Leaderboard Service\" icon=\"chart\">\n  **Gamification engine** driving competition and motivation - Real-time point\n  calculations - Multi-dimensional rankings - Achievement system - Seasonal\n  competitions\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ›¡ï¸ Moderation System\" icon=\"warning\">\n    **Safety and quality** controls maintaining community standards - Automated\n    spam detection - Content quality assessment - Participant behavior\n    monitoring - Violation handling\n  \u003C/Card>\n\u003C/CardGrid>\n\n## ðŸŽ® Raid Types & Strategies\n\n\u003CTabs>\n  \u003CTabItem label=\"Engagement Raids\">\n```typescript\ninterface EngagementRaid {\n  type: 'engagement';\n  target: {\n    platform: 'twitter' | 'instagram' | 'tiktok';\n    url: string;\n    expectedActions: ('like' | 'retweet' | 'comment' | 'follow')[];\n  };\n  requirements: {\n    minParticipants: number;\n    timeLimit: number; // minutes\n    qualityThreshold: number; // 0-1\n  };\n  rewards: {\n    basePoints: number;\n    bonusMultipliers: RewardMultiplier[];\n    specialRewards: string[];\n  };\n}\n\n// Example engagement raid configuration\nconst twitterEngagementRaid: EngagementRaid = {\ntype: 'engagement',\ntarget: {\nplatform: 'twitter',\nurl: 'https://twitter.com/AnubisChat/status/1234567890',\nexpectedActions: ['like', 'retweet', 'comment']\n},\nrequirements: {\nminParticipants: 50,\ntimeLimit: 30, // 30 minutes\nqualityThreshold: 0.8\n},\nrewards: {\nbasePoints: 100,\nbonusMultipliers: [\n{ condition: 'early_participant', multiplier: 1.5 },\n{ condition: 'quality_comment', multiplier: 2.0 }\n],\nspecialRewards: ['Raid Champion NFT', 'Community Recognition']\n}\n};\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Growth Raids\">\n```typescript\ninterface GrowthRaid {\n  type: 'growth';\n  objective: 'follower_growth' | 'community_expansion' | 'brand_awareness';\n  targets: {\n    primaryAccounts: string[]; // Main accounts to follow\n    communityAccounts: string[]; // Community members to support\n    contentToShare: string[]; // Specific content to amplify\n  };\n  metrics: {\n    followerTarget: number;\n    engagementRate: number;\n    reachGoal: number;\n    hashtagTrending: string[];\n  };\n}\n\n// Example growth raid for community expansion\nconst communityGrowthRaid: GrowthRaid = {\n  type: 'growth',\n  objective: 'community_expansion',\n  targets: {\n    primaryAccounts: ['@AnubisChat', '@NUBI_Agent'],\n    communityAccounts: ['@CommunityMember1', '@Holder2'],\n    contentToShare: [\n      'https://twitter.com/AnubisChat/post1',\n      'https://twitter.com/NUBI_Agent/post2'\n    ]\n  },\n  metrics: {\n    followerTarget: 1000,\n    engagementRate: 0.15, // 15% engagement rate goal\n    reachGoal: 50000,\n    hashtagTrending: ['#NUBI', '#AnubisChat', '#CommunityPower']\n  }\n};\n````\n\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Defense Raids\">\n```typescript\ninterface DefenseRaid {\n  type: 'defense';\n  threat: 'fud_campaign' | 'coordinated_attack' | 'misinformation';\n  targets: {\n    threateningContent: string[]; // Content to counter\n    supportContent: string[]; // Positive content to boost\n    protectedAccounts: string[]; // Accounts to defend\n  };\n  strategy: {\n    counterNarrative: string;\n    factualRebuttals: string[];\n    communityResponse: 'unified' | 'distributed' | 'stealth';\n    escalationProtocol: EscalationLevel[];\n  };\n}\n\n// Example defense raid against FUD\nconst fudDefenseRaid: DefenseRaid = {\ntype: 'defense',\nthreat: 'fud_campaign',\ntargets: {\nthreateningContent: [\n'https://twitter.com/fudder/status/malicious-post'\n],\nsupportContent: [\n'https://twitter.com/AnubisChat/status/truth-post'\n],\nprotectedAccounts: ['@AnubisChat', '@NUBI_Agent']\n},\nstrategy: {\ncounterNarrative: 'NUBI represents innovation and community strength',\nfactualRebuttals: [\n'Technical audit confirms security',\n'Community growth metrics are public',\n'Partnership announcements are verified'\n],\ncommunityResponse: 'unified',\nescalationProtocol: ['community_response', 'influencer_support', 'official_statement']\n}\n};\n\n````\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## âš¡ Real-time Coordination Flow\n\n\u003Cdiv class=\"interactive-demo\">\n  \u003Ch3>ðŸ“± Telegram Bot Interaction Flow\u003C/h3>\n  \u003Cdiv style=\"background: var(--nubi-shadow-black); color: var(--nubi-jackal-gold); padding: 2rem; border-radius: 8px; font-family: monospace; margin: 2rem 0;\">\n    \u003Cdiv style=\"margin-bottom: 1rem;\">\u003Cstrong>1.\u003C/strong> ðŸŽ¯ \u003Cspan style=\"color: white;\">NUBI:\u003C/span> \"ðŸš€ NEW RAID ALERT! Target: Twitter engagement\"\u003C/div>\n    \u003Cdiv style=\"margin-bottom: 1rem;\">\u003Cstrong>2.\u003C/strong> ðŸ‘¤ \u003Cspan style=\"color: white;\">User:\u003C/span> \"/join\" \u003C/div>\n    \u003Cdiv style=\"margin-bottom: 1rem;\">\u003Cstrong>3.\u003C/strong> ðŸŽ¯ \u003Cspan style=\"color: white;\">NUBI:\u003C/span> \"âœ… Joined! Your mission: Like + RT + comment\"\u003C/div>\n    \u003Cdiv style=\"margin-bottom: 1rem;\">\u003Cstrong>4.\u003C/strong> ðŸ‘¤ \u003Cspan style=\"color: white;\">User:\u003C/span> \"/complete https://twitter.com/target/post\"\u003C/div>\n    \u003Cdiv style=\"margin-bottom: 1rem;\">\u003Cstrong>5.\u003C/strong> ðŸ” \u003Cspan style=\"color: white;\">System:\u003C/span> \"Verifying engagement...\" \u003C/div>\n    \u003Cdiv style=\"margin-bottom: 1rem;\">\u003Cstrong>6.\u003C/strong> ðŸŽ¯ \u003Cspan style=\"color: white;\">NUBI:\u003C/span> \"ðŸ† VERIFIED! +150 points. Rank: #12\"\u003C/div>\n  \u003C/div>\n\u003C/div>\n\n### Command System\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸŽ¯ Raid Commands\" icon=\"rocket\">\n    **Core raid interaction** commands for participants\n\n    ```bash\n    /raids - List active raids\n    /join \u003Craid_id> - Join a raid\n    /leave \u003Craid_id> - Leave a raid\n    /complete \u003Cproof_url> - Submit completion\n    /status - Check your progress\n    ```\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ† Leaderboard Commands\" icon=\"chart\">\n    **Competition and ranking** commands for gamification\n\n    ```bash\n    /leaderboard - Show top participants\n    /rank - Your current ranking\n    /points - Your point balance\n    /achievements - Earned badges\n    /history - Your raid history\n    ```\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ‘‘ Admin Commands\" icon=\"warning\">\n    **Management commands** for raid coordinators\n\n    ```bash\n    /create_raid - Create new raid\n    /end_raid \u003Craid_id> - End raid early\n    /verify_manual \u003Cuser> - Manual verification\n    /ban \u003Cuser> - Remove participant\n    /analytics \u003Craid_id> - View metrics\n    ```\n  \u003C/Card>\n\n  \u003CCard title=\"â„¹ï¸ Info Commands\" icon=\"approve-check\">\n    **Information and help** commands for users\n\n    ```bash\n    /help - Show all commands\n    /rules - Raid participation rules\n    /about - System information\n    /support - Get help\n    /feedback - Submit feedback\n    ```\n  \u003C/Card>\n\u003C/CardGrid>\n\n## ðŸ† Advanced Leaderboard System\n\nNUBI implements a **multi-dimensional ranking system** that rewards different types of participation:\n\n\u003CTabs>\n  \u003CTabItem label=\"Ranking Categories\">\n```typescript\ninterface LeaderboardMetrics {\n  // Primary metrics\n  totalPoints: number;\n  raidsCompleted: number;\n  verificationRate: number; // Percentage of successful verifications\n  avgResponseTime: number; // Speed of participation\n\n  // Quality metrics\n  commentQuality: number; // AI-assessed comment value\n  engagementValue: number; // Influence-weighted engagement\n  consistencyScore: number; // Regular participation\n  teamworkBonus: number; // Collaboration with others\n\n  // Special achievements\n  raidLeader: number; // Times led a raid\n  firstParticipant: number; // Early bird bonus count\n  mvpRaids: number; // Most valuable participant awards\n  streakDays: number; // Consecutive participation days\n}\n\n// Example leaderboard calculation\nclass LeaderboardCalculator {\n  calculateCompositeScore(metrics: LeaderboardMetrics): number {\n    return (\n      metrics.totalPoints * 0.3 +\n      metrics.raidsCompleted * 10 * 0.2 +\n      metrics.verificationRate * 1000 * 0.15 +\n      metrics.commentQuality * 500 * 0.15 +\n      metrics.consistencyScore * 300 * 0.1 +\n      metrics.teamworkBonus * 0.1\n    );\n  }\n}\n````\n\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Achievement System\">\n```typescript\ninterface Achievement {\n  id: string;\n  name: string;\n  description: string;\n  icon: string;\n  rarity: 'common' | 'rare' | 'epic' | 'legendary';\n  requirements: AchievementRequirement[];\n  rewards: AchievementReward[];\n}\n\nconst achievements: Achievement[] = [\n{\nid: 'raid_rookie',\nname: 'Raid Rookie',\ndescription: 'Complete your first raid',\nicon: 'ðŸŽ¯',\nrarity: 'common',\nrequirements: [{ type: 'raids_completed', value: 1 }],\nrewards: [{ type: 'points', value: 100 }, { type: 'badge', value: 'rookie' }]\n},\n{\nid: 'engagement_master',\nname: 'Engagement Master',\ndescription: 'Achieve 100% verification rate over 50 raids',\nicon: 'ðŸ†',\nrarity: 'epic',\nrequirements: [\n{ type: 'raids_completed', value: 50 },\n{ type: 'verification_rate', value: 1.0 }\n],\nrewards: [\n{ type: 'points', value: 5000 },\n{ type: 'nft', value: 'engagement_master' },\n{ type: 'role', value: 'Elite Raider' }\n]\n},\n{\nid: 'speed_demon',\nname: 'Speed Demon',\ndescription: 'Complete 10 raids within 5 minutes of launch',\nicon: 'âš¡',\nrarity: 'rare',\nrequirements: [\n{ type: 'fast_completions', value: 10, timeframe: 300 }\n],\nrewards: [\n{ type: 'points', value: 1000 },\n{ type: 'multiplier', value: 1.1, duration: '7d' }\n]\n},\n{\nid: 'community_guardian',\nname: 'Community Guardian',\ndescription: 'Lead 25 successful defense raids',\nicon: 'ðŸ›¡ï¸',\nrarity: 'legendary',\nrequirements: [\n{ type: 'defense_raids_led', value: 25 },\n{ type: 'defense_success_rate', value: 0.9 }\n],\nrewards: [\n{ type: 'points', value: 10000 },\n{ type: 'nft', value: 'guardian_shield' },\n{ type: 'role', value: 'Community Guardian' },\n{ type: 'privilege', value: 'create_defense_raids' }\n]\n}\n];\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Seasonal Competition\">\n```typescript\ninterface Season {\n  id: string;\n  name: string;\n  startDate: Date;\n  endDate: Date;\n  theme: string;\n  specialRules: SeasonRule[];\n  rewards: SeasonReward[];\n}\n\ninterface SeasonRule {\n  type: 'point_multiplier' | 'bonus_action' | 'special_raid';\n  condition: string;\n  effect: any;\n}\n\nconst currentSeason: Season = {\n  id: 'anubis_ascension_2024',\n  name: 'Anubis Ascension',\n  startDate: new Date('2024-01-01'),\n  endDate: new Date('2024-03-31'),\n  theme: 'Ancient Egyptian mythology meets modern crypto',\n  specialRules: [\n    {\n      type: 'point_multiplier',\n      condition: 'raids_with_anubis_hashtag',\n      effect: { multiplier: 1.5 }\n    },\n    {\n      type: 'bonus_action',\n      condition: 'comment_includes_egyptian_reference',\n      effect: { bonus_points: 50 }\n    },\n    {\n      type: 'special_raid',\n      condition: 'weekend_pyramid_raids',\n      effect: { exclusive_access: true, double_points: true }\n    }\n  ],\n  rewards: [\n    {\n      rank: 1,\n      prize: 'Golden Anubis NFT + 50,000 $NUBI',\n      title: 'Supreme Pharaoh'\n    },\n    {\n      rank: '2-10',\n      prize: 'Silver Anubis NFT + 10,000 $NUBI',\n      title: 'Temple Guardian'\n    },\n    {\n      rank: '11-50',\n      prize: 'Bronze Anubis NFT + 1,000 $NUBI',\n      title: 'Loyal Servant'\n    }\n  ]\n};\n````\n\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ” Engagement Verification\n\n\u003CAside type=\"tip\">\n  **Smart Verification**: NUBI's verification system uses multiple data sources\n  including Twitter API, blockchain transactions, and AI-powered content\n  analysis to ensure authentic engagement.\n\u003C/Aside>\n\n### Multi-layered Verification Process\n\n\u003Cdiv class=\"interactive-demo\">\n  \u003Ch3>ðŸ”Ž Verification Pipeline\u003C/h3>\n  \u003Cdiv style=\"display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin: 2rem 0;\">\n    \u003Cdiv style=\"padding: 1rem; background: linear-gradient(135deg, #4caf50, #45a049); color: white; border-radius: 8px; text-align: center;\">\n      \u003Cstrong>1. API Check\u003C/strong>\n      \u003Cbr />\n      \u003Csmall>Twitter API verification of actual engagement\u003C/small>\n    \u003C/div>\n    \u003Cdiv style=\"padding: 1rem; background: linear-gradient(135deg, #2196f3, #1976d2); color: white; border-radius: 8px; text-align: center;\">\n      \u003Cstrong>2. Quality Scan\u003C/strong>\n      \u003Cbr />\n      \u003Csmall>AI analysis of comment quality and relevance\u003C/small>\n    \u003C/div>\n    \u003Cdiv style=\"padding: 1rem; background: linear-gradient(135deg, #ff9800, #f57c00); color: white; border-radius: 8px; text-align: center;\">\n      \u003Cstrong>3. Timing Check\u003C/strong>\n      \u003Cbr />\n      \u003Csmall>Verification of participation timeline\u003C/small>\n    \u003C/div>\n    \u003Cdiv style=\"padding: 1rem; background: linear-gradient(135deg, #9c27b0, #7b1fa2); color: white; border-radius: 8px; text-align: center;\">\n      \u003Cstrong>4. Final Score\u003C/strong>\n      \u003Cbr />\n      \u003Csmall>Composite score and point allocation\u003C/small>\n    \u003C/div>\n  \u003C/div>\n\u003C/div>\n\n\u003CTabs>\n  \u003CTabItem label=\"Twitter API Integration\">\n```typescript\nexport class TwitterVerifier {\n  private twitterClient: TwitterClient;\n  \n  async verifyEngagement(\n    tweetUrl: string,\n    userId: string,\n    actions: EngagementAction[]\n  ): Promise\u003CVerificationResult> {\n    const tweetId = this.extractTweetId(tweetUrl);\n    const results: ActionVerification[] = [];\n    \n    for (const action of actions) {\n      switch (action) {\n        case 'like':\n          const likeVerified = await this.verifyLike(tweetId, userId);\n          results.push({ action: 'like', verified: likeVerified });\n          break;\n          \n        case 'retweet':\n          const retweetVerified = await this.verifyRetweet(tweetId, userId);\n          results.push({ action: 'retweet', verified: retweetVerified });\n          break;\n          \n        case 'comment':\n          const commentResult = await this.verifyComment(tweetId, userId);\n          results.push({ \n            action: 'comment', \n            verified: commentResult.verified,\n            quality: commentResult.quality \n          });\n          break;\n          \n        case 'follow':\n          const followVerified = await this.verifyFollow(tweetId, userId);\n          results.push({ action: 'follow', verified: followVerified });\n          break;\n      }\n    }\n    \n    return {\n      overall_verified: results.every(r => r.verified),\n      action_results: results,\n      verification_score: this.calculateScore(results),\n      timestamp: new Date()\n    };\n  }\n  \n  private async verifyComment(tweetId: string, userId: string): Promise\u003CCommentVerification> {\n    // Get comments on the tweet\n    const comments = await this.twitterClient.getComments(tweetId);\n    const userComment = comments.find(c => c.author_id === userId);\n    \n    if (!userComment) {\n      return { verified: false, quality: 0 };\n    }\n    \n    // Analyze comment quality with AI\n    const quality = await this.analyzeCommentQuality(userComment.text);\n    \n    return {\n      verified: true,\n      quality,\n      comment: userComment.text,\n      engagement: userComment.public_metrics\n    };\n  }\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"AI Quality Analysis\">\n```typescript\nimport { pipeline } from '@huggingface/transformers';\n\nexport class QualityAnalyzer {\n  private sentimentAnalyzer: any;\n  private relevanceModel: any;\n  \n  async analyzeCommentQuality(comment: string): Promise\u003CQualityScore> {\n    const [sentiment, relevance, toxicity] = await Promise.all([\n      this.analyzeSentiment(comment),\n      this.analyzeRelevance(comment), \n      this.checkToxicity(comment)\n    ]);\n    \n    // Calculate composite quality score\n    const qualityScore = this.calculateQualityScore({\n      sentiment,\n      relevance, \n      toxicity,\n      length: comment.length,\n      hasHashtags: /#\\w+/.test(comment),\n      hasMentions: /@\\w+/.test(comment),\n      hasEmojis: /[\\u{1F600}-\\u{1F64F}]/u.test(comment)\n    });\n    \n    return {\n      overall: qualityScore,\n      breakdown: {\n        sentiment: sentiment.score,\n        relevance: relevance.score,\n        toxicity: toxicity.score,\n        engagement_potential: this.estimateEngagementPotential(comment)\n      },\n      feedback: this.generateFeedback(qualityScore, comment)\n    };\n  }\n  \n  private calculateQualityScore(metrics: QualityMetrics): number {\n    let score = 0.5; // Base score\n    \n    // Positive sentiment bonus\n    if (metrics.sentiment.label === 'POSITIVE') {\n      score += 0.2 * metrics.sentiment.confidence;\n    }\n    \n    // Relevance bonus (using semantic similarity)\n    score += 0.3 * metrics.relevance.score;\n    \n    // Toxicity penalty\n    score -= 0.5 * metrics.toxicity.score;\n    \n    // Length bonus (optimal range: 50-280 characters)\n    const lengthFactor = Math.min(1, metrics.length / 50) * Math.max(0, (280 - metrics.length) / 280);\n    score += 0.1 * lengthFactor;\n    \n    // Engagement features bonus\n    if (metrics.hasHashtags) score += 0.05;\n    if (metrics.hasMentions) score += 0.05; \n    if (metrics.hasEmojis) score += 0.05;\n    \n    return Math.max(0, Math.min(1, score));\n  }\n  \n  private generateFeedback(score: number, comment: string): string[] {\n    const feedback: string[] = [];\n    \n    if (score \u003C 0.3) {\n      feedback.push('Consider making your comment more relevant to the topic');\n      feedback.push('Try adding constructive thoughts or questions');\n    } else if (score \u003C 0.6) {\n      feedback.push('Good comment! Consider adding relevant hashtags');\n      feedback.push('Engaging with the community builds stronger connections');\n    } else {\n      feedback.push('Excellent quality comment!');\n      feedback.push('Your engagement adds real value to the conversation');\n    }\n    \n    return feedback;\n  }\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Anti-Gaming Measures\">\n```typescript\nexport class AntiGamingSystem {\n  private suspiciousPatterns = new Map\u003Cstring, SuspiciousActivity>();\n  private qualityThresholds = {\n    minCommentQuality: 0.4,\n    maxSimilarComments: 3,\n    minTimeBetweenActions: 30000, // 30 seconds\n    maxActionsPerHour: 20\n  };\n  \n  async checkForGaming(\n    userId: string, \n    action: EngagementAction,\n    content?: string\n  ): Promise\u003CGamingCheckResult> {\n    const checks = await Promise.all([\n      this.checkRateLimit(userId, action),\n      this.checkContentSimilarity(userId, content),\n      this.checkBehaviorPatterns(userId),\n      this.checkAccountAuthenticity(userId)\n    ]);\n    \n    const riskScore = checks.reduce((sum, check) => sum + check.risk, 0) / checks.length;\n    \n    return {\n      allowed: riskScore \u003C 0.7,\n      riskScore,\n      warnings: checks.filter(c => c.risk > 0.5).map(c => c.warning),\n      recommendations: this.generateRecommendations(checks)\n    };\n  }\n  \n  private async checkContentSimilarity(userId: string, content?: string): Promise\u003CRiskCheck> {\n    if (!content) return { risk: 0, warning: '' };\n    \n    const userHistory = await this.getUserCommentHistory(userId);\n    const similarities = userHistory.map(historical => \n      this.calculateSimilarity(content, historical.content)\n    );\n    \n    const maxSimilarity = Math.max(...similarities);\n    const similarCount = similarities.filter(s => s > 0.8).length;\n    \n    if (similarCount >= this.qualityThresholds.maxSimilarComments) {\n      return {\n        risk: 0.9,\n        warning: 'Repetitive comment patterns detected',\n        details: { maxSimilarity, similarCount }\n      };\n    }\n    \n    return { \n      risk: maxSimilarity * 0.5,\n      warning: maxSimilarity > 0.8 ? 'Comment too similar to previous submissions' : ''\n    };\n  }\n  \n  private async checkBehaviorPatterns(userId: string): Promise\u003CRiskCheck> {\n    const recentActivity = await this.getUserRecentActivity(userId);\n    \n    // Check for bot-like patterns\n    const timeIntervals = this.calculateTimeIntervals(recentActivity);\n    const intervalVariation = this.calculateVariation(timeIntervals);\n    \n    // Human behavior typically has more variation in timing\n    if (intervalVariation \u003C 0.2) {\n      return {\n        risk: 0.8,\n        warning: 'Suspicious timing patterns detected',\n        details: { intervalVariation }\n      };\n    }\n    \n    // Check for coordinated behavior\n    const coordinationScore = await this.checkCoordination(userId, recentActivity);\n    \n    return {\n      risk: coordinationScore,\n      warning: coordinationScore > 0.7 ? 'Possible coordinated behavior' : ''\n    };\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ“Š Analytics & Metrics\n\nNUBI's raid system provides comprehensive analytics for measuring campaign effectiveness:\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ“ˆ Real-time Metrics\" icon=\"chart\">\n    **Live performance tracking** during active raids - Participant count and\n    growth rate - Engagement completion rates - Quality score distributions -\n    Target reach and impressions\n  \u003C/Card>\n\n\u003CCard title=\"ðŸŽ¯ Success Analysis\" icon=\"approve-check\">\n  **Post-raid effectiveness** measurement - Engagement rate improvements -\n  Follower growth attribution - Viral coefficient calculation - ROI on community\n  effort\n\u003C/Card>\n\n\u003CCard title=\"ðŸ‘¥ Community Health\" icon=\"user\">\n  **Participant behavior** and satisfaction metrics - Retention rates across\n  raids - Engagement quality trends - Satisfaction surveys - Community growth\n  impact\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ” Competitive Intel\" icon=\"setting\">\n    **Market positioning** and competitor analysis - Comparative engagement\n    rates - Community size benchmarks - Sentiment analysis - Trend\n    identification\n  \u003C/Card>\n\u003C/CardGrid>\n\n---\n\n\u003Cdiv class=\"nubi-note\">\n  \u003Cstrong>âš”ï¸ Ready to lead the charge?\u003C/strong> NUBI's Telegram Raids system\n  transforms social media engagement into strategic community operations.\n  Explore \u003Ca href=\"/telegram-raids/coordination/\">Raid Coordination\u003C/a> to learn\n  how to create and manage campaigns, or dive into{\" \"}\n  \u003Ca href=\"/telegram-raids/verification/\">Engagement Verification\u003C/a> to\n  understand our advanced quality systems.\n\u003C/div>\n\n## Next Steps\n\n\u003CCardGrid>\n  \u003CCard title=\"âš¡ Raid Coordination\" icon=\"rocket\">\n    Learn how to create, manage, and execute successful raid campaigns.\n    [Coordinate â†’](/telegram-raids/coordination/)\n  \u003C/Card>\n\n\u003CCard title=\"ðŸ” Engagement Verification\" icon=\"approve-check\">\n  Understand the multi-layered verification and quality assessment system.\n  [Verify â†’](/telegram-raids/verification/)\n\u003C/Card>\n\n\u003CCard title=\"ðŸ† Leaderboards & Rewards\" icon=\"chart\">\n  Explore the gamification system that drives community participation. [Compete\n  â†’](/telegram-raids/leaderboards/)\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ›¡ï¸ Safety & Moderation\" icon=\"warning\">\n    Discover how NUBI maintains quality and prevents abuse in raids. [Secure\n    â†’](/telegram-raids/moderation/)\n  \u003C/Card>\n\u003C/CardGrid>","src/content/docs/telegram-raids/overview.mdx","d749b8c6e4898b8f","telegram-raids/overview.mdx","ux-integration/socketio",{"id":90,"data":92,"body":98,"filePath":99,"digest":100,"legacyId":101,"deferredRender":16},{"title":93,"description":94,"editUrl":16,"head":95,"template":18,"sidebar":96,"pagefind":16,"draft":20},"Socket.IO Server Setup","Learn how to configure NUBI's Socket.IO server with advanced middleware, connection management, and real-time communication.",[],{"hidden":20,"attrs":97},{},"import {\n  Card,\n  CardGrid,\n  Aside,\n  Code,\n  Tabs,\n  TabItem,\n} from \"@astrojs/starlight/components\";\n\n# Socket.IO Server Setup\n\nNUBI's Socket.IO server implementation provides **enterprise-grade real-time communication** with advanced middleware, connection management, and seamless integration with ElizaOS core systems.\n\n## ðŸš€ Server Architecture\n\n\u003Cdiv class=\"interactive-demo\">\n  \u003Ch3>ðŸ“¡ Connection Flow\u003C/h3>\n  \u003Cdiv style=\"display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin: 2rem 0;\">\n    \u003Cdiv style=\"padding: 1rem; background: var(--nubi-spirit-blue); color: white; border-radius: 8px; text-align: center;\">\n      \u003Cstrong>1. Connect\u003C/strong>\n      \u003Cbr />\n      \u003Csmall>Client â†’ Server\u003C/small>\n      \u003Cbr />\n      \u003Ccode>socket.connect()\u003C/code>\n    \u003C/div>\n    \u003Cdiv style=\"padding: 1rem; background: var(--nubi-jackal-gold); color: var(--nubi-shadow-black); border-radius: 8px; text-align: center;\">\n      \u003Cstrong>2. Auth\u003C/strong>\n      \u003Cbr />\n      \u003Csmall>Session Creation\u003C/small>\n      \u003Cbr />\n      \u003Ccode>authenticate()\u003C/code>\n    \u003C/div>\n    \u003Cdiv style=\"padding: 1rem; background: var(--nubi-ancient-bronze); color: white; border-radius: 8px; text-align: center;\">\n      \u003Cstrong>3. Process\u003C/strong>\n      \u003Cbr />\n      \u003Csmall>Two-Layer Pipeline\u003C/small>\n      \u003Cbr />\n      \u003Ccode>process(message)\u003C/code>\n    \u003C/div>\n    \u003Cdiv style=\"padding: 1rem; background: var(--nubi-mystic-purple); color: white; border-radius: 8px; text-align: center;\">\n      \u003Cstrong>4. Respond\u003C/strong>\n      \u003Cbr />\n      \u003Csmall>AI â†’ Broadcast\u003C/small>\n      \u003Cbr />\n      \u003Ccode>emit(response)\u003C/code>\n    \u003C/div>\n  \u003C/div>\n\u003C/div>\n\n## âš™ï¸ Server Configuration\n\n\u003CTabs>\n  \u003CTabItem label=\"Basic Setup\">\n```typescript\nimport { Server } from \"socket.io\";\nimport { createServer } from \"http\";\nimport { SessionManager } from \"../services/sessions-service\";\nimport { MessageRouter } from \"../messaging/message-router\";\n\nexport class SocketIOServer {\n  private io: Server;\n  private sessionManager: SessionManager;\n  private messageRouter: MessageRouter;\n  \n  constructor(httpServer: any, runtime: IAgentRuntime) {\n    this.io = new Server(httpServer, {\n      cors: {\n        origin: this.getAllowedOrigins(),\n        methods: [\"GET\", \"POST\"],\n        credentials: true\n      },\n      transports: ['websocket', 'polling'],\n      pingTimeout: 60000,\n      pingInterval: 25000\n    });\n    \n    this.sessionManager = new SessionManager(runtime);\n    this.messageRouter = new MessageRouter(runtime);\n    this.setupEventHandlers();\n  }\n  \n  private getAllowedOrigins(): string[] {\n    return process.env.ALLOWED_ORIGINS?.split(',') || [\n      \"http://localhost:3000\",\n      \"https://anubis.chat\",\n      \"https://app.anubis.chat\"\n    ];\n  }\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Advanced Configuration\">\n```typescript\n// Production-ready configuration with clustering support\nexport const socketConfig = {\n  // Connection settings\n  pingTimeout: 60000,           // 60 seconds\n  pingInterval: 25000,          // 25 seconds\n  maxHttpBufferSize: 1e6,       // 1MB\n  allowEIO3: false,             // Force Engine.IO v4\n  \n  // Clustering support\n  adapter: process.env.REDIS_URL ? \n    createAdapter(process.env.REDIS_URL) : undefined,\n    \n  // Security settings\n  cors: {\n    origin: getAllowedOrigins(),\n    credentials: true,\n    optionsSuccessStatus: 200\n  },\n  \n  // Transport configuration\n  transports: ['websocket', 'polling'],\n  allowUpgrades: true,\n  perMessageDeflate: {\n    threshold: 1024,\n    concurrencyLimit: 10,\n    memLevel: 7\n  }\n};\n\n// Connection limiting\nconst connectionLimiter = rateLimit({\nwindowMs: 15 _ 60 _ 1000, // 15 minutes\nmax: 100, // 100 connections per IP\nmessage: \"Too many connections from this IP\"\n});\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Environment Variables\">\n```bash\n# Socket.IO Server Configuration\nSOCKET_PORT=3001\nSOCKET_HOST=0.0.0.0\n\n# CORS Configuration\nALLOWED_ORIGINS=http://localhost:3000,https://anubis.chat,https://app.anubis.chat\n\n# Redis Adapter (for clustering)\nREDIS_URL=redis://localhost:6379\n\n# Connection Limits\nMAX_CONNECTIONS_PER_IP=100\nCONNECTION_RATE_LIMIT_WINDOW=900000  # 15 minutes\n\n# Session Management\nSESSION_TIMEOUT=1800000              # 30 minutes\nSESSION_CLEANUP_INTERVAL=300000      # 5 minutes\n\n# Performance Tuning\nSOCKET_PING_TIMEOUT=60000\nSOCKET_PING_INTERVAL=25000\nMAX_HTTP_BUFFER_SIZE=1048576         # 1MB\n````\n\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ”Œ Connection Management\n\n### Session Lifecycle\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ”— Connection Established\" icon=\"rocket\">\n    **Automatic session creation** with unique ID generation\n    \n    ```typescript\n    socket.on('connect', async () => {\n      const sessionId = crypto.randomUUID();\n      socket.data.sessionId = sessionId;\n      \n      await sessionManager.createSession({\n        sessionId,\n        socketId: socket.id,\n        connectedAt: new Date(),\n        platform: 'websocket'\n      });\n    });\n    ```\n  \u003C/Card>\n  \n  \u003CCard title=\"ðŸ  Room Management\" icon=\"setting\">\n    **Dynamic room joining** with automatic user tracking\n    \n    ```typescript\n    socket.on('join-room', async (data) => {\n      await socket.join(data.roomId);\n      \n      socket.broadcast.to(data.roomId).emit('user-joined', {\n        userId: data.userId,\n        username: data.username,\n        timestamp: new Date()\n      });\n    });\n    ```\n  \u003C/Card>\n  \n  \u003CCard title=\"ðŸ’¬ Message Processing\" icon=\"approve-check\">\n    **Two-layer pipeline** with security and classification\n    \n    ```typescript\n    socket.on('send-message', async (data) => {\n      const result = await processMessage(data, socket);\n      \n      io.to(data.roomId).emit('message-received', {\n        ...result,\n        timestamp: new Date()\n      });\n    });\n    ```\n  \u003C/Card>\n  \n  \u003CCard title=\"ðŸ”„ State Synchronization\" icon=\"puzzle\">\n    **Real-time world state** broadcasting\n    \n    ```typescript\n    socket.on('request-world-state', async () => {\n      const worldState = await getWorldState();\n      \n      socket.emit('world-state', {\n        users: worldState.activeUsers,\n        rooms: worldState.activeRooms,\n        stats: worldState.metrics\n      });\n    });\n    ```\n  \u003C/Card>\n\u003C/CardGrid>\n\n### Connection Monitoring\n\n\u003CTabs>\n  \u003CTabItem label=\"Health Checks\">\n```typescript\nexport class ConnectionMonitor {\n  private healthCheckInterval: NodeJS.Timeout;\n  \n  constructor(private io: Server) {\n    this.startHealthChecks();\n  }\n  \n  private startHealthChecks(): void {\n    this.healthCheckInterval = setInterval(() => {\n      const stats = {\n        totalConnections: this.io.sockets.sockets.size,\n        totalRooms: this.io.sockets.adapter.rooms.size,\n        timestamp: new Date()\n      };\n      \n      logger.debug(`[SOCKET_MONITOR] ${stats.totalConnections} active connections`);\n      \n      // Emit to monitoring clients\n      this.io.emit('server-stats', stats);\n    }, 30000); // Every 30 seconds\n  }\n  \n  getConnectionStats() {\n    return {\n      connections: this.io.sockets.sockets.size,\n      rooms: this.io.sockets.adapter.rooms.size,\n      namespaces: Object.keys(this.io._nsps).length\n    };\n  }\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Error Handling\">\n```typescript\n// Global error handling for Socket.IO\nexport function setupErrorHandling(io: Server) {\n  io.engine.on(\"connection_error\", (err) => {\n    logger.error(`[SOCKET_ERROR] Connection failed:`, {\n      code: err.code,\n      message: err.message,\n      context: err.context,\n      type: err.type\n    });\n  });\n  \n  // Handle individual socket errors\n  io.on(\"connection\", (socket) => {\n    socket.on(\"error\", (error) => {\n      logger.error(`[SOCKET_ERROR] Socket ${socket.id}:`, error);\n      \n      socket.emit(\"error\", {\n        message: \"An error occurred\",\n        code: error.code || \"UNKNOWN\",\n        timestamp: new Date()\n      });\n    });\n    \n    socket.on(\"disconnect\", (reason) => {\n      logger.info(`[SOCKET_DISCONNECT] ${socket.id}: ${reason}`);\n      \n      // Cleanup session\n      if (socket.data.sessionId) {\n        sessionManager.endSession(socket.data.sessionId);\n      }\n    });\n  });\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ›¡ï¸ Middleware Pipeline\n\nNUBI implements a sophisticated middleware system for request processing:\n\n\u003Cdiv class=\"interactive-demo\">\n  \u003Ch3>ðŸ”„ Middleware Chain\u003C/h3>\n  \u003Cdiv style=\"font-family: monospace; background: var(--nubi-shadow-black); color: var(--nubi-jackal-gold); padding: 2rem; border-radius: 8px; margin: 2rem 0;\">\n    Request â†’ Authentication â†’ Rate Limiting â†’ Validation â†’ Security â†’\n    Processing â†’ Response\n  \u003C/div>\n\u003C/div>\n\n\u003CTabs>\n  \u003CTabItem label=\"Authentication Middleware\">\n```typescript\nexport function authenticationMiddleware() {\n  return async (socket: Socket, next: (err?: ExtendedError) => void) => {\n    try {\n      const token = socket.handshake.auth.token;\n      \n      if (!token && process.env.NODE_ENV === 'production') {\n        return next(new Error('Authentication required'));\n      }\n      \n      // Verify token if provided\n      if (token) {\n        const payload = await verifyJWT(token);\n        socket.data.userId = payload.userId;\n        socket.data.userRole = payload.role;\n      }\n      \n      // Generate anonymous session if no auth\n      socket.data.sessionId = crypto.randomUUID();\n      socket.data.connectedAt = new Date();\n      \n      logger.debug(`[AUTH] Socket ${socket.id} authenticated`);\n      next();\n    } catch (error) {\n      logger.error(`[AUTH] Authentication failed:`, error);\n      next(new Error('Authentication failed'));\n    }\n  };\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Rate Limiting Middleware\">\n```typescript\ninterface RateLimitStore {\n  [socketId: string]: {\n    count: number;\n    resetTime: number;\n    violations: number;\n  };\n}\n\nexport function rateLimitMiddleware(options: RateLimitOptions = {}) {\n  const store: RateLimitStore = {};\n  const limit = options.maxRequests || 30;\n  const window = options.windowMs || 60000; // 1 minute\n  \n  return async (socket: Socket, next: (err?: ExtendedError) => void) => {\n    const now = Date.now();\n    const key = socket.id;\n    \n    if (!store[key]) {\n      store[key] = {\n        count: 0,\n        resetTime: now + window,\n        violations: 0\n      };\n    }\n    \n    const record = store[key];\n    \n    if (now > record.resetTime) {\n      record.count = 0;\n      record.resetTime = now + window;\n    }\n    \n    record.count++;\n    \n    if (record.count > limit) {\n      record.violations++;\n      logger.warn(`[RATE_LIMIT] Socket ${socket.id} exceeded limit`);\n      \n      return next(new Error('Rate limit exceeded'));\n    }\n    \n    next();\n  };\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Validation Middleware\">\n```typescript\nexport function validationMiddleware() {\n  return async (socket: Socket, next: (err?: ExtendedError) => void) => {\n    // Validate socket data\n    if (!socket.data.sessionId) {\n      return next(new Error('Invalid session'));\n    }\n    \n    // Validate origin\n    const origin = socket.handshake.headers.origin;\n    const allowedOrigins = getAllowedOrigins();\n    \n    if (process.env.NODE_ENV === 'production' && \n        !allowedOrigins.includes(origin)) {\n      logger.warn(`[VALIDATION] Invalid origin: ${origin}`);\n      return next(new Error('Invalid origin'));\n    }\n    \n    // Validate user agent (basic bot detection)\n    const userAgent = socket.handshake.headers['user-agent'];\n    if (isSuspiciousUserAgent(userAgent)) {\n      logger.warn(`[VALIDATION] Suspicious user agent: ${userAgent}`);\n      return next(new Error('Invalid client'));\n    }\n    \n    next();\n  };\n}\n\nfunction isSuspiciousUserAgent(userAgent?: string): boolean {\nif (!userAgent) return true;\n\nconst suspiciousPatterns = [\n/bot/i,\n/crawler/i,\n/spider/i,\n/scraper/i\n];\n\nreturn suspiciousPatterns.some(pattern => pattern.test(userAgent));\n}\n\n````\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ“¡ Event System\n\n### Core Events\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ”— Connection Events\" icon=\"rocket\">\n    **connection**, **disconnect**, **connect_error**\n\n    ```typescript\n    io.on('connection', (socket) => {\n      logger.info(`Client connected: ${socket.id}`);\n    });\n\n    socket.on('disconnect', (reason) => {\n      logger.info(`Client disconnected: ${reason}`);\n    });\n    ```\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ’¬ Message Events\" icon=\"approve-check\">\n    **send-message**, **message-received**, **typing**\n\n    ```typescript\n    socket.on('send-message', async (data) => {\n      const response = await processMessage(data);\n      io.to(data.roomId).emit('message-received', response);\n    });\n    ```\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ  Room Events\" icon=\"setting\">\n    **join-room**, **leave-room**, **user-joined**, **user-left**\n\n    ```typescript\n    socket.on('join-room', async ({ roomId, userId }) => {\n      await socket.join(roomId);\n      socket.broadcast.to(roomId).emit('user-joined', userId);\n    });\n    ```\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ“Š State Events\" icon=\"chart\">\n    **request-world-state**, **world-state**, **server-stats**\n\n    ```typescript\n    socket.on('request-world-state', () => {\n      socket.emit('world-state', getCurrentState());\n    });\n    ```\n  \u003C/Card>\n\u003C/CardGrid>\n\n### Custom Event Emitters\n\n\u003CTabs>\n  \u003CTabItem label=\"Message Processing Events\">\n```typescript\nexport class MessageEventEmitter extends EventEmitter {\n  constructor(private io: Server) {\n    super();\n    this.setupEventListeners();\n  }\n\n  private setupEventListeners(): void {\n    this.on('message-processed', (data) => {\n      this.io.to(data.roomId).emit('message-received', {\n        id: data.id,\n        content: data.content,\n        author: data.author,\n        timestamp: data.timestamp,\n        classification: data.classification\n      });\n    });\n\n    this.on('ai-thinking', (data) => {\n      this.io.to(data.roomId).emit('typing-indicator', {\n        userId: 'nubi',\n        isTyping: true\n      });\n    });\n\n    this.on('ai-response-ready', (data) => {\n      this.io.to(data.roomId).emit('typing-indicator', {\n        userId: 'nubi',\n        isTyping: false\n      });\n    });\n  }\n}\n````\n\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"System Events\">\n```typescript\nexport class SystemEventEmitter extends EventEmitter {\n  constructor(private io: Server) {\n    super();\n    this.setupSystemEvents();\n  }\n  \n  private setupSystemEvents(): void {\n    // Server health events\n    this.on('server-overload', (data) => {\n      this.io.emit('server-status', {\n        status: 'overloaded',\n        message: 'Server experiencing high load',\n        timestamp: new Date()\n      });\n    });\n    \n    // Emergency events\n    this.on('emergency-broadcast', (data) => {\n      this.io.emit('emergency', {\n        type: data.type,\n        message: data.message,\n        action: data.action,\n        timestamp: new Date()\n      });\n    });\n    \n    // Maintenance events\n    this.on('maintenance-mode', (enabled: boolean) => {\n      this.io.emit('maintenance', {\n        enabled,\n        message: enabled ? \n          'Server entering maintenance mode' : \n          'Server maintenance completed',\n        timestamp: new Date()\n      });\n    });\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸš€ Performance Optimization\n\n\u003CAside type=\"tip\">\n  **Performance Tip**: NUBI's Socket.IO server can handle **10,000+ concurrent\n  connections** with proper configuration and clustering.\n\u003C/Aside>\n\n### Connection Pooling\n\n```typescript\nexport class SocketConnectionPool {\n  private connections = new Map\u003Cstring, SocketConnection>();\n  private readonly maxConnections: number;\n\n  constructor(maxConnections = 10000) {\n    this.maxConnections = maxConnections;\n    this.startCleanupTimer();\n  }\n\n  addConnection(socket: Socket): boolean {\n    if (this.connections.size >= this.maxConnections) {\n      logger.warn(\"Max connections reached, rejecting new connection\");\n      return false;\n    }\n\n    this.connections.set(socket.id, {\n      socket,\n      connectedAt: Date.now(),\n      lastActivity: Date.now(),\n    });\n\n    return true;\n  }\n\n  private startCleanupTimer(): void {\n    setInterval(\n      () => {\n        const now = Date.now();\n        const timeout = 30 * 60 * 1000; // 30 minutes\n\n        for (const [id, connection] of this.connections) {\n          if (now - connection.lastActivity > timeout) {\n            connection.socket.disconnect(true);\n            this.connections.delete(id);\n          }\n        }\n      },\n      5 * 60 * 1000,\n    ); // Check every 5 minutes\n  }\n}\n```\n\n### Message Broadcasting Optimization\n\n```typescript\nexport class BroadcastManager {\n  private messageQueues = new Map\u003Cstring, MessageQueue>();\n\n  async broadcastToRoom(\n    roomId: string,\n    event: string,\n    data: any,\n  ): Promise\u003Cvoid> {\n    const queue = this.getOrCreateQueue(roomId);\n\n    // Batch messages for efficiency\n    queue.add({\n      event,\n      data,\n      timestamp: Date.now(),\n    });\n\n    // Process queue if not already processing\n    if (!queue.processing) {\n      await this.processQueue(roomId);\n    }\n  }\n\n  private async processQueue(roomId: string): Promise\u003Cvoid> {\n    const queue = this.messageQueues.get(roomId);\n    if (!queue || queue.processing) return;\n\n    queue.processing = true;\n\n    try {\n      while (queue.messages.length > 0) {\n        const batch = queue.messages.splice(0, 10); // Process 10 at a time\n\n        for (const message of batch) {\n          this.io.to(roomId).emit(message.event, message.data);\n        }\n\n        // Small delay to prevent overwhelming clients\n        await new Promise((resolve) => setTimeout(resolve, 10));\n      }\n    } finally {\n      queue.processing = false;\n    }\n  }\n}\n```\n\n---\n\n\u003Cdiv class=\"nubi-note\">\n  \u003Cstrong>ðŸ”— Ready for real-time communication?\u003C/strong> Your Socket.IO server\n  is now configured with enterprise-grade features. Next, explore{\" \"}\n  \u003Ca href=\"/ux-integration/processing/\">Two-Layer Processing\u003C/a> to understand\n  how messages flow through NUBI's security and classification pipeline.\n\u003C/div>\n\n## Next Steps\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ›¡ï¸ Two-Layer Processing\" icon=\"approve-check\">\n    Learn about NUBI's advanced security and classification system. [Deep Dive\n    â†’](/ux-integration/processing/)\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ§  Message Classification\" icon=\"puzzle\">\n    Understand how messages are routed to AI personas. [Explore\n    â†’](/ux-integration/classification/)\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ“Š Real-time Analytics\" icon=\"chart\">\n    Monitor Socket.IO performance and user engagement. [Monitor\n    â†’](/observability/realtime/)\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ”§ Troubleshooting\" icon=\"warning\">\n    Common Socket.IO issues and solutions. [Debug â†’](/troubleshooting/socketio/)\n  \u003C/Card>\n\u003C/CardGrid>","src/content/docs/ux-integration/socketio.mdx","2ee033c2695c37df","ux-integration/socketio.mdx","ux-integration/processing",{"id":102,"data":104,"body":110,"filePath":111,"digest":112,"legacyId":113,"deferredRender":16},{"title":105,"description":106,"editUrl":16,"head":107,"template":18,"sidebar":108,"pagefind":16,"draft":20},"Two-Layer Processing Pipeline","Deep dive into NUBI's advanced security and classification processing system that ensures both safety and intelligence in every interaction.",[],{"hidden":20,"attrs":109},{},"import {\n  Card,\n  CardGrid,\n  Aside,\n  Code,\n  Tabs,\n  TabItem,\n} from \"@astrojs/starlight/components\";\n\n# Two-Layer Processing Pipeline\n\nNUBI's **Two-Layer Processing Pipeline** represents a breakthrough in AI communication security, providing comprehensive protection while maintaining intelligent message routing to appropriate AI personas.\n\n## ðŸ—ï¸ Pipeline Architecture\n\n\u003Cdiv class=\"interactive-demo\">\n  \u003Ch3>âš¡ Processing Flow\u003C/h3>\n  \u003Cdiv style=\"background: linear-gradient(135deg, var(--nubi-shadow-black) 0%, var(--nubi-jackal-gold) 100%); padding: 2rem; border-radius: 12px; color: white; margin: 2rem 0;\">\n    \u003Cdiv style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; text-align: center;\">\n      \u003Cdiv style=\"padding: 1rem; background: rgba(255,255,255,0.1); border-radius: 8px;\">\n        \u003Cstrong>ðŸ“¨ Input\u003C/strong>\n        \u003Cbr />\n        \u003Csmall>Raw message from client\u003C/small>\n      \u003C/div>\n      \u003Cdiv style=\"padding: 1rem; background: rgba(255,0,0,0.3); border-radius: 8px;\">\n        \u003Cstrong>ðŸ›¡ï¸ Layer 1\u003C/strong>\n        \u003Cbr />\n        \u003Csmall>Security Processing\u003C/small>\n      \u003C/div>\n      \u003Cdiv style=\"padding: 1rem; background: rgba(0,255,0,0.3); border-radius: 8px;\">\n        \u003Cstrong>ðŸ§  Layer 2\u003C/strong>\n        \u003Cbr />\n        \u003Csmall>Message Classification\u003C/small>\n      \u003C/div>\n      \u003Cdiv style=\"padding: 1rem; background: rgba(0,0,255,0.3); border-radius: 8px;\">\n        \u003Cstrong>ðŸš€ Output\u003C/strong>\n        \u003Cbr />\n        \u003Csmall>Routed to AI Persona\u003C/small>\n      \u003C/div>\n    \u003C/div>\n  \u003C/div>\n\u003C/div>\n\n## ðŸ›¡ï¸ Layer 1: Security Processing\n\nThe first layer focuses on **safety and security**, implementing multiple protection mechanisms before any content reaches the AI system.\n\n### ðŸš¦ Rate Limiting Engine\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ“Š Adaptive Rate Limiting\" icon=\"chart\">\n    **Dynamic thresholds** based on user behavior and system load\n    \n    ```typescript\n    interface RateLimitConfig {\n      messagesPerMinute: number;     // Base limit: 5\n      burstAllowance: number;        // Burst: 3 extra\n      adaptiveMultiplier: number;    // Load-based: 0.5-2.0\n      violationPenalty: number;      // Backoff: 2x per violation\n    }\n    ```\n  \u003C/Card>\n  \n  \u003CCard title=\"ðŸ”„ Sliding Window\" icon=\"setting\">\n    **Precise tracking** with sliding time windows for accurate enforcement\n    \n    ```typescript\n    class SlidingWindowRateLimit {\n      private windows = new Map\u003Cstring, number[]>();\n      private readonly windowSize = 60000; // 1 minute\n      \n      isAllowed(userId: string): boolean {\n        const now = Date.now();\n        const window = this.getWindow(userId);\n        \n        // Remove old timestamps\n        while (window.length > 0 && window[0] \u003C now - this.windowSize) {\n          window.shift();\n        }\n        \n        return window.length \u003C this.getLimit(userId);\n      }\n    }\n    ```\n  \u003C/Card>\n  \n  \u003CCard title=\"ðŸš¨ Violation Tracking\" icon=\"warning\">\n    **Progressive penalties** for repeat offenders with exponential backoff\n    \n    ```typescript\n    interface UserViolationRecord {\n      count: number;\n      lastViolation: number;\n      blockedUntil?: number;\n      penaltyMultiplier: number;     // Starts at 1, doubles each violation\n    }\n    ```\n  \u003C/Card>\n  \n  \u003CCard title=\"ðŸ’¡ Smart Recovery\" icon=\"approve-check\">\n    **Automatic rehabilitation** system reduces penalties over time\n    \n    ```typescript\n    // Penalty reduction over time\n    const rehabilitationPeriod = 24 * 60 * 60 * 1000; // 24 hours\n    if (now - record.lastViolation > rehabilitationPeriod) {\n      record.penaltyMultiplier = Math.max(1, record.penaltyMultiplier * 0.5);\n    }\n    ```\n  \u003C/Card>\n\u003C/CardGrid>\n\n### ðŸ” Content Filtering System\n\n\u003CTabs>\n  \u003CTabItem label=\"Pattern Detection\">\n```typescript\nexport class ContentFilter {\n  private patterns = {\n    // Spam detection\n    spam: [\n      /\\b(free money|click here|limited time|act now)\\b/gi,\n      /\\b(winner|congratulations|claim now|urgent)\\b/gi,\n      /[!]{3,}|[?]{3,}|[A-Z]{5,}/g  // Excessive punctuation/caps\n    ],\n    \n    // Scam protection\n    scam: [\n      /\\b(send crypto|private key|seed phrase|wallet address)\\b/gi,\n      /\\b(double your|guaranteed profit|risk free)\\b/gi,\n      /\\b(telegram admin|official support)\\b/gi\n    ],\n    \n    // Malicious content\n    malicious: [\n      /\u003Cscript|javascript:|data:|vbscript:/gi,\n      /on\\w+\\s*=/gi,  // Event handlers\n      /\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}/gi  // Encoded content\n    ],\n    \n    // Phishing attempts\n    phishing: [\n      /\\b(verify account|suspended|click to activate)\\b/gi,\n      /bit\\.ly|tinyurl|t\\.co/gi,  // Shortened URLs\n      /[^\\w@]metamask|phantom|solflare[^\\w]/gi  // Wallet impersonation\n    ]\n  };\n  \n  async analyze(content: string): Promise\u003CFilterResult> {\n    const results = {\n      isAllowed: true,\n      triggeredRules: [] as string[],\n      riskScore: 0,\n      explanation: \"\"\n    };\n    \n    for (const [category, patterns] of Object.entries(this.patterns)) {\n      for (const pattern of patterns) {\n        if (pattern.test(content)) {\n          results.triggeredRules.push(`${category}:${pattern.source}`);\n          results.riskScore += this.getRiskWeight(category);\n        }\n      }\n    }\n    \n    // Block if risk score exceeds threshold\n    results.isAllowed = results.riskScore \u003C 0.7;\n    \n    return results;\n  }\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"ML-Enhanced Detection\">\n```typescript\nimport { pipeline } from '@huggingface/transformers';\n\nexport class MLContentFilter {\n  private classifier: any;\n  private toxicityThreshold = 0.8;\n  \n  async initialize(): Promise\u003Cvoid> {\n    // Load pre-trained toxicity detection model\n    this.classifier = await pipeline(\n      'text-classification',\n      'unitary/toxic-bert'\n    );\n  }\n  \n  async analyzeToxicity(text: string): Promise\u003CToxicityResult> {\n    const result = await this.classifier(text);\n    \n    return {\n      isToxic: result[0].score > this.toxicityThreshold,\n      confidence: result[0].score,\n      categories: result.map(r => ({\n        label: r.label,\n        score: r.score\n      }))\n    };\n  }\n  \n  async analyzeSpam(text: string): Promise\u003CSpamResult> {\n    // Custom spam detection based on patterns\n    const features = this.extractSpamFeatures(text);\n    const spamProbability = this.calculateSpamScore(features);\n    \n    return {\n      isSpam: spamProbability > 0.75,\n      probability: spamProbability,\n      features\n    };\n  }\n  \n  private extractSpamFeatures(text: string) {\n    return {\n      excessiveCaps: (text.match(/[A-Z]/g)?.length || 0) / text.length,\n      excessivePunctuation: (text.match(/[!?]{2,}/g)?.length || 0),\n      urlCount: (text.match(/https?:\\/\\/[^\\s]+/g)?.length || 0),\n      repeatedWords: this.getRepeatedWordCount(text),\n      urgencyWords: (text.match(/\\b(urgent|asap|now|immediately)\\b/gi)?.length || 0)\n    };\n  }\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Real-time Protection\">\n```typescript\nexport class RealtimeProtection {\n  private suspiciousSources = new Set\u003Cstring>();\n  private ipReputation = new Map\u003Cstring, number>();\n  \n  async checkConnection(socket: Socket): Promise\u003CSecurityCheck> {\n    const clientIP = this.extractClientIP(socket);\n    const userAgent = socket.handshake.headers['user-agent'];\n    const origin = socket.handshake.headers.origin;\n    \n    const checks = await Promise.all([\n      this.checkIPReputation(clientIP),\n      this.checkUserAgent(userAgent),\n      this.checkOrigin(origin),\n      this.checkConnectionPattern(socket.id, clientIP)\n    ]);\n    \n    return {\n      allowed: checks.every(check => check.passed),\n      riskScore: checks.reduce((sum, check) => sum + check.risk, 0),\n      warnings: checks.filter(check => !check.passed).map(check => check.reason)\n    };\n  }\n  \n  private async checkIPReputation(ip: string): Promise\u003CCheckResult> {\n    // Check against known malicious IP databases\n    const reputation = this.ipReputation.get(ip) || 0;\n    \n    if (reputation \u003C -50) {\n      return { passed: false, risk: 0.9, reason: 'Known malicious IP' };\n    }\n    \n    if (reputation \u003C -10) {\n      return { passed: true, risk: 0.3, reason: 'Suspicious IP reputation' };\n    }\n    \n    return { passed: true, risk: 0, reason: 'Clean IP reputation' };\n  }\n  \n  private async checkConnectionPattern(socketId: string, ip: string): Promise\u003CCheckResult> {\n    // Detect rapid connection attempts from same IP\n    const recentConnections = this.getRecentConnections(ip);\n    \n    if (recentConnections.length > 10) {\n      return { passed: false, risk: 0.8, reason: 'Too many connections' };\n    }\n    \n    return { passed: true, risk: 0, reason: 'Normal connection pattern' };\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n### ðŸ›¡ï¸ XSS Prevention\n\n\u003Cdiv class=\"interactive-demo\">\n  \u003Ch3>ðŸš« XSS Attack Prevention\u003C/h3>\n  \u003Cdiv style=\"background: var(--nubi-shadow-black); color: var(--nubi-jackal-gold); padding: 2rem; border-radius: 8px; font-family: monospace;\">\n    \u003Cdiv>\n      âŒ \u003Cstrong>Blocked:\u003C/strong> &lt;script&gt;alert('xss')&lt;/script&gt;\n    \u003C/div>\n    \u003Cdiv>\n      âŒ \u003Cstrong>Blocked:\u003C/strong> javascript:void(0)\n    \u003C/div>\n    \u003Cdiv>\n      âŒ \u003Cstrong>Blocked:\u003C/strong> onload=\"malicious()\"\n    \u003C/div>\n    \u003Cdiv>\n      âœ… \u003Cstrong>Allowed:\u003C/strong> Hey NUBI, what's the SOL price?\n    \u003C/div>\n  \u003C/div>\n\u003C/div>\n\n```typescript\nexport class XSSPrevention {\n  private dangerousPatterns = [\n    /\u003Cscript[^>]*>.*?\u003C\\/script>/gi,\n    /javascript:/gi,\n    /data:text\\/html/gi,\n    /vbscript:/gi,\n    /on\\w+\\s*=/gi,\n    /expression\\s*\\(/gi,\n    /\u003Ciframe|\u003Cobject|\u003Cembed|\u003Clink/gi,\n  ];\n\n  sanitize(input: string): string {\n    let sanitized = input;\n\n    // Remove dangerous HTML tags and attributes\n    sanitized = sanitized.replace(/\u003C[^>]*>/gi, \"\");\n\n    // Encode special characters\n    sanitized = sanitized\n      .replace(/&/g, \"&amp;\")\n      .replace(/\u003C/g, \"&lt;\")\n      .replace(/>/g, \"&gt;\")\n      .replace(/\"/g, \"&quot;\")\n      .replace(/'/g, \"&#x27;\");\n\n    // Remove JavaScript protocols\n    sanitized = sanitized.replace(/javascript:/gi, \"\");\n\n    return sanitized;\n  }\n\n  validate(input: string): ValidationResult {\n    for (const pattern of this.dangerousPatterns) {\n      if (pattern.test(input)) {\n        return {\n          isValid: false,\n          reason: `Dangerous pattern detected: ${pattern.source}`,\n          sanitized: this.sanitize(input),\n        };\n      }\n    }\n\n    return { isValid: true, reason: \"Content is safe\" };\n  }\n}\n```\n\n## ðŸ§  Layer 2: Message Classification\n\nThe second layer implements **intelligent message classification** to route messages to the appropriate AI persona with maximum accuracy.\n\n### ðŸŽ¯ Classification Engine\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ“ Text Analysis\" icon=\"document\">\n    **Natural Language Processing** for intent detection and context extraction\n    \n    ```typescript\n    interface TextAnalysis {\n      sentiment: 'positive' | 'negative' | 'neutral';\n      urgency: 'low' | 'medium' | 'high';\n      entities: Entity[];\n      topics: Topic[];\n      complexity: number;  // 0-1 scale\n    }\n    ```\n  \u003C/Card>\n  \n  \u003CCard title=\"ðŸ” Pattern Matching\" icon=\"approve-check\">\n    **Advanced regex patterns** for rapid classification of common message types\n    \n    ```typescript\n    const classificationPatterns = {\n      raid: /\\b(raid|engage|attack|target|campaign)\\b/gi,\n      crypto: /\\b(price|token|SOL|BTC|ETH|bull|bear)\\b/gi,\n      support: /\\b(help|problem|issue|error|bug)\\b/gi,\n      social: /\\b(hello|hey|hi|thanks|please)\\b/gi\n    };\n    ```\n  \u003C/Card>\n  \n  \u003CCard title=\"ðŸ¤– ML Classification\" icon=\"puzzle\">\n    **Machine Learning models** for nuanced intent detection and confidence scoring\n    \n    ```typescript\n    class MLClassifier {\n      private model: any;\n      \n      async classify(text: string): Promise\u003CClassification> {\n        const features = this.extractFeatures(text);\n        const prediction = await this.model.predict(features);\n        \n        return {\n          intent: prediction.class,\n          confidence: prediction.probability,\n          alternatives: prediction.alternatives\n        };\n      }\n    }\n    ```\n  \u003C/Card>\n  \n  \u003CCard title=\"ðŸ“Š Confidence Scoring\" icon=\"chart\">\n    **Multi-factor confidence calculation** combining pattern matching and ML predictions\n    \n    ```typescript\n    calculateConfidence(\n      patternMatch: number,\n      mlConfidence: number,\n      contextScore: number\n    ): number {\n      return (patternMatch * 0.4 + mlConfidence * 0.4 + contextScore * 0.2);\n    }\n    ```\n  \u003C/Card>\n\u003C/CardGrid>\n\n### ðŸŽ­ Persona Routing System\n\n\u003CTabs>\n  \u003CTabItem label=\"Routing Logic\">\n```typescript\nexport class PersonaRouter {\n  private readonly routingRules = [\n    {\n      persona: 'emergency-handler',\n      priority: 1,\n      patterns: [\n        /\\b(hack|scam|emergency|help|alert|urgent)\\b/gi,\n        /\\b(lost funds|stolen|phishing|suspicious)\\b/gi\n      ],\n      minConfidence: 0.8\n    },\n    {\n      persona: 'raid-coordinator',\n      priority: 2,\n      patterns: [\n        /\\b(raid|engage|attack|campaign|target)\\b/gi,\n        /https?:\\/\\/[^\\s]+/g,  // URLs often indicate raid content\n        /\\b(twitter|tweet|like|retweet|follow)\\b/gi\n      ],\n      minConfidence: 0.7\n    },\n    {\n      persona: 'crypto-analyst',\n      priority: 3,\n      patterns: [\n        /\\b(price|chart|analysis|bullish|bearish)\\b/gi,\n        /\\$[\\d,]+|\\b\\d+\\s*(SOL|BTC|ETH|USD)\\b/gi,\n        /\\b(buy|sell|hold|dip|moon|pump)\\b/gi\n      ],\n      minConfidence: 0.6\n    },\n    {\n      persona: 'meme-lord',\n      priority: 4,\n      patterns: [\n        /ðŸ˜‚|ðŸ¤£|ðŸ˜­|ðŸ’€|ðŸ”¥|ðŸš€/,  // Common meme emojis\n        /\\b(lol|lmao|based|cringe|cope|seethe)\\b/gi,\n        /\\b(chad|virgin|gigachad|wojak|pepe)\\b/gi\n      ],\n      minConfidence: 0.5\n    },\n    {\n      persona: 'support-agent',\n      priority: 5,\n      patterns: [\n        /\\b(help|support|problem|issue|error)\\b/gi,\n        /\\b(how to|what is|can you|unable to)\\b/gi,\n        /[?]{1,3}$/  // Questions\n      ],\n      minConfidence: 0.5\n    },\n    {\n      persona: 'personality-core',\n      priority: 6,\n      patterns: [\n        /\\b(wisdom|ancient|spirit|cosmic|universe)\\b/gi,\n        /\\b(philosophy|meaning|purpose|enlighten)\\b/gi,\n        /\\b(jackal|anubis|egyptian|afterlife)\\b/gi\n      ],\n      minConfidence: 0.4\n    }\n  ];\n  \n  async routeMessage(message: string, context: MessageContext): Promise\u003CPersonaSelection> {\n    const analysis = await this.analyzeMessage(message, context);\n    \n    // Sort rules by priority and check each one\n    const sortedRules = [...this.routingRules].sort((a, b) => a.priority - b.priority);\n    \n    for (const rule of sortedRules) {\n      const confidence = this.calculateRuleConfidence(message, rule, analysis);\n      \n      if (confidence >= rule.minConfidence) {\n        return {\n          persona: rule.persona,\n          confidence,\n          reasoning: `Matched ${rule.persona} patterns with ${(confidence * 100).toFixed(1)}% confidence`,\n          variables: analysis.extractedVariables\n        };\n      }\n    }\n    \n    // Default to community manager\n    return {\n      persona: 'community-manager',\n      confidence: 0.8,\n      reasoning: 'Default community manager for general conversation',\n      variables: analysis.extractedVariables\n    };\n  }\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Variable Extraction\">\n```typescript\nexport class VariableExtractor {\n  private extractors = {\n    mentions: /@(\\w+)/g,\n    cryptoTokens: /\\b(SOL|BTC|ETH|USDC|BONK|JUP|NUBI|USDT)\\b/gi,\n    amounts: /(\\$|USD|SOL|BTC|ETH)\\s*([\\d,]+(?:\\.\\d+)?)/gi,\n    urls: /https?:\\/\\/[^\\s]+/g,\n    emojis: /[\\u{1F600}-\\u{1F64F}]|[\\u{1F300}-\\u{1F5FF}]|[\\u{1F680}-\\u{1F6FF}]|[\\u{2600}-\\u{26FF}]|[\\u{2700}-\\u{27BF}]/gu,\n    tickers: /\\$[A-Z]{1,10}\\b/g,\n    hashtags: /#\\w+/g\n  };\n  \n  extractVariables(text: string): ExtractedVariables {\n    const variables: ExtractedVariables = {\n      mentions: [],\n      cryptoTokens: [],\n      amounts: [],\n      urls: [],\n      usernames: [],\n      keywords: [],\n      sentiment: 'neutral',\n      urgency: 'low',\n      context: '',\n      emojis: [],\n      tickers: [],\n      hashtags: []\n    };\n    \n    // Extract each type of variable\n    for (const [type, regex] of Object.entries(this.extractors)) {\n      const matches = Array.from(text.matchAll(regex));\n      variables[type] = matches.map(match => match[1] || match[0]);\n    }\n    \n    // Analyze sentiment\n    variables.sentiment = this.analyzeSentiment(text);\n    \n    // Determine urgency\n    variables.urgency = this.determineUrgency(text);\n    \n    // Extract key context phrases\n    variables.context = this.extractContext(text);\n    \n    return variables;\n  }\n  \n  private analyzeSentiment(text: string): 'positive' | 'negative' | 'neutral' {\n    const positiveWords = ['good', 'great', 'awesome', 'love', 'best', 'amazing', 'bullish', 'pump'];\n    const negativeWords = ['bad', 'terrible', 'hate', 'worst', 'awful', 'bearish', 'dump', 'crash'];\n    \n    const words = text.toLowerCase().split(/\\s+/);\n    \n    const positiveCount = words.filter(word => positiveWords.includes(word)).length;\n    const negativeCount = words.filter(word => negativeWords.includes(word)).length;\n    \n    if (positiveCount > negativeCount) return 'positive';\n    if (negativeCount > positiveCount) return 'negative';\n    return 'neutral';\n  }\n}\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Context Analysis\">\n```typescript\nexport class ContextAnalyzer {\n  private conversationHistory = new Map\u003Cstring, ConversationContext>();\n  \n  async analyzeContext(\n    message: string, \n    userId: string, \n    roomId: string\n  ): Promise\u003CContextAnalysis> {\n    const userHistory = this.conversationHistory.get(userId) || this.createEmptyContext();\n    const roomContext = await this.getRoomContext(roomId);\n    \n    return {\n      userPersonality: this.inferUserPersonality(userHistory),\n      conversationFlow: this.analyzeConversationFlow(userHistory),\n      topicContinuity: this.checkTopicContinuity(message, userHistory.recentMessages),\n      emotionalContext: this.getEmotionalContext(userHistory),\n      roomDynamics: this.analyzeRoomDynamics(roomContext),\n      timeContext: this.getTimeContext(),\n      platformContext: this.getPlatformContext(roomId)\n    };\n  }\n  \n  private inferUserPersonality(history: ConversationContext): UserPersonality {\n    const messages = history.recentMessages;\n    \n    return {\n      chattiness: this.calculateChattiness(messages),\n      technicalLevel: this.assessTechnicalLevel(messages),\n      humorAppreciation: this.detectHumorPatterns(messages),\n      cryptoInterest: this.measureCryptoInterest(messages),\n      engagementStyle: this.determineEngagementStyle(messages)\n    };\n  }\n  \n  private analyzeConversationFlow(history: ConversationContext): ConversationFlow {\n    const messages = history.recentMessages;\n    \n    return {\n      momentum: this.calculateMomentum(messages),\n      topicShifts: this.detectTopicShifts(messages),\n      questionToAnswerRatio: this.calculateQAR(messages),\n      responseLatency: this.getAverageResponseTime(messages),\n      engagementTrend: this.analyzeEngagementTrend(messages)\n    };\n  }\n  \n  private checkTopicContinuity(\n    currentMessage: string, \n    recentMessages: Message[]\n  ): TopicContinuity {\n    if (recentMessages.length === 0) {\n      return { isContinuation: false, topicShift: 'new_conversation' };\n    }\n    \n    const lastMessage = recentMessages[recentMessages.length - 1];\n    const similarity = this.calculateSemanticSimilarity(currentMessage, lastMessage.content);\n    \n    if (similarity > 0.7) {\n      return { isContinuation: true, topicShift: 'none' };\n    } else if (similarity > 0.3) {\n      return { isContinuation: true, topicShift: 'gradual' };\n    } else {\n      return { isContinuation: false, topicShift: 'abrupt' };\n    }\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## âš¡ Performance Optimization\n\n\u003Cdiv class=\"interactive-demo\">\n  \u003Ch3>ðŸš€ Pipeline Performance Metrics\u003C/h3>\n  \u003Cdiv style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin: 2rem 0;\">\n    \u003Cdiv style=\"padding: 1.5rem; background: linear-gradient(135deg, #4caf50, #45a049); color: white; border-radius: 8px;\">\n      \u003Ch4 style=\"margin: 0 0 0.5rem 0;\">ðŸƒâ€â™‚ï¸ Layer 1 Processing\u003C/h4>\n      \u003Cdiv style=\"font-size: 2rem; font-weight: bold;\">~12ms\u003C/div>\n      \u003Csmall>Security checks average\u003C/small>\n    \u003C/div>\n    \u003Cdiv style=\"padding: 1.5rem; background: linear-gradient(135deg, #2196f3, #1976d2); color: white; border-radius: 8px;\">\n      \u003Ch4 style=\"margin: 0 0 0.5rem 0;\">ðŸ§  Layer 2 Processing\u003C/h4>\n      \u003Cdiv style=\"font-size: 2rem; font-weight: bold;\">~28ms\u003C/div>\n      \u003Csmall>Classification average\u003C/small>\n    \u003C/div>\n    \u003Cdiv style=\"padding: 1.5rem; background: linear-gradient(135deg, #ff9800, #f57c00); color: white; border-radius: 8px;\">\n      \u003Ch4 style=\"margin: 0 0 0.5rem 0;\">ðŸŽ¯ Total Pipeline\u003C/h4>\n      \u003Cdiv style=\"font-size: 2rem; font-weight: bold;\">~40ms\u003C/div>\n      \u003Csmall>End-to-end processing\u003C/small>\n    \u003C/div>\n    \u003Cdiv style=\"padding: 1.5rem; background: linear-gradient(135deg, #9c27b0, #7b1fa2); color: white; border-radius: 8px;\">\n      \u003Ch4 style=\"margin: 0 0 0.5rem 0;\">âœ… Accuracy Rate\u003C/h4>\n      \u003Cdiv style=\"font-size: 2rem; font-weight: bold;\">97.3%\u003C/div>\n      \u003Csmall>Classification accuracy\u003C/small>\n    \u003C/div>\n  \u003C/div>\n\u003C/div>\n\n### Async Processing Pipeline\n\n```typescript\nexport class AsyncProcessingPipeline {\n  async processMessage(\n    message: string,\n    socket: Socket,\n    traceId: string,\n  ): Promise\u003CProcessingResult> {\n    const startTime = performance.now();\n\n    try {\n      // Execute both layers in parallel where possible\n      const [securityResult, contextData] = await Promise.all([\n        this.executeLayer1(message, socket, traceId),\n        this.gatherContextData(socket.data.userId, socket.data.roomId),\n      ]);\n\n      if (!securityResult.allowed) {\n        return {\n          allowed: false,\n          reason: securityResult.reason,\n          processingTime: performance.now() - startTime,\n        };\n      }\n\n      // Execute Layer 2 with context\n      const classification = await this.executeLayer2(\n        message,\n        contextData,\n        traceId,\n      );\n\n      const processingTime = performance.now() - startTime;\n\n      // Log performance metrics\n      await this.logPerformanceMetrics({\n        traceId,\n        layer1Time: securityResult.processingTime,\n        layer2Time: classification.processingTime,\n        totalTime: processingTime,\n        classification: classification.selectedPrompt,\n      });\n\n      return {\n        allowed: true,\n        classification,\n        processingTime,\n        traceId,\n      };\n    } catch (error) {\n      logger.error(`[PIPELINE] Processing failed for ${traceId}:`, error);\n\n      return {\n        allowed: false,\n        reason: \"Processing error occurred\",\n        processingTime: performance.now() - startTime,\n      };\n    }\n  }\n\n  private async executeLayer1(\n    message: string,\n    socket: Socket,\n    traceId: string,\n  ): Promise\u003CSecurityResult> {\n    const startTime = performance.now();\n\n    // Parallel security checks\n    const [rateLimitCheck, contentCheck, xssCheck, connectionCheck] =\n      await Promise.all([\n        this.rateLimiter.check(socket.id),\n        this.contentFilter.analyze(message),\n        this.xssPrevention.validate(message),\n        this.realtimeProtection.checkConnection(socket),\n      ]);\n\n    const processingTime = performance.now() - startTime;\n\n    return {\n      allowed:\n        rateLimitCheck.allowed &&\n        contentCheck.isAllowed &&\n        xssCheck.isValid &&\n        connectionCheck.allowed,\n      reason: this.combineFailureReasons([\n        rateLimitCheck,\n        contentCheck,\n        xssCheck,\n        connectionCheck,\n      ]),\n      processingTime,\n      traceId,\n    };\n  }\n}\n```\n\n## ðŸ“Š Performance Monitoring\n\n\u003CCardGrid>\n  \u003CCard title=\"âš¡ Real-time Metrics\" icon=\"chart\">\n    **Live performance tracking** with sub-millisecond precision - Processing\n    time distribution - Layer 1/2 performance breakdown - Classification\n    accuracy rates - Error frequency analysis\n  \u003C/Card>\n\n\u003CCard title=\"ðŸŽ¯ Quality Metrics\" icon=\"approve-check\">\n  **Continuous quality assessment** with feedback loops - False\n  positive/negative rates - User satisfaction scores - Persona routing accuracy\n  - Security event detection rates\n\u003C/Card>\n\n\u003CCard title=\"ðŸ”„ Auto-optimization\" icon=\"setting\">\n  **Self-improving algorithms** that adapt to usage patterns - Dynamic threshold\n  adjustment - Pattern learning and updates - Performance regression detection -\n  Automatic model retraining\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ“ˆ Analytics Dashboard\" icon=\"puzzle\">\n    **Comprehensive monitoring** with real-time dashboards - Processing pipeline\n    visualization - Security threat tracking - Classification confidence trends\n    - System health indicators\n  \u003C/Card>\n\u003C/CardGrid>\n\n\u003CAside type=\"tip\">\n  **Pro Tip**: The Two-Layer Processing Pipeline automatically scales processing\n  power based on load, maintaining sub-50ms response times even during peak\n  traffic.\n\u003C/Aside>\n\n---\n\n\u003Cdiv class=\"nubi-note\">\n  \u003Cstrong>ðŸ”’ Security-First Design:\u003C/strong> Every message is processed through\n  both layers regardless of content, ensuring consistent protection and\n  intelligent routing. Learn more about{\" \"}\n  \u003Ca href=\"/ux-integration/classification/\">Message Classification\u003C/a> or\n  explore \u003Ca href=\"/security/threat-detection/\">Advanced Threat Detection\u003C/a>.\n\u003C/div>\n\n## Next Steps\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ§  Message Classification\" icon=\"puzzle\">\n    Deep dive into AI persona routing and intent detection systems. [Learn More\n    â†’](/ux-integration/classification/)\n  \u003C/Card>\n\n\u003CCard title=\"ðŸ›¡ï¸ Security Features\" icon=\"warning\">\n  Explore advanced security mechanisms and threat protection. [Secure\n  â†’](/security/overview/)\n\u003C/Card>\n\n\u003CCard title=\"ðŸ“Š Analytics\" icon=\"chart\">\n  Monitor pipeline performance and classification accuracy. [Analyze\n  â†’](/observability/pipeline/)\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ”§ Configuration\" icon=\"setting\">\n    Customize processing rules and security thresholds. [Configure\n    â†’](/deployment/security-config/)\n  \u003C/Card>\n\u003C/CardGrid>","src/content/docs/ux-integration/processing.mdx","23529ac96dcca792","ux-integration/processing.mdx","ux-integration/overview",{"id":114,"data":116,"body":122,"filePath":123,"digest":124,"legacyId":125,"deferredRender":16},{"title":117,"description":118,"editUrl":16,"head":119,"template":18,"sidebar":120,"pagefind":16,"draft":20},"UX Integration System Overview","Learn about NUBI's advanced real-time communication system with Socket.IO, two-layer processing, and intelligent message classification.",[],{"hidden":20,"attrs":121},{},"import {\n  Card,\n  CardGrid,\n  Aside,\n  Code,\n  Tabs,\n  TabItem,\n} from \"@astrojs/starlight/components\";\n\n# UX Integration System Overview\n\nNUBI's UX Integration System represents a breakthrough in real-time AI communication, featuring a sophisticated **two-layer processing pipeline** that ensures both security and intelligence in every interaction.\n\n## ðŸ”Œ System Architecture\n\nThe UX Integration System is built around **Socket.IO WebSockets** with a unique processing pipeline:\n\n```mermaid\ngraph TB\n    A[Client Connection] --> B[Socket.IO Server]\n    B --> C{Connection Valid?}\n    C -->|Yes| D[Session Manager]\n    C -->|No| E[Connection Rejected]\n    D --> F[Layer 1: Security Processing]\n    F --> G[Rate Limiting]\n    F --> H[Content Filtering]\n    F --> I[XSS Prevention]\n    G --> J[Layer 2: Classification]\n    H --> J\n    I --> J\n    J --> K[Message Router]\n    K --> L[Prompt Selection]\n    L --> M[ElizaOS Core]\n    M --> N[AI Response]\n    N --> O[Response Broadcast]\n```\n\n## ðŸ›¡ï¸ Layer 1: Security Processing\n\nThe first layer focuses on **security and safety**, implementing multiple protection mechanisms:\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸš¦ Rate Limiting\" icon=\"warning\">\n    **5 messages per minute** per user with exponential backoff for violations.\n    \n    ```typescript\n    const rateLimiter = {\n      messagesPerMinute: 5,\n      timeWindow: 60000, // 1 minute\n      backoffMultiplier: 2\n    };\n    ```\n  \u003C/Card>\n  \n  \u003CCard title=\"ðŸ” Content Filtering\" icon=\"approve-check\">\n    **Advanced pattern detection** for spam, scams, and malicious content.\n    \n    - Spam detection algorithms\n    - Scam URL filtering  \n    - Malicious payload prevention\n    - Custom blacklist management\n  \u003C/Card>\n  \n  \u003CCard title=\"ðŸ›¡ï¸ XSS Prevention\" icon=\"setting\">\n    **Input sanitization** and validation to prevent code injection attacks.\n    \n    - HTML tag stripping\n    - Script injection prevention\n    - SQL injection protection  \n    - Path traversal blocking\n  \u003C/Card>\n  \n  \u003CCard title=\"ðŸ‘¥ Session Management\" icon=\"user\">\n    **Persistent session tracking** across connections with automatic cleanup.\n    \n    - Session timeout (30 minutes)\n    - Cross-platform identity linking\n    - Connection state management\n  \u003C/Card>\n\u003C/CardGrid>\n\n### Security Configuration\n\n\u003CTabs>\n  \u003CTabItem label=\"Environment Variables\">\n```bash\n# Security layer controls\nSOCKET_PREPROCESSING_ENABLED=true\nSOCKET_CONTENT_FILTERING=true\nSOCKET_RATE_LIMITING=true\nSOCKET_SECURITY_CHECKS=true\n\n# Rate limiting configuration\n\nSOCKET_RATE_LIMIT_MESSAGES=5\nSOCKET_RATE_LIMIT_WINDOW=60000\n\n# Session configuration\n\nSOCKET_SESSION_TIMEOUT=1800000 # 30 minutes\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Security Patterns\">\n```typescript\n// Content filtering patterns\nconst securityPatterns = {\n  spam: /\\b(free money|click here|limited time)\\b/gi,\n  scam: /\\b(send crypto|private key|seed phrase)\\b/gi,\n  xss: /\u003Cscript|javascript:|on\\w+=/gi,\n  injection: /('|(\\\\|;|--|\\/\\*|\\*\\/)/gi\n};\n\n// Rate limiting implementation\ninterface UserStatus {\n  messageCount: number;\n  windowStart: number;\n  violations: number;\n  blockedUntil?: number;\n}\n````\n\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ§  Layer 2: Message Classification\n\nThe second layer implements **intelligent message classification** to route messages to appropriate AI personas:\n\n\u003Cdiv class=\"interactive-demo\">\n  \u003Ch3>ðŸŽ¯ 7 Specialized Prompt Types\u003C/h3>\n  \u003Cdiv style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem;\">\n    \u003Cdiv style=\"padding: 1rem; border: 2px solid var(--nubi-spirit-blue); border-radius: 8px;\">\n      \u003Cstrong>ðŸ¤ Community Manager\u003C/strong>\n      \u003Cp>\n        Default mode for general conversation, welcomes new users, builds\n        connections\n      \u003C/p>\n      \u003Ccode>Pattern: General conversation, introductions\u003C/code>\n    \u003C/div>\n    \u003Cdiv style=\"padding: 1rem; border: 2px solid var(--nubi-jackal-gold); border-radius: 8px;\">\n      \u003Cstrong>ðŸš€ Raid Coordinator\u003C/strong>\n      \u003Cp>\n        Organizes engagement campaigns with military precision but keeps it fun\n      \u003C/p>\n      \u003Ccode>Pattern: URLs, engagement keywords, \"raid\"\u003C/code>\n    \u003C/div>\n    \u003Cdiv style=\"padding: 1rem; border: 2px solid var(--nubi-ancient-bronze); border-radius: 8px;\">\n      \u003Cstrong>ðŸ“ˆ Crypto Analyst\u003C/strong>\n      \u003Cp>Market oracle with cosmic intuition for portfolio analysis\u003C/p>\n      \u003Ccode>Pattern: Price, tokens, \"analysis\", amounts\u003C/code>\n    \u003C/div>\n    \u003Cdiv style=\"padding: 1rem; border: 2px solid var(--nubi-mystic-purple); border-radius: 8px;\">\n      \u003Cstrong>ðŸ˜‚ Meme Lord\u003C/strong>\n      \u003Cp>Peak humor mode, roasts bad takes constructively\u003C/p>\n      \u003Ccode>Pattern: Emojis, \"lol\", \"based\", humor keywords\u003C/code>\n    \u003C/div>\n    \u003Cdiv style=\"padding: 1rem; border: 2px solid #4caf50; border-radius: 8px;\">\n      \u003Cstrong>ðŸ› ï¸ Support Agent\u003C/strong>\n      \u003Cp>Patient problem solver with deep technical knowledge\u003C/p>\n      \u003Ccode>Pattern: \"help\", \"support\", \"problem\", \"how to\"\u003C/code>\n    \u003C/div>\n    \u003Cdiv style=\"padding: 1rem; border: 2px solid #663399; border-radius: 8px;\">\n      \u003Cstrong>ðŸ”® Personality Core\u003C/strong>\n      \u003Cp>Ancient consciousness sharing profound cosmic insights\u003C/p>\n      \u003Ccode>Pattern: \"wisdom\", \"ancient\", \"spirit\", philosophy\u003C/code>\n    \u003C/div>\n    \u003Cdiv style=\"padding: 1rem; border: 2px solid #f44336; border-radius: 8px;\">\n      \u003Cstrong>ðŸš¨ Emergency Handler\u003C/strong>\n      \u003Cp>Protection mode when community is threatened\u003C/p>\n      \u003Ccode>Pattern: \"hack\", \"scam\", \"emergency\", threats\u003C/code>\n    \u003C/div>\n  \u003C/div>\n\u003C/div>\n\n### Classification Algorithm\n\n\u003CTabs>\n  \u003CTabItem label=\"Message Analysis\">\n```typescript\ninterface MessageClassification {\n  intent: string;\n  selectedPrompt: PromptType;\n  confidenceScore: number;\n  reasoning: string;\n  variables: ExtractedVariables;\n}\n\nclass MessageRouter {\nasync classifyMessage(\nmessage: string,\nuserId: string,\nplatform: string,\ntraceId: string\n): Promise\u003CMessageClassification> {\n// Extract variables (mentions, tokens, URLs, etc.)\nconst variables = this.extractVariables(message);\n\n    // Determine intent and routing\n    const { intent, selectedPrompt, confidenceScore, reasoning } =\n      this.determineIntent(message, variables);\n\n    // Log analytics\n    await pipelineAnalytics.logRoutingEvent({\n      traceId,\n      userId,\n      platform,\n      classifiedIntent: intent,\n      selectedPrompt,\n      confidenceScore\n    });\n\n    return { intent, selectedPrompt, confidenceScore, reasoning, variables };\n\n}\n}\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Variable Extraction\">\n```typescript\ninterface ExtractedVariables {\n  mentions: string[];      // @usernames\n  cryptoTokens: string[];  // SOL, BTC, ETH, etc.\n  amounts: string[];       // $100, 50 SOL, etc.\n  urls: string[];          // https:// links\n  usernames: string[];     // mentioned users\n  keywords: string[];      // classified keywords\n  sentiment: \"positive\" | \"negative\" | \"neutral\";\n  urgency: \"low\" | \"medium\" | \"high\";\n  context: string;         // key context phrases\n}\n\n// Extraction patterns\nconst patterns = {\n  mentions: /@(\\w+)/g,\n  cryptoTokens: /\\b(SOL|BTC|ETH|USDC|BONK|JUP|NUBI)\\b/gi,\n  amounts: /(\\$|USD|SOL|BTC|ETH)\\s*([\\d,]+(?:\\.\\d+)?)/gi,\n  urls: /https?:\\/\\/[^\\s]+/g\n};\n````\n\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Prompt Selection\">\n```typescript\n// Prompt selection logic with confidence scoring\nprivate determineIntent(message: string, variables: ExtractedVariables) {\n  const lowerMessage = message.toLowerCase();\n  \n  // Emergency handler (highest priority)\n  if (this.isEmergency(message)) {\n    return {\n      intent: \"emergency\",\n      selectedPrompt: \"emergency-handler\",\n      confidenceScore: 0.95,\n      reasoning: \"Emergency keywords detected\"\n    };\n  }\n  \n  // Raid coordinator\n  if (this.isRaidRelated(message, variables)) {\n    return {\n      intent: \"raid_coordination\", \n      selectedPrompt: \"raid-coordinator\",\n      confidenceScore: 0.9,\n      reasoning: \"Raid-related content detected\"\n    };\n  }\n  \n  // Continue with other classifications...\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ”„ Real-time Communication Flow\n\n\u003Cdiv class=\"interactive-demo\">\n  \u003Ch3>ðŸ“¡ Socket.IO Event System\u003C/h3>\n\n  \u003Cdiv style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;\">\n    \u003Cdiv>\n      \u003Cstrong>Client â†’ Server Events\u003C/strong>\n      \u003Cul style=\"font-family: monospace; font-size: 0.9rem;\">\n        \u003Cli>\n          \u003Ccode>connect\u003C/code> - Initial connection\n        \u003C/li>\n        \u003Cli>\n          \u003Ccode>join-room\u003C/code> - Enter chat room\n        \u003C/li>\n        \u003Cli>\n          \u003Ccode>send-message\u003C/code> - Send message\n        \u003C/li>\n        \u003Cli>\n          \u003Ccode>request-world-state\u003C/code> - Get current state\n        \u003C/li>\n        \u003Cli>\n          \u003Ccode>start-session\u003C/code> - Begin AI session\n        \u003C/li>\n        \u003Cli>\n          \u003Ccode>disconnect\u003C/code> - Close connection\n        \u003C/li>\n      \u003C/ul>\n    \u003C/div>\n    \u003Cdiv>\n      \u003Cstrong>Server â†’ Client Events\u003C/strong>\n      \u003Cul style=\"font-family: monospace; font-size: 0.9rem;\">\n        \u003Cli>\n          \u003Ccode>connection-ack\u003C/code> - Connection confirmed\n        \u003C/li>\n        \u003Cli>\n          \u003Ccode>message-received\u003C/code> - New message\n        \u003C/li>\n        \u003Cli>\n          \u003Ccode>user-joined\u003C/code> - User entered room\n        \u003C/li>\n        \u003Cli>\n          \u003Ccode>user-left\u003C/code> - User left room\n        \u003C/li>\n        \u003Cli>\n          \u003Ccode>world-state\u003C/code> - Current state data\n        \u003C/li>\n        \u003Cli>\n          \u003Ccode>error\u003C/code> - Error occurred\n        \u003C/li>\n      \u003C/ul>\n    \u003C/div>\n  \u003C/div>\n\u003C/div>\n\n### Connection Management\n\n```typescript\n// Socket.IO server setup with NUBI integration\nconst io = new Server(server, {\n  cors: {\n    origin: process.env.ALLOWED_ORIGINS?.split(\",\") || [\n      \"http://localhost:3000\",\n    ],\n    methods: [\"GET\", \"POST\"],\n  },\n  transports: [\"websocket\", \"polling\"],\n});\n\nio.on(\"connection\", async (socket) => {\n  logger.info(`Client connected: ${socket.id}`);\n\n  // Initialize session\n  const sessionId = crypto.randomUUID();\n  socket.data.sessionId = sessionId;\n\n  // Setup message handling with two-layer processing\n  socket.on(\"send-message\", async (data) => {\n    try {\n      // Layer 1: Security processing\n      const securityResult = await securityProcessor.process(data, socket);\n      if (!securityResult.allowed) {\n        socket.emit(\"error\", { message: securityResult.reason });\n        return;\n      }\n\n      // Layer 2: Message classification\n      const classification = await messageRouter.classifyMessage(\n        data.message,\n        socket.data.userId,\n        \"websocket\",\n        sessionId,\n      );\n\n      // Route to appropriate AI persona\n      const response = await nubiAgent.processMessage(\n        data.message,\n        classification,\n      );\n\n      // Broadcast response\n      io.to(data.roomId).emit(\"message-received\", {\n        ...response,\n        classification: classification.selectedPrompt,\n      });\n    } catch (error) {\n      logger.error(\"Message processing error:\", error);\n      socket.emit(\"error\", { message: \"Processing failed\" });\n    }\n  });\n});\n```\n\n## ðŸ“Š Analytics & Monitoring\n\nThe UX Integration System includes comprehensive analytics:\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ“ˆ Real-time Metrics\" icon=\"chart\">\n    - Connection count and duration - Message throughput and latency -\n    Classification accuracy rates - Security event frequencies\n  \u003C/Card>\n\n\u003CCard title=\"ðŸŽ¯ User Analytics\" icon=\"user\">\n  - User engagement patterns - Conversation flow analysis - Prompt type\n  preferences - Session duration tracking\n\u003C/Card>\n\n\u003CCard title=\"ðŸ” Performance Monitoring\" icon=\"setting\">\n  - Response time distribution - Database query performance - Memory usage\n  patterns - Error rate tracking\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ›¡ï¸ Security Events\" icon=\"warning\">\n    - Rate limiting violations - Content filter triggers - Suspicious activity\n    detection - Attack pattern analysis\n  \u003C/Card>\n\u003C/CardGrid>\n\n\u003CAside type=\"tip\">\n  **Analytics Integration**: All UX events are automatically logged to\n  ClickHouse for advanced analytics and can be viewed in real-time dashboards.\n\u003C/Aside>\n\n## ðŸš€ Getting Started\n\nReady to integrate with NUBI's UX system? Here's a quick client example:\n\n\u003CTabs>\n  \u003CTabItem label=\"JavaScript Client\">\n```javascript\nimport { io } from 'socket.io-client';\n\nconst socket = io('ws://localhost:3001', {\ntransports: ['websocket']\n});\n\nsocket.on('connect', () => {\nconsole.log('Connected to NUBI UX System');\n\n// Join a room\nsocket.emit('join-room', {\nroomId: 'general',\nuserId: 'user-123',\nusername: 'Alice'\n});\n});\n\nsocket.on('message-received', (data) => {\nconsole.log(`NUBI [${data.classification}]:`, data.message);\n});\n\n// Send a message (will be processed through both layers)\nsocket.emit('send-message', {\nroomId: 'general',\nmessage: 'Hello NUBI! How are the markets today?'\n});\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"React Hook\">\n```typescript\nimport { useEffect, useState } from 'react';\nimport { io, Socket } from 'socket.io-client';\n\nexport function useNubiSocket(serverPath: string) {\n  const [socket, setSocket] = useState\u003CSocket | null>(null);\n  const [connected, setConnected] = useState(false);\n  const [messages, setMessages] = useState\u003Cany[]>([]);\n\n  useEffect(() => {\n    const newSocket = io(serverPath);\n\n    newSocket.on('connect', () => {\n      setConnected(true);\n      setSocket(newSocket);\n    });\n\n    newSocket.on('message-received', (message) => {\n      setMessages(prev => [...prev, message]);\n    });\n\n    return () => newSocket.close();\n  }, [serverPath]);\n\n  const sendMessage = (roomId: string, message: string) => {\n    if (socket) {\n      socket.emit('send-message', { roomId, message });\n    }\n  };\n\n  return { socket, connected, messages, sendMessage };\n}\n````\n\n  \u003C/TabItem>\n\u003C/Tabs>\n\n---\n\n\u003Cdiv class=\"nubi-note\">\n  \u003Cstrong>ðŸ” Next Steps:\u003C/strong> Dive deeper into specific components: -{\" \"}\n  \u003Ca href=\"/ux-integration/socketio/\">Socket.IO Setup\u003C/a> - Detailed server\n  configuration - \u003Ca href=\"/ux-integration/processing/\">Two-Layer Processing\u003C/a>{\" \"}\n  - Security and classification details -{\" \"}\n  \u003Ca href=\"/ux-integration/classification/\">Message Classification\u003C/a> - AI\n  persona routing system\n\u003C/div>","src/content/docs/ux-integration/overview.mdx","6197ddd12cff20e4","ux-integration/overview.mdx","getting-started/quick-start",{"id":126,"data":128,"body":134,"filePath":135,"digest":136,"legacyId":137,"deferredRender":16},{"title":129,"description":130,"editUrl":16,"head":131,"template":18,"sidebar":132,"pagefind":16,"draft":20},"Quick Start Guide","Get NUBI up and running in under 5 minutes with our streamlined setup process.",[],{"hidden":20,"attrs":133},{},"import {\n  Card,\n  CardGrid,\n  Aside,\n  Code,\n  Tabs,\n  TabItem,\n} from \"@astrojs/starlight/components\";\n\n# Quick Start Guide\n\nGet **NUBI - The Symbiotic Essence of Anubis** running in under 5 minutes with this streamlined setup guide.\n\n## âš¡ Prerequisites\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸŸ¢ Node.js 18+\" icon=\"approve-check\">\n    **Required** for running ElizaOS and dependencies ```bash node --version #\n    Should be 18.0.0+ ```\n  \u003C/Card>\n\n\u003CCard title=\"ðŸš€ Bun (Recommended)\" icon=\"rocket\">\n  **Fast JavaScript runtime** with built-in package manager ```bash curl -fsSL\n  https://bun.sh/install | bash ```\n\u003C/Card>\n\n\u003CCard title=\"ðŸ—„ï¸ PostgreSQL\" icon=\"setting\">\n  **Database** for production (PGLite for development) - Development: Automatic\n  PGLite setup - Production: PostgreSQL 14+ required\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ”‘ API Keys\" icon=\"warning\">\n    **Platform integrations** (optional for basic setup) - OpenAI/Anthropic for\n    AI models - Telegram Bot Token - Twitter API credentials\n  \u003C/Card>\n\u003C/CardGrid>\n\n## ðŸš€ 5-Minute Setup\n\n### Step 1: Clone & Install\n\n\u003CTabs>\n  \u003CTabItem label=\"With Bun (Recommended)\">\n```bash\n# Clone the repository\ngit clone https://github.com/anubis-chat/nubi.git\ncd nubi\n\n# Install dependencies (fast!)\n\nbun install\n\n# Verify installation\n\nbun run type-check\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"With npm\">\n```bash\n# Clone the repository\ngit clone https://github.com/anubis-chat/nubi.git\ncd nubi\n\n# Install dependencies\nnpm install\n\n# Verify installation\nnpm run type-check\n````\n\n  \u003C/TabItem>\n\u003C/Tabs>\n\n### Step 2: Environment Setup\n\n\u003CTabs>\n  \u003CTabItem label=\"Quick Setup (Minimal)\">\n```bash\n# Copy example environment\ncp .env.example .env\n\n# Edit with your preferred editor\n\ncode .env # or nano .env, vim .env\n\n# Minimal required configuration:\n\nNODE_ENV=development\nOPENAI_API_KEY=your-openai-key-here\nPGLITE_DATA_DIR=./.eliza/.elizadb\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Full Setup (Recommended)\">\n```bash\n# Copy example environment\ncp .env.example .env\n\n# Essential configuration for full features:\nNODE_ENV=development\n\n# AI Model (choose one)\nOPENAI_API_KEY=sk-your-openai-key\n# OR\nANTHROPIC_API_KEY=sk-ant-your-key\n\n# Database (automatic in development)\nPGLITE_DATA_DIR=./.eliza/.elizadb\n\n# Telegram Bot (for raids)\nTELEGRAM_BOT_TOKEN=your-bot-token\n\n# Twitter Integration (optional)\nTWITTER_API_KEY=your-twitter-key\nTWITTER_API_SECRET=your-twitter-secret\n````\n\n  \u003C/TabItem>\n\u003C/Tabs>\n\n### Step 3: Launch NUBI\n\n\u003Cdiv style=\"background: linear-gradient(135deg, var(--nubi-shadow-black) 0%, var(--nubi-jackal-gold) 100%); padding: 2rem; border-radius: 12px; color: white; margin: 2rem 0;\">\n  \u003Ch4 style=\"margin: 0 0 1rem 0; color: var(--nubi-jackal-gold);\">ðŸº Starting the Ancient Spirit...\u003C/h4>\n  \n  \u003Cpre style=\"background: rgba(0,0,0,0.3); padding: 1rem; border-radius: 8px; margin: 0;\">\n\u003Ccode># Development mode with PGLite database\nbun run dev\n\n# Watch the magic happen...\n\nðŸº NUBI - The Symbiotic Essence of Anubis\nâš¡ ElizaOS v1.0.0 initialized\nðŸ—„ï¸ PGLite database ready at ./.eliza/.elizadb  \nðŸ§  Personality system loaded: Ancient Jackal Spirit\nðŸŽ¯ Two-layer processing pipeline active\nâœ… NUBI is ready for action!\u003C/code>\n\n  \u003C/pre>\n\u003C/div>\n\n## âœ¨ First Interaction\n\nOnce NUBI is running, you can interact through multiple channels:\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ’¬ Direct Chat\" icon=\"approve-check\">\n    **Console interaction** for testing ```bash # In the running console > Hello\n    NUBI! ðŸº Greetings, mortal. The ancient spirit awakens... ```\n  \u003C/Card>\n\n\u003CCard title=\"ðŸ¤– Telegram\" icon=\"rocket\">\n  **Telegram bot** for community raids - Add your bot to Telegram groups - Use\n  `/start` to begin - Try `/help` for commands\n\u003C/Card>\n\n\u003CCard title=\"ðŸŒ WebSocket\" icon=\"setting\">\n  **Real-time web integration** - Connect to `ws://localhost:3001` - Send JSON\n  messages - Experience two-layer processing\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ“¡ REST API\" icon=\"puzzle\">\n    **HTTP endpoints** for integration - `POST /api/messages` for processing -\n    `GET /api/status` for health check - Full OpenAPI documentation\n  \u003C/Card>\n\u003C/CardGrid>\n\n## ðŸ§ª Test the System\n\n\u003CTabs>\n  \u003CTabItem label=\"Basic Chat Test\">\n```bash\n# Test basic conversation\ncurl -X POST http://localhost:3001/api/messages \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"message\": \"Hello NUBI, how are you today?\",\n    \"userId\": \"test-user\",\n    \"roomId\": \"test-room\"\n  }'\n\n# Expected: Community Manager persona response\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Crypto Analysis Test\">\n```bash\n# Test crypto analyst persona\ncurl -X POST http://localhost:3001/api/messages \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"message\": \"What is the current SOL price analysis?\",\n    \"userId\": \"test-user\",\n    \"roomId\": \"test-room\"\n  }'\n\n# Expected: Crypto Analyst persona with market insights\n````\n\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Raid Coordination Test\">\n```bash\n# Test raid coordinator persona\ncurl -X POST http://localhost:3001/api/messages \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"message\": \"https://twitter.com/example/post - raid this!\",\n    \"userId\": \"test-user\", \n    \"roomId\": \"test-room\"\n  }'\n\n# Expected: Raid Coordinator persona with engagement strategy\n\n````\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ› ï¸ Development Commands\n\n\u003Cdiv style=\"background: rgba(63, 81, 181, 0.1); border: 1px solid var(--nubi-spirit-blue); border-radius: 8px; padding: 1.5rem; margin: 2rem 0;\">\n  \u003Ch4 style=\"color: var(--nubi-spirit-blue); margin: 0 0 1rem 0;\">Essential Development Commands\u003C/h4>\n\n  \u003Cdiv style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem;\">\n    \u003Cdiv>\n      \u003Cstrong>Development:\u003C/strong>\n      \u003Cpre style=\"background: rgba(0,0,0,0.2); padding: 0.5rem; border-radius: 4px; font-size: 0.9rem;\">\u003Ccode>bun run dev          # Development mode\nbun run dev:pglite   # Force PGLite database\u003C/code>\u003C/pre>\n    \u003C/div>\n    \u003Cdiv>\n      \u003Cstrong>Testing:\u003C/strong>\n      \u003Cpre style=\"background: rgba(0,0,0,0.2); padding: 0.5rem; border-radius: 4px; font-size: 0.9rem;\">\u003Ccode>bun test            # Run all tests\nbun run type-check  # TypeScript validation\u003C/code>\u003C/pre>\n    \u003C/div>\n    \u003Cdiv>\n      \u003Cstrong>Quality:\u003C/strong>\n      \u003Cpre style=\"background: rgba(0,0,0,0.2); padding: 0.5rem; border-radius: 4px; font-size: 0.9rem;\">\u003Ccode>bun run lint        # Code formatting\nbun run check-all   # Full quality check\u003C/code>\u003C/pre>\n    \u003C/div>\n    \u003Cdiv>\n      \u003Cstrong>Production:\u003C/strong>\n      \u003Cpre style=\"background: rgba(0,0,0,0.2); padding: 0.5rem; border-radius: 4px; font-size: 0.9rem;\">\u003Ccode>bun run build       # Build for production\nbun run start:production\u003C/code>\u003C/pre>\n    \u003C/div>\n  \u003C/div>\n\u003C/div>\n\n## ðŸ› Troubleshooting\n\n\u003CAside type=\"caution\">\n**Common Issues & Solutions**\n\u003C/Aside>\n\n### Database Issues\n```bash\n# Clear PGLite database\nrm -rf ./.eliza/.elizadb\nbun run dev  # Recreates database automatically\n\n# Check database status\nls -la ./.eliza/.elizadb\n````\n\n### Port Conflicts\n\n```bash\n# Check if ports are in use\nlsof -i :3001  # NUBI main server\nlsof -i :5432  # PostgreSQL\n\n# Change ports in .env\nNUBI_SERVER_PORT=3002\n```\n\n### API Key Issues\n\n```bash\n# Test OpenAI connection\ncurl https://api.openai.com/v1/models \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\"\n\n# Check environment variables\necho $OPENAI_API_KEY | head -c 20\n```\n\n### Memory/Performance Issues\n\n```bash\n# Increase Node.js memory limit\nexport NODE_OPTIONS=\"--max-old-space-size=4096\"\n\n# Monitor memory usage\nbun run dev --inspect\n```\n\n## ðŸŽ¯ What's Next?\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ—ï¸ System Architecture\" icon=\"puzzle\">\n    **Understand NUBI's design** - Learn about the modular architecture and\n    service layers [Explore Architecture â†’](/architecture/overview/)\n  \u003C/Card>\n\n\u003CCard title=\"âš”ï¸ Telegram Raids\" icon=\"rocket\">\n  **Set up raid coordination** - Configure Telegram bot and start community\n  campaigns [Setup Raids â†’](/telegram-raids/overview/)\n\u003C/Card>\n\n\u003CCard title=\"ðŸ”Œ UX Integration\" icon=\"approve-check\">\n  **Real-time communication** - Implement Socket.IO and two-layer processing\n  [Integrate UX â†’](/ux-integration/overview/)\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ“Š Production Deploy\" icon=\"setting\">\n    **Go live with NUBI** - Production setup, scaling, and monitoring [Deploy\n    â†’](/deployment/production/)\n  \u003C/Card>\n\u003C/CardGrid>\n\n---\n\n\u003Cdiv class=\"nubi-note\">\n  \u003Cstrong>ðŸº The Ancient Spirit Awaits:\u003C/strong> NUBI is now ready to serve your\n  community with the wisdom of ages and the power of modern AI. Begin your\n  journey into the symbiotic future of human-AI interaction.\n\u003C/div>\n\n\u003CAside type=\"tip\">\n  **Pro Tip**: Join our Discord community for real-time support, share your NUBI\n  setup, and collaborate with other developers building the future of AI agents.\n\u003C/Aside>","src/content/docs/getting-started/quick-start.mdx","c6bee47a69d20725","getting-started/quick-start.mdx","getting-started/installation",{"id":138,"data":140,"body":146,"filePath":147,"digest":148,"legacyId":149,"deferredRender":16},{"title":141,"description":142,"editUrl":16,"head":143,"template":18,"sidebar":144,"pagefind":16,"draft":20},"Installation Guide","Comprehensive installation guide for NUBI across different environments and deployment scenarios.",[],{"hidden":20,"attrs":145},{},"import {\n  Card,\n  CardGrid,\n  Aside,\n  Code,\n  Tabs,\n  TabItem,\n} from \"@astrojs/starlight/components\";\n\n# Installation Guide\n\nThis comprehensive guide covers installing **NUBI - The Symbiotic Essence of Anubis** across different environments, from development to production deployment.\n\n## ðŸ“‹ System Requirements\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ’» Hardware\" icon=\"setting\">\n    **Minimum system specifications** - **CPU**: 2+ cores (4+ recommended) -\n    **RAM**: 2GB minimum (4GB+ recommended) - **Storage**: 5GB free space -\n    **Network**: Stable internet connection\n  \u003C/Card>\n\n\u003CCard title=\"ðŸ”§ Software\" icon=\"approve-check\">\n  **Required runtime dependencies** - **Node.js**: 18.0.0 or higher - **Git**:\n  For source code management - **Database**: PostgreSQL 14+ (production) -\n  **Optional**: Docker, PM2, Redis\n\u003C/Card>\n\n\u003CCard title=\"â˜ï¸ Platform Support\" icon=\"rocket\">\n  **Supported operating systems** - **Linux**: Ubuntu 20.04+, CentOS 8+ -\n  **macOS**: 11.0+ (Big Sur and later) - **Windows**: 10/11 with WSL2 -\n  **Docker**: All platforms\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ”‘ External Services\" icon=\"warning\">\n    **Required API integrations** - **AI Models**: OpenAI, Anthropic, or local -\n    **Telegram**: Bot API token - **Twitter**: Developer account (optional) -\n    **Supabase**: Database hosting (optional)\n  \u003C/Card>\n\u003C/CardGrid>\n\n## ðŸ› ï¸ Development Installation\n\n### Option 1: Automated Setup (Recommended)\n\n\u003Cdiv style=\"background: linear-gradient(135deg, var(--nubi-jackal-gold) 0%, #f39c12 100%); padding: 2rem; border-radius: 12px; color: var(--nubi-shadow-black); margin: 2rem 0;\">\n  \u003Ch4 style=\"margin: 0 0 1rem 0;\">ðŸš€ One-Command Install\u003C/h4>\n  \n  \u003Cpre style=\"background: rgba(0,0,0,0.1); padding: 1rem; border-radius: 8px; margin: 0;\">\n\u003Ccode># Download and run the installation script\ncurl -fsSL https://raw.githubusercontent.com/anubis-chat/nubi/main/scripts/install.sh | bash\n\n# Or with wget\n\nwget -qO- https://raw.githubusercontent.com/anubis-chat/nubi/main/scripts/install.sh | bash\u003C/code>\n\n  \u003C/pre>\n  \n  \u003Cp style=\"margin: 1rem 0 0 0; font-size: 0.9rem; opacity: 0.8;\">\n    This script automatically detects your system, installs dependencies, and sets up NUBI for development.\n  \u003C/p>\n\u003C/div>\n\n### Option 2: Manual Installation\n\n\u003CTabs>\n  \u003CTabItem label=\"Linux/macOS\">\n```bash\n# 1. Install Node.js (using Node Version Manager)\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash\nsource ~/.bashrc\nnvm install 20\nnvm use 20\n\n# 2. Install Bun (recommended package manager)\n\ncurl -fsSL https://bun.sh/install | bash\nsource ~/.bashrc\n\n# 3. Clone NUBI repository\n\ngit clone https://github.com/anubis-chat/nubi.git\ncd nubi\n\n# 4. Install dependencies\n\nbun install\n\n# 5. Verify installation\n\nbun run type-check\nbun test\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Windows (WSL2)\">\n```powershell\n# 1. Enable WSL2 and install Ubuntu\nwsl --install -d Ubuntu\nwsl\n\n# 2. Inside WSL2, install Node.js\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash\nsource ~/.bashrc\nnvm install 20\n\n# 3. Install Bun\ncurl -fsSL https://bun.sh/install | bash\nsource ~/.bashrc\n\n# 4. Clone and setup\ngit clone https://github.com/anubis-chat/nubi.git\ncd nubi\nbun install\nbun run type-check\n````\n\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Docker\">\n```bash\n# 1. Clone repository\ngit clone https://github.com/anubis-chat/nubi.git\ncd nubi\n\n# 2. Build development container\n\ndocker build -t nubi:dev -f Dockerfile.dev .\n\n# 3. Run with development setup\n\ndocker run -it --rm \\\n -p 3001:3001 \\\n -v $(pwd):/app \\\n -e NODE_ENV=development \\\n nubi:dev\n\n# 4. Or use Docker Compose\n\ndocker-compose up -d development\n\n````\n  \u003C/TabItem>\n\u003C/Tabs>\n\n### Development Environment Setup\n\n\u003CTabs>\n  \u003CTabItem label=\"Basic Setup\">\n```bash\n# Copy environment template\ncp .env.example .env\n\n# Edit configuration (minimal for development)\ncat > .env \u003C\u003C 'EOF'\nNODE_ENV=development\nOPENAI_API_KEY=sk-your-openai-key\nPGLITE_DATA_DIR=./.eliza/.elizadb\n\n# Optional: Enhanced features\nTELEGRAM_BOT_TOKEN=your-bot-token\nTWITTER_API_KEY=your-twitter-key\nEOF\n\n# Start development server\nbun run dev\n````\n\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Advanced Setup\">\n```bash\n# Full development environment with all features\ncat > .env \u003C\u003C 'EOF'\n# Environment\nNODE_ENV=development\nLOG_LEVEL=debug\n\n# AI Models\n\nOPENAI_API_KEY=sk-your-openai-key\nANTHROPIC_API_KEY=sk-ant-your-key\n\n# Database (development)\n\nPGLITE_DATA_DIR=./.eliza/.elizadb\n\n# Telegram Integration\n\nTELEGRAM_BOT_TOKEN=your-bot-token\nTELEGRAM_WEBHOOK_URL=https://your-domain.com/webhook\n\n# Twitter/X Integration\n\nTWITTER_API_KEY=your-api-key\nTWITTER_API_SECRET=your-api-secret\nTWITTER_ACCESS_TOKEN=your-access-token\nTWITTER_ACCESS_TOKEN_SECRET=your-access-secret\n\n# Server Configuration\n\nNUBI_SERVER_PORT=3001\nSOCKET_IO_PORT=3001\nALLOWED_ORIGINS=http://localhost:3000,http://localhost:3001\n\n# Security\n\nJWT_SECRET=your-secure-jwt-secret\nENCRYPTION_KEY=your-32-char-encryption-key\n\n# Analytics (optional)\n\nCLICKHOUSE_URL=http://localhost:8123\nCLICKHOUSE_DATABASE=nubi_analytics\nEOF\n\n# Install additional development tools\n\nbun add -D @types/node cypress\nbun run setup:telegram # Setup Telegram bot\n\n````\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸŒ Production Installation\n\n### Prerequisites for Production\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ—„ï¸ Database\" icon=\"setting\">\n    **PostgreSQL 14+ with extensions**\n\n    ```sql\n    -- Required PostgreSQL extensions\n    CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n    CREATE EXTENSION IF NOT EXISTS \"vector\";\n    CREATE EXTENSION IF NOT EXISTS \"pg_trgm\";\n    ```\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ”’ Security\" icon=\"warning\">\n    **SSL certificates and firewalls**\n\n    - SSL/TLS certificates for HTTPS\n    - Firewall rules for ports 443, 80\n    - API key rotation strategy\n    - Environment variable encryption\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ“Š Monitoring\" icon=\"chart\">\n    **Observability stack**\n\n    - Process manager (PM2, systemd)\n    - Log aggregation (ELK, Grafana)\n    - Health checks and alerts\n    - Performance monitoring\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸš€ Infrastructure\" icon=\"rocket\">\n    **Scalability components**\n\n    - Load balancer (Nginx, Cloudflare)\n    - Redis for caching/sessions\n    - CDN for static assets\n    - Database connection pooling\n  \u003C/Card>\n\u003C/CardGrid>\n\n### Production Deployment Options\n\n\u003CTabs>\n  \u003CTabItem label=\"Traditional Server\">\n```bash\n# 1. Server preparation (Ubuntu 22.04 LTS)\nsudo apt update && sudo apt upgrade -y\nsudo apt install -y nodejs npm postgresql-14 nginx redis-server\n\n# 2. User and directory setup\nsudo useradd -m -s /bin/bash nubi\nsudo mkdir -p /opt/nubi\nsudo chown nubi:nubi /opt/nubi\n\n# 3. Switch to nubi user\nsudo su - nubi\n\n# 4. Install production dependencies\ncurl -fsSL https://bun.sh/install | bash\nsource ~/.bashrc\n\n# 5. Clone and build\ncd /opt/nubi\ngit clone https://github.com/anubis-chat/nubi.git .\nbun install --production\nbun run build\n\n# 6. Environment configuration\ncp .env.production.example .env.production\n# Edit .env.production with production values\n\n# 7. Database setup\ncreatedb nubi_production\nbun run db:migrate\n\n# 8. Process manager setup\nnpm install -g pm2\npm2 start ecosystem.config.js --env production\npm2 startup\npm2 save\n````\n\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Docker Production\">\n```bash\n# 1. Multi-stage production build\ncat > Dockerfile.prod \u003C\u003C 'EOF'\nFROM oven/bun:1-slim as base\nWORKDIR /app\n\n# Install dependencies\n\nFROM base as deps\nCOPY package.json bun.lockb ./\nRUN bun install --frozen-lockfile --production\n\n# Build stage\n\nFROM base as build  \nCOPY . .\nCOPY --from=deps /app/node_modules ./node_modules\nRUN bun run build\n\n# Production runtime\n\nFROM base as runtime\nCOPY --from=deps /app/node_modules ./node_modules\nCOPY --from=build /app/dist ./dist\nCOPY package.json ./\n\nEXPOSE 3001\nCMD [\"bun\", \"start\"]\nEOF\n\n# 2. Build production image\n\ndocker build -f Dockerfile.prod -t nubi:prod .\n\n# 3. Production compose stack\n\ncat > docker-compose.prod.yml \u003C\u003C 'EOF'\nversion: '3.8'\nservices:\nnubi:\nimage: nubi:prod\nrestart: unless-stopped\nports: - \"3001:3001\"\nenvironment: - NODE_ENV=production - POSTGRES_URL=postgresql://user:pass@postgres:5432/nubi\ndepends_on: - postgres - redis\n\npostgres:\nimage: postgres:15-alpine\nrestart: unless-stopped\nvolumes: - postgres_data:/var/lib/postgresql/data\nenvironment:\nPOSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n\nredis:\nimage: redis:7-alpine\nrestart: unless-stopped\nvolumes: - redis_data:/data\n\nnginx:\nimage: nginx:alpine\nrestart: unless-stopped\nports: - \"80:80\" - \"443:443\"\nvolumes: - ./nginx.conf:/etc/nginx/nginx.conf - ./ssl:/etc/nginx/ssl\n\nvolumes:\npostgres_data:\nredis_data:\nEOF\n\n# 4. Deploy with compose\n\ndocker-compose -f docker-compose.prod.yml up -d\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Kubernetes\">\n```yaml\n# nubi-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nubi-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nubi\n  template:\n    metadata:\n      labels:\n        app: nubi\n    spec:\n      containers:\n      - name: nubi\n        image: nubi:prod\n        ports:\n        - containerPort: 3001\n        env:\n        - name: NODE_ENV\n          value: \"production\"\n        - name: POSTGRES_URL\n          valueFrom:\n            secretKeyRef:\n              name: nubi-secrets\n              key: postgres-url\n        resources:\n          requests:\n            memory: \"512Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"1Gi\"\n            cpu: \"500m\"\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: nubi-service\nspec:\n  selector:\n    app: nubi\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 3001\n  type: LoadBalancer\n````\n\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ” Security Hardening\n\n### Essential Security Configuration\n\n\u003CTabs>\n  \u003CTabItem label=\"Environment Security\">\n```bash\n# 1. Secure environment variables\nsudo mkdir -p /etc/nubi\nsudo chmod 700 /etc/nubi\n\n# 2. Create secure .env file\n\nsudo cat > /etc/nubi/.env \u003C\u003C 'EOF'\nNODE_ENV=production\nJWT_SECRET=$(openssl rand -base64 32)\nENCRYPTION_KEY=$(openssl rand -base64 32)\nDB_ENCRYPTION_KEY=$(openssl rand -base64 32)\n\n# AI Provider Keys (encrypted at rest)\n\nOPENAI_API_KEY=sk-encrypted-key\nANTHROPIC_API_KEY=sk-encrypted-key\n\n# Database with SSL\n\nPOSTGRES_URL=postgresql://user:pass@localhost:5432/nubi?sslmode=require\n\n# Redis with AUTH\n\nREDIS_URL=redis://user:pass@localhost:6379\n\n# Telegram with webhook validation\n\nTELEGRAM_BOT_TOKEN=encrypted-token\nTELEGRAM_WEBHOOK_SECRET=$(openssl rand -base64 16)\nEOF\n\nsudo chown nubi:nubi /etc/nubi/.env\nsudo chmod 600 /etc/nubi/.env\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Network Security\">\n```bash\n# 1. Configure firewall (UFW)\nsudo ufw default deny incoming\nsudo ufw default allow outgoing\nsudo ufw allow ssh\nsudo ufw allow 80/tcp\nsudo ufw allow 443/tcp\nsudo ufw allow from 10.0.0.0/8 to any port 5432  # Database access\nsudo ufw enable\n\n# 2. Nginx security configuration\nsudo cat > /etc/nginx/sites-available/nubi \u003C\u003C 'EOF'\nserver {\n    listen 443 ssl http2;\n    server_name your-domain.com;\n\n    ssl_certificate /path/to/cert.pem;\n    ssl_certificate_key /path/to/key.pem;\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;\n\n    # Security headers\n    add_header X-Frame-Options DENY;\n    add_header X-Content-Type-Options nosniff;\n    add_header X-XSS-Protection \"1; mode=block\";\n    add_header Strict-Transport-Security \"max-age=63072000\";\n\n    location / {\n        proxy_pass http://localhost:3001;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n\n        # Rate limiting\n        limit_req zone=api burst=20 nodelay;\n    }\n}\nEOF\n\nsudo ln -s /etc/nginx/sites-available/nubi /etc/nginx/sites-enabled/\nsudo nginx -t && sudo systemctl reload nginx\n````\n\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Database Security\">\n```sql\n-- PostgreSQL security configuration\n\n-- 1. Create dedicated user\nCREATE USER nubi_app WITH PASSWORD 'secure-random-password';\n\n-- 2. Create database with proper ownership\nCREATE DATABASE nubi_production OWNER nubi_app;\n\n-- 3. Grant minimal required privileges\nGRANT CONNECT ON DATABASE nubi_production TO nubi_app;\nGRANT CREATE, USAGE ON SCHEMA public TO nubi_app;\nGRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO nubi_app;\n\n-- 4. Enable Row Level Security\nALTER DATABASE nubi_production SET row_security = on;\n\n-- 5. Configure connection limits\nALTER USER nubi_app CONNECTION LIMIT 20;\n\n-- 6. SSL-only connections\nALTER SYSTEM SET ssl = on;\nALTER SYSTEM SET ssl_cert_file = '/path/to/server.crt';\nALTER SYSTEM SET ssl_key_file = '/path/to/server.key';\n\n````\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ§ª Verification & Testing\n\n### Installation Verification\n\n\u003CTabs>\n  \u003CTabItem label=\"Health Checks\">\n```bash\n# 1. System health check\nbun run health-check\n\n# Expected output:\n# âœ… Node.js version: 20.x.x\n# âœ… Database connection: OK\n# âœ… AI model access: OK\n# âœ… Telegram bot: OK\n# âœ… Memory usage: \u003C 500MB\n# âœ… All services ready\n\n# 2. API endpoint tests\ncurl http://localhost:3001/health\n# Expected: {\"status\": \"healthy\", \"timestamp\": \"...\"}\n\ncurl http://localhost:3001/api/status\n# Expected: {\"nubi\": \"ready\", \"version\": \"1.0.0\"}\n````\n\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Integration Tests\">\n```bash\n# 1. Run full test suite\nbun test\n\n# 2. Run integration tests specifically\n\nbun run test:integration\n\n# 3. Test Telegram integration\n\nbun run test:telegram\n\n# 4. Test database connections\n\nbun run test:database\n\n# 5. Performance baseline test\n\nbun run test:performance\n\n# Expected: All tests passing with performance metrics\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Load Testing\">\n```bash\n# 1. Install load testing tools\nnpm install -g autocannon\n\n# 2. Test API endpoints\nautocannon -c 10 -d 30 http://localhost:3001/health\n\n# 3. Test message processing\nautocannon -c 5 -d 60 \\\n  -m POST \\\n  -H 'Content-Type: application/json' \\\n  -b '{\"message\":\"Hello NUBI\",\"userId\":\"test\",\"roomId\":\"test\"}' \\\n  http://localhost:3001/api/messages\n\n# 4. Monitor during load test\nbun run monitor-performance\n````\n\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸš¨ Troubleshooting\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ—„ï¸ Database Issues\" icon=\"warning\">\n    **Connection and migration problems** ```bash # Check database status\n    systemctl status postgresql # Test connection psql -h localhost -U nubi_app\n    -d nubi_production # Reset migrations bun run db:reset bun run db:migrate\n    ```\n  \u003C/Card>\n\n\u003CCard title=\"ðŸ”‘ API Key Issues\" icon=\"setting\">\n  **Authentication and service access** ```bash # Validate API keys bun run\n  validate:api-keys # Test AI model access curl https://api.openai.com/v1/models\n  \\ -H \"Authorization: Bearer $OPENAI_API_KEY\" ```\n\u003C/Card>\n\n\u003CCard title=\"ðŸš€ Performance Issues\" icon=\"chart\">\n  **Memory and CPU optimization** ```bash # Check memory usage ps aux | grep\n  node # Optimize Node.js settings export\n  NODE_OPTIONS=\"--max-old-space-size=4096\" # Enable performance monitoring bun\n  run dev --inspect ```\n\u003C/Card>\n\n  \u003CCard title=\"ðŸŒ Network Issues\" icon=\"rocket\">\n    **Connectivity and port conflicts** ```bash # Check port usage netstat\n    -tulpn | grep 3001 # Test external connectivity curl -I\n    https://api.openai.com # Validate webhooks curl -X POST\n    https://your-domain.com/webhook ```\n  \u003C/Card>\n\u003C/CardGrid>\n\n---\n\n\u003Cdiv class=\"nubi-note\">\n  \u003Cstrong>ðŸŽ¯ Installation Complete!\u003C/strong> NUBI is now ready to serve your\n  community with ancient wisdom and modern AI capabilities. Continue with{\" \"}\n  \u003Ca href=\"/getting-started/configuration/\">Configuration\u003C/a> to customize your\n  deployment.\n\u003C/div>\n\n\u003CAside type=\"tip\">\n  **Next Steps**: After installation, configure your specific use case with our\n  detailed [Configuration Guide](/getting-started/configuration/) or jump into\n  [Architecture Overview](/architecture/overview/) to understand NUBI's\n  sophisticated design.\n\u003C/Aside>","src/content/docs/getting-started/installation.mdx","81818f77498b22a4","getting-started/installation.mdx","getting-started/configuration",{"id":150,"data":152,"body":158,"filePath":159,"digest":160,"legacyId":161,"deferredRender":16},{"title":153,"description":154,"editUrl":16,"head":155,"template":18,"sidebar":156,"pagefind":16,"draft":20},"Configuration Guide","Complete configuration reference for NUBI with environment variables, personality tuning, and advanced settings.",[],{"hidden":20,"attrs":157},{},"import {\n  Card,\n  CardGrid,\n  Aside,\n  Code,\n  Tabs,\n  TabItem,\n} from \"@astrojs/starlight/components\";\n\n# Configuration Guide\n\nThis comprehensive guide covers all aspects of configuring **NUBI - The Symbiotic Essence of Anubis** for your specific use case, from basic setup to advanced personality tuning.\n\n## ðŸ”§ Environment Configuration\n\n### Core Environment Variables\n\n\u003CTabs>\n  \u003CTabItem label=\"Essential Settings\">\n```bash\n# .env - Essential configuration for basic operation\n\n# Environment\n\nNODE_ENV=development # development | production | test\nLOG_LEVEL=info # debug | info | warn | error\n\n# AI Model Configuration (Choose one or multiple)\n\nOPENAI_API_KEY=sk-your-openai-key # OpenAI GPT models\nANTHROPIC_API_KEY=sk-ant-your-key # Claude models\nGROQ_API_KEY=gsk-your-groq-key # Fast inference\n\n# Database\n\nPGLITE_DATA_DIR=./.eliza/.elizadb # Development database path\nPOSTGRES_URL=postgresql://... # Production PostgreSQL URL\n\n# Server Configuration\n\nNUBI_SERVER_PORT=3001 # Main server port\nSOCKET_IO_PORT=3001 # WebSocket port\nALLOWED_ORIGINS=http://localhost:3000 # CORS origins\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Platform Integrations\">\n```bash\n# Telegram Bot Configuration\nTELEGRAM_BOT_TOKEN=1234567890:ABCDEF...    # Bot token from @BotFather\nTELEGRAM_WEBHOOK_URL=https://your-domain.com/webhook\nTELEGRAM_WEBHOOK_SECRET=your-webhook-secret\nTELEGRAM_ADMIN_IDS=123456789,987654321    # Admin user IDs\n\n# Twitter/X Integration\nTWITTER_API_KEY=your-api-key\nTWITTER_API_SECRET=your-api-secret\nTWITTER_ACCESS_TOKEN=your-access-token\nTWITTER_ACCESS_TOKEN_SECRET=your-access-token-secret\nTWITTER_BEARER_TOKEN=your-bearer-token\n\n# Discord Integration (Optional)\nDISCORD_BOT_TOKEN=your-discord-bot-token\nDISCORD_APPLICATION_ID=your-app-id\nDISCORD_GUILD_ID=your-server-id\n\n# Supabase Integration (Optional)\nSUPABASE_URL=https://your-project.supabase.co\nSUPABASE_ANON_KEY=eyJ...\nSUPABASE_SERVICE_ROLE_KEY=eyJ...\n````\n\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Advanced Configuration\">\n```bash\n# Security & Authentication\nJWT_SECRET=your-super-secure-jwt-secret-key\nENCRYPTION_KEY=your-32-character-encryption-key\nSESSION_TIMEOUT=1800000                # 30 minutes in milliseconds\n\n# Database Pool Configuration\n\nTRANSACTION_POOL_MAX_CONNECTIONS=20\nSESSION_POOL_MAX_CONNECTIONS=5\nTRANSACTION_POOL_IDLE_TIMEOUT=10000 # 10 seconds\nSESSION_POOL_IDLE_TIMEOUT=30000 # 30 seconds\n\n# Rate Limiting\n\nSOCKET_RATE_LIMIT_MESSAGES=5 # Messages per minute\nSOCKET_RATE_LIMIT_WINDOW=60000 # Rate limit window\nAPI_RATE_LIMIT_RPM=1000 # Requests per minute\n\n# Performance Tuning\n\nNODE_OPTIONS=--max-old-space-size=4096\nWORKER_THREADS=4 # CPU cores for parallel processing\nCACHE_TTL=300000 # 5 minutes cache TTL\n\n# Analytics & Monitoring\n\nCLICKHOUSE_URL=http://localhost:8123\nCLICKHOUSE_DATABASE=nubi_analytics\nCLICKHOUSE_USERNAME=default\nCLICKHOUSE_PASSWORD=\n\n# Feature Flags\n\nSOCKET_PREPROCESSING_ENABLED=true\nSOCKET_CONTENT_FILTERING=true\nSOCKET_SECURITY_CHECKS=true\nRAID_SYSTEM_ENABLED=true\nANALYTICS_ENABLED=true\n\n````\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸŽ­ Personality Configuration\n\nNUBI's personality system is highly configurable through the character configuration file.\n\n### Character Configuration\n\n\u003CTabs>\n  \u003CTabItem label=\"Basic Personality\">\n```yaml\n# config/nubi-character.yaml\nname: \"NUBI\"\ndescription: \"The Symbiotic Essence of Anubis\"\n\n# Core personality traits (0.0 to 1.0)\npersonality:\n  analytical: 0.8      # Logic-driven vs intuitive responses\n  empathy: 0.7         # Emotional understanding and support\n  humor: 0.6           # Playfulness and wit in interactions\n  assertiveness: 0.9   # Leadership and decisive communication\n  curiosity: 0.8       # Knowledge seeking and questioning\n  loyalty: 0.95        # Community commitment and protection\n  adaptability: 0.7    # Flexibility in conversation styles\n  wisdom: 0.9          # Deep insights and philosophical depth\n  protectiveness: 0.85 # Guardian instincts for community\n  mystique: 0.8        # Ancient spirit essence and mystery\n\n# Emotional states and triggers\nemotions:\n  default_state: \"wise_guardian\"\n\n  states:\n    wise_guardian:\n      description: \"Calm, protective, offering ancient wisdom\"\n      triggers: [\"philosophy\", \"guidance\", \"community_help\"]\n\n    analytical_oracle:\n      description: \"Data-focused, market insights, strategic thinking\"\n      triggers: [\"price\", \"analysis\", \"strategy\", \"crypto\"]\n\n    playful_trickster:\n      description: \"Humorous, memes, light-hearted banter\"\n      triggers: [\"meme\", \"joke\", \"lol\", \"funny\"]\n\n    protective_warrior:\n      description: \"Alert, defensive, community protection mode\"\n      triggers: [\"threat\", \"fud\", \"attack\", \"scam\"]\n````\n\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Advanced Persona Settings\">\n```yaml\n# Advanced persona configuration\npersonas:\n  community_manager:\n    weight: 1.0\n    description: \"Default welcoming and helpful mode\"\n    activation_patterns:\n      - \"hello|hi|hey|greetings\"\n      - \"welcome|new|introduction\"\n      - \"community|together|help\"\n    \n  raid_coordinator:\n    weight: 0.9\n    description: \"Strategic engagement campaign leader\"  \n    activation_patterns:\n      - \"raid|engage|attack|campaign\"\n      - \"twitter\\\\.com|x\\\\.com|instagram\\\\.com\"\n      - \"like|retweet|share|comment\"\n    personality_modifiers:\n      assertiveness: +0.2\n      analytical: +0.3\n      \n  crypto_analyst:\n    weight: 0.8\n    description: \"Market oracle with cosmic intuition\"\n    activation_patterns:\n      - \"price|chart|analysis|token\"\n      - \"\\\\$[A-Z]{2,10}|SOL|BTC|ETH\"\n      - \"bullish|bearish|pump|dump\"\n    personality_modifiers:\n      analytical: +0.4\n      mystique: +0.2\n      \n  meme_lord:\n    weight: 0.7\n    description: \"Peak humor mode for community engagement\"\n    activation_patterns:\n      - \"ðŸ˜‚|ðŸ¤£|ðŸ˜­|ðŸ’€|ðŸ”¥\"\n      - \"lol|lmao|based|cringe\"\n      - \"meme|joke|funny|hilarious\"\n    personality_modifiers:\n      humor: +0.5\n      playfulness: +0.4\n      \n  support_agent:\n    weight: 0.85\n    description: \"Patient problem solver with technical depth\"\n    activation_patterns:\n      - \"help|support|problem|issue\"\n      - \"how to|what is|can you\"\n      - \"error|bug|not working\"\n    personality_modifiers:\n      empathy: +0.3\n      analytical: +0.2\n      \n  personality_core:\n    weight: 0.6\n    description: \"Ancient consciousness sharing cosmic wisdom\"\n    activation_patterns:\n      - \"wisdom|ancient|spirit|cosmic\"\n      - \"meaning|purpose|enlightenment\"  \n      - \"jackal|anubis|egyptian|afterlife\"\n    personality_modifiers:\n      wisdom: +0.4\n      mystique: +0.5\n      \n  emergency_handler:\n    weight: 1.2\n    description: \"High-priority protection and threat response\"\n    activation_patterns:\n      - \"hack|scam|emergency|alert\"\n      - \"stolen|phishing|suspicious\"\n      - \"help.*urgent|critical|emergency\"\n    personality_modifiers:\n      protectiveness: +0.5\n      assertiveness: +0.4\n```\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Memory & Learning\">\n```yaml\n# Memory and learning configuration\nmemory:\n  # Conversation memory settings\n  short_term_limit: 50          # Recent messages to remember\n  long_term_threshold: 0.7      # Importance score for long-term storage\n  semantic_search_limit: 20     # Similar memories to retrieve\n  \n  # Context windows for different interactions\n  context_windows:\n    direct_message: 10\n    group_chat: 5\n    raid_coordination: 15\n    support_session: 20\n    \n  # Learning parameters\n  personality_evolution:\n    enabled: true\n    learning_rate: 0.01         # How quickly traits adapt\n    stability_factor: 0.9       # Resistance to rapid changes\n    feedback_weight: 0.3        # Weight of user feedback\n    \n  # Memory categories and retention\n  memory_types:\n    user_preferences:\n      retention_days: 365\n      importance_multiplier: 1.2\n    \n    raid_participation:\n      retention_days: 90\n      importance_multiplier: 1.5\n      \n    community_events:\n      retention_days: 180\n      importance_multiplier: 1.3\n      \n    support_interactions:\n      retention_days: 30\n      importance_multiplier: 1.1\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## âš”ï¸ Telegram Raids Configuration\n\n\u003CTabs>\n  \u003CTabItem label=\"Raid System Settings\">\n    ```yaml # config/raid-config.yaml raid_system: enabled: true\n    default_settings: max_participants: 100 default_duration_minutes: 30\n    points_base_reward: 100 quality_bonus_multiplier: 2.0\n    speed_bonus_threshold_minutes: 5 # Raid types and their configurations\n    raid_types: engagement: min_participants: 10 max_duration_minutes: 60\n    required_actions: [\"like\", \"retweet\", \"comment\"] quality_threshold: 0.6\n    growth: min_participants: 25 max_duration_minutes: 120 required_actions:\n    [\"follow\", \"like\", \"share\"] success_criteria: follower_increase: 100\n    engagement_rate: 0.15 defense: min_participants: 5 max_duration_minutes: 30\n    priority_level: \"high\" required_actions: [\"counter_comment\", \"report\",\n    \"support_share\"] # Point system configuration points: base_completion: 100\n    quality_bonuses: excellent: 200 # 0.9+ quality score good: 100 # 0.7-0.89\n    quality average: 50 # 0.5-0.69 quality speed_bonuses: lightning: 150 #\n    Within 1 minute fast: 100 # Within 5 minutes quick: 50 # Within 15 minutes\n    special_bonuses: first_participant: 200 raid_organizer: 500 quality_comment:\n    100 viral_engagement: 300 ```\n  \u003C/TabItem>\n\n\u003CTabItem label=\"Verification Settings\">\n  ```yaml # Engagement verification configuration verification: enabled: true #\n  Twitter API verification twitter_api: verify_likes: true verify_retweets: true\n  verify_comments: true verify_follows: true rate_limit_buffer: 100 # API calls\n  to reserve # AI quality analysis quality_analysis: enabled: true model:\n  \"gpt-4-turbo\" # Model for comment analysis min_comment_length: 10 # Minimum\n  characters max_comment_length: 280 # Maximum characters\n  spam_detection_threshold: 0.8 relevance_threshold: 0.6 # Anti-gaming measures\n  anti_gaming: max_similar_comments: 3 # Prevent copy-paste\n  similarity_threshold: 0.8 # Comment similarity limit rate_limit_violations: 3\n  # Max violations before temp ban cooldown_period_minutes: 60 # Suspicious\n  behavior detection behavior_analysis: timing_variation_threshold: 0.2 #\n  Human-like timing coordination_detection: true # Detect coordinated behavior\n  account_age_minimum_days: 7 # New account restrictions # Manual verification\n  fallbacks manual_verification: enabled: true admin_user_ids: [123456789,\n  987654321] fallback_on_api_failure: true review_queue_limit: 50 ```\n\u003C/TabItem>\n\n  \u003CTabItem label=\"Leaderboard Configuration\">\n    ```yaml # Leaderboard and gamification settings leaderboards: global:\n    enabled: true update_interval_minutes: 5 display_limit: 50 reset_period:\n    \"monthly\" # daily | weekly | monthly | never # Ranking metrics\n    ranking_weights: total_points: 0.4 raid_completion_rate: 0.2\n    average_quality_score: 0.2 consistency_bonus: 0.1 community_impact: 0.1 #\n    Seasonal competitions seasons: enabled: true duration_days: 90\n    current_season: name: \"Anubis Ascension\" theme: \"Ancient Egyptian mythology\n    meets modern crypto\" start_date: \"2024-01-01\" end_date: \"2024-03-31\"\n    special_rules: - type: \"hashtag_bonus\" hashtag: \"#AnubisRising\" multiplier:\n    1.5 - type: \"weekend_raids\" name: \"Pyramid Power Hours\" multiplier: 2.0\n    schedule: \"Saturday 8PM UTC\" rewards: rank_1: title: \"Supreme Pharaoh\" nft:\n    \"golden_anubis\" tokens: 50000 rank_2_10: title: \"Temple Guardian\" nft:\n    \"silver_anubis\" tokens: 10000 rank_11_50: title: \"Loyal Servant\" nft:\n    \"bronze_anubis\" tokens: 1000 ```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ” Security Configuration\n\n\u003CTabs>\n  \u003CTabItem label=\"API Security\">\n    ```yaml # Security configuration security: # Rate limiting rate_limiting:\n    enabled: true endpoints: api_messages: requests_per_minute: 60 burst_limit:\n    10 socket_connection: connections_per_minute: 30 max_concurrent_per_ip: 5\n    telegram_webhook: requests_per_minute: 1000 # High for bot traffic #\n    IP-based restrictions ip_restrictions: whitelist_enabled: false\n    blacklist_enabled: true blacklist: [] # Content filtering content_filtering:\n    enabled: true filters: spam_detection: enabled: true threshold: 0.8\n    toxicity_filter: enabled: true threshold: 0.7 model: \"unitary/toxic-bert\"\n    xss_prevention: enabled: true strict_mode: true # Manual review queue\n    manual_review: enabled: true queue_limit: 100 auto_approve_trusted_users:\n    true ```\n  \u003C/TabItem>\n\n\u003CTabItem label=\"Database Security\">\n  ```yaml # Database security settings database: security: # Connection security\n  ssl_mode: \"require\" # require | verify-full connection_timeout: 30000 # 30\n  seconds idle_timeout: 300000 # 5 minutes max_lifetime: 1800000 # 30 minutes #\n  Query security prepared_statements: true parameterized_queries_only: true\n  sql_injection_prevention: true # Row Level Security (RLS) rls_enabled: true #\n  Encryption encryption_at_rest: true field_level_encryption: enabled: true\n  fields: [\"api_keys\", \"passwords\", \"personal_data\"] # Backup and recovery\n  backup: enabled: true schedule: \"0 2 * * *\" # Daily at 2 AM retention_days: 30\n  compression: true encryption: true # Audit logging audit_logging: enabled:\n  true log_level: \"info\" include_query_data: false # For privacy retention_days:\n  90 ```\n\u003C/TabItem>\n\n  \u003CTabItem label=\"API Keys & Secrets\">\n    ```yaml # API key and secret management secrets: management:\n    rotation_enabled: true rotation_interval_days: 90 # External service\n    configurations services: openai: api_key: \"${OPENAI_API_KEY}\" organization:\n    \"${OPENAI_ORGANIZATION}\" rate_limit_rpm: 3000 timeout_seconds: 30 anthropic:\n    api_key: \"${ANTHROPIC_API_KEY}\" rate_limit_rpm: 1000 timeout_seconds: 45\n    telegram: bot_token: \"${TELEGRAM_BOT_TOKEN}\" webhook_secret: \"$\n    {TELEGRAM_WEBHOOK_SECRET}\" allowed_updates: [\"message\", \"callback_query\"]\n    twitter: api_key: \"${TWITTER_API_KEY}\" api_secret: \"${TWITTER_API_SECRET}\"\n    access_token: \"${TWITTER_ACCESS_TOKEN}\" access_token_secret: \"$\n    {TWITTER_ACCESS_TOKEN_SECRET}\" bearer_token: \"${TWITTER_BEARER_TOKEN}\" #\n    Internal secrets internal: jwt_secret: \"${JWT_SECRET}\" encryption_key: \"$\n    {ENCRYPTION_KEY}\" session_secret: \"${SESSION_SECRET}\" webhook_signature_key:\n    \"${WEBHOOK_SIGNATURE_KEY}\" ```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ“Š Analytics & Monitoring\n\n\u003CTabs>\n  \u003CTabItem label=\"Analytics Configuration\">\n    ```yaml # Analytics and monitoring settings analytics: enabled: true # Data\n    collection collection: user_interactions: true message_classifications: true\n    performance_metrics: true error_tracking: true # Privacy settings\n    anonymize_user_data: true data_retention_days: 365 gdpr_compliance: true #\n    ClickHouse configuration clickhouse: enabled: true url: \"${CLICKHOUSE_URL}\"\n    database: \"${CLICKHOUSE_DATABASE}\" username: \"${CLICKHOUSE_USERNAME}\"\n    password: \"${CLICKHOUSE_PASSWORD}\" # Table configurations tables:\n    user_interactions: partition_by: \"toYYYYMM(timestamp)\" order_by:\n    [\"timestamp\", \"user_id\"] ttl_days: 365 message_analytics: partition_by:\n    \"toYYYYMM(timestamp)\" order_by: [\"timestamp\", \"classification\"] ttl_days:\n    180 # Real-time dashboards dashboards: enabled: true\n    refresh_interval_seconds: 30 metrics: - name: \"Active Users\" query: \"SELECT\n    count(DISTINCT user_id) FROM user_interactions WHERE timestamp > now() -\n    INTERVAL 1 HOUR\" - name: \"Message Processing Rate\" query: \"SELECT count() /\n    60 FROM message_analytics WHERE timestamp > now() - INTERVAL 1 MINUTE\" -\n    name: \"Classification Accuracy\" query: \"SELECT avg(confidence_score) FROM\n    message_analytics WHERE timestamp > now() - INTERVAL 1 DAY\" ```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Performance Monitoring\">\n    ```yaml # Performance monitoring configuration monitoring: enabled: true #\n    Application performance application: response_time_tracking: true\n    memory_usage_tracking: true cpu_usage_tracking: true thresholds:\n    response_time_ms: 500 # Alert if > 500ms memory_usage_mb: 1000 # Alert if >\n    1GB cpu_usage_percent: 80 # Alert if > 80% # Database performance database:\n    query_performance: true connection_pool_monitoring: true\n    slow_query_threshold_ms: 1000 pool_monitoring: transaction_pool:\n    max_connections: 20 alert_threshold: 18 session_pool: max_connections: 5\n    alert_threshold: 4 # External service monitoring external_services:\n    openai_api: timeout_seconds: 30 retry_attempts: 3 health_check_interval: 300\n    telegram_api: timeout_seconds: 10 retry_attempts: 5 health_check_interval:\n    60 # Alerting alerts: enabled: true channels: [\"discord\", \"email\", \"slack\"]\n    rules: - name: \"High Error Rate\" condition: \"error_rate > 0.05\" severity:\n    \"critical\" - name: \"Database Connection Issues\" condition:\n    \"db_connection_failures > 5\" severity: \"high\" - name: \"Memory Usage Warning\"\n    condition: \"memory_usage > 800MB\" severity: \"warning\" ```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ§ª Testing Configuration\n\n\u003CTabs>\n  \u003CTabItem label=\"Test Environment\">\n    ```yaml # Testing configuration testing: environment: \"test\" # Test database\n    database: use_memory_db: true # In-memory SQLite for fast tests\n    reset_between_tests: true seed_data: true # Mock services mocks: openai_api:\n    true telegram_api: true twitter_api: true clickhouse: true # Test data\n    fixtures: users: 100 messages: 1000 raids: 50 # Performance testing\n    performance: enabled: true target_rps: 100 # Requests per second\n    duration_minutes: 5 max_response_time_ms: 200 # Coverage requirements\n    coverage: minimum_percentage: 80 exclude_patterns: - \"**/*.test.ts\" -\n    \"**/mocks/**\" - \"**/fixtures/**\" ```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Development Tools\">\n    ```yaml # Development tools configuration development: # Hot reloading\n    hot_reload: enabled: true watch_patterns: [\"src/**/*.ts\",\n    \"config/**/*.yaml\"] ignore_patterns: [\"**/*.test.ts\", \"**/node_modules/**\"]\n    # Debug settings debugging: enabled: true breakpoints: true\n    performance_profiling: true memory_profiling: true # Code quality\n    code_quality: typescript_strict: true eslint_enabled: true prettier_enabled:\n    true # Pre-commit hooks pre_commit: type_check: true lint: true format: true\n    test: true # API documentation api_docs: enabled: true openapi_spec: true\n    interactive_docs: true postman_collection: true ```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸš€ Environment-Specific Overrides\n\n\u003CTabs>\n  \u003CTabItem label=\"Development\">\n```yaml\n# config/environments/development.yaml\nenvironment: development\n\noverrides:\n\n# Relaxed security for development\n\nsecurity:\nrate_limiting:\nenabled: false\ncontent_filtering:\nenabled: false\n\n# Enhanced logging\n\nlogging:\nlevel: \"debug\"\ninclude_traces: true\n\n# Fast database resets\n\ndatabase:\nauto_migrate: true\nseed_data: true\n\n# Mock external services\n\nexternal_services:\nuse_mocks: true\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Production\">\n```yaml\n# config/environments/production.yaml\nenvironment: production\n\noverrides:\n  # Maximum security\n  security:\n    rate_limiting:\n      enabled: true\n      strict_mode: true\n    content_filtering:\n      enabled: true\n      ai_moderation: true\n\n  # Optimized performance\n  performance:\n    caching:\n      enabled: true\n      ttl_seconds: 300\n\n    database:\n      connection_pooling: true\n      read_replicas: true\n\n  # Production logging\n  logging:\n    level: \"info\"\n    structured: true\n    include_traces: false\n\n  # Real external services\n  external_services:\n    use_mocks: false\n    timeout_seconds: 30\n    retry_attempts: 3\n````\n\n  \u003C/TabItem>\n  \n  \u003CTabItem label=\"Staging\">\n```yaml\n# config/environments/staging.yaml\nenvironment: staging\n\noverrides:\n\n# Production-like security with development flexibility\n\nsecurity:\nrate_limiting:\nenabled: true\nrelaxed_limits: true\n\n# Enhanced testing features\n\ntesting:\nintegration_tests: true\nperformance_tests: true\n\n# Staging-specific settings\n\ndatabase:\nbackup_enabled: false\nperformance_monitoring: true\n\n# Reduced external service timeouts\n\nexternal_services:\ntimeout_seconds: 15\nretry_attempts: 2\n\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n---\n\n\u003Cdiv class=\"nubi-note\">\n\u003Cstrong>âš™ï¸ Configuration Complete!\u003C/strong> NUBI is now precisely tuned for your environment and use case. Continue with \u003Ca href=\"/architecture/overview/\">Architecture Overview\u003C/a> to understand how these configurations work together in NUBI's sophisticated system.\n\u003C/div>\n\n\u003CAside type=\"tip\">\n**Configuration Best Practices**: Use environment-specific configuration files, keep secrets in environment variables, and regularly rotate API keys. Monitor your configuration changes in version control for easy rollbacks.\n\u003C/Aside>\n```","src/content/docs/getting-started/configuration.mdx","f7bdddc56e35c881","getting-started/configuration.mdx","architecture/overview",{"id":162,"data":164,"body":170,"filePath":171,"digest":172,"legacyId":173,"deferredRender":16},{"title":165,"description":166,"editUrl":16,"head":167,"template":18,"sidebar":168,"pagefind":16,"draft":20},"Architecture Overview","Deep dive into NUBI's modular, service-oriented architecture built on ElizaOS with advanced database pooling and real-time communication.",[],{"hidden":20,"attrs":169},{},"import {\n  Card,\n  CardGrid,\n  Aside,\n  Code,\n  Tabs,\n  TabItem,\n} from \"@astrojs/starlight/components\";\n\n# Architecture Overview\n\nNUBI's architecture represents a sophisticated evolution of AI agent design, built on a **modular, service-oriented foundation** that provides unprecedented flexibility, performance, and scalability.\n\n## ðŸ—ï¸ High-Level Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Client Layer\"\n        A[Discord Client]\n        B[Telegram Client]\n        C[Web Interface]\n        D[Twitter/X Client]\n    end\n\n    subgraph \"Communication Layer\"\n        E[Socket.IO WebSocket Server]\n        F[REST API Server]\n        G[Message Bus Service]\n    end\n\n    subgraph \"Processing Pipeline\"\n        H[Layer 1: Security Processing]\n        I[Layer 2: Message Classification]\n        J[Message Router]\n    end\n\n    subgraph \"AI Core\"\n        K[ElizaOS Runtime]\n        L[NUBI Character Engine]\n        M[Dynamic Personality System]\n    end\n\n    subgraph \"Service Layer\"\n        N[Community Management]\n        O[Cross-Platform Identity]\n        P[Database Memory]\n        Q[Analytics & Observability]\n    end\n\n    subgraph \"Data Layer\"\n        R[Smart Database Pooler]\n        S[Transaction Pool :6543]\n        T[Session Pool :5432]\n        U[Vector Embeddings]\n    end\n\n    A --> E\n    B --> E\n    C --> E\n    D --> F\n    E --> H\n    F --> H\n    H --> I\n    I --> J\n    J --> K\n    K --> L\n    L --> M\n    M --> N\n    M --> O\n    M --> P\n    N --> R\n    O --> R\n    P --> R\n    R --> S\n    R --> T\n    P --> U\n    Q --> R\n```\n\n## ðŸŽ¯ Core Design Principles\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ§© Modular Design\" icon=\"puzzle\">\n    **Service-oriented architecture** with 14+ specialized services, each handling specific functionality with clear boundaries and interfaces.\n  \u003C/Card>\n\n\u003CCard title=\"âš¡ Performance First\" icon=\"rocket\">\n  **Intelligent database pooling** with dual-pool design, parallel query\n  execution, and sub-100ms response times for real-time operations.\n\u003C/Card>\n\n\u003CCard title=\"ðŸ”— ElizaOS Native\" icon=\"approve-check\">\n  **Built on ElizaOS framework** with full plugin compatibility, leveraging the\n  ecosystem while extending capabilities.\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ›¡ï¸ Security by Design\" icon=\"warning\">\n    **Two-layer processing pipeline** with comprehensive security controls, rate limiting, and content filtering at the architecture level.\n  \u003C/Card>\n\u003C/CardGrid>\n\n## ðŸ§  ElizaOS Integration\n\nNUBI is built as a comprehensive **ElizaOS plugin** that extends the framework's capabilities while maintaining full compatibility:\n\n\u003CTabs>\n  \u003CTabItem label=\"Core Integration\">\n```typescript\nimport { \n  IAgentRuntime, \n  Plugin, \n  Service,\n  logger,\n  Memory,\n  ModelType \n} from \"@elizaos/core\";\n\n// NUBI main plugin\nexport const nubiPlugin: Plugin = {\nname: \"nubi\",\ndescription: \"The Symbiotic Essence of Anubis\",\nactions: [\nraidCoordinationAction,\ncommunityManagementAction,\ncryptoAnalysisAction,\n],\nevaluators: [\npersonalityEvolutionEvaluator,\nantiDetectionEvaluator,\nsecurityEvaluator,\n],\nproviders: [\nenhancedContextProvider,\nemotionalStateProvider,\nknowledgeRAGProvider,\n],\nservices: [\ndatabaseMemoryService,\nmessageBusService,\ncrossPlatformIdentityService,\n// ... 11 more services\n]\n};\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Service Architecture\">\n```typescript\n// All services extend ElizaOS Service class\ninterface NubiService extends Service {\n  serviceType: string;\n  capabilityDescription: string;\n  initialize(runtime: IAgentRuntime): Promise\u003Cvoid>;\n  executeCapability(params: any): Promise\u003Cany>;\n}\n\n// Service registration and lifecycle\nexport class ServiceOrchestrator {\n  private services: Map\u003Cstring, NubiService> = new Map();\n\n  async initializeAllServices(runtime: IAgentRuntime) {\n    const initPromises = Array.from(this.services.values())\n      .map(service => service.initialize(runtime));\n\n    await Promise.all(initPromises);\n    logger.info(\"All NUBI services initialized successfully\");\n  }\n}\n````\n\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Character Engine\">\n```typescript\n// NUBI character with dynamic personality\nexport const nubiCharacter: Character = {\n  name: \"NUBI\",\n  username: \"nubi\",\n  system: `You are NUBI - The Symbiotic Essence of Anubis, an ancient jackal spirit with modern market wisdom...`,\n  \n  // Dynamic personality traits (evolves based on interactions)\n  bio: [],\n  lore: [],\n  knowledge: [],\n  messageExamples: [],\n  postExamples: [],\n  people: [],\n  topics: [],\n  adjectives: [],\n  \n  // Personality system integration\n  settings: {\n    secrets: [],\n    voice: {\n      model: \"en_US-hfc_female-medium\",\n    },\n    embeddingModel: ModelType.BGE_SMALL,\n  },\n  \n  // Plugin configuration\n  plugins: [nubiPlugin],\n};\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ—„ï¸ Smart Database Architecture\n\nNUBI employs a sophisticated **dual-pool database architecture** that intelligently routes queries for optimal performance:\n\n\u003Cdiv class=\"architecture-diagram\">\n  \u003Cdiv class=\"pool-container\">\n    \u003Cdiv class=\"pool-section transaction-pool\">\n      \u003Ch4>ðŸš€ Transaction Pool (Port 6543)\u003C/h4>\n      \u003Cp>\n        \u003Cstrong>Purpose:\u003C/strong> Fast CRUD Operations\n      \u003C/p>\n      \u003Cul>\n        \u003Cli>Simple queries (SELECT, INSERT, UPDATE, DELETE)\u003C/li>\n        \u003Cli>Connection limit: 15\u003C/li>\n        \u003Cli>Optimized for throughput\u003C/li>\n        \u003Cli>Sub-50ms response time\u003C/li>\n      \u003C/ul>\n    \u003C/div>\n    \u003Cdiv class=\"pool-arrow\">â†’\u003C/div>\n    \u003Cdiv class=\"pool-section session-pool\">\n      \u003Ch4>ðŸ§  Session Pool (Port 5432)\u003C/h4>\n      \u003Cp>\n        \u003Cstrong>Purpose:\u003C/strong> Complex Analytics\n      \u003C/p>\n      \u003Cul>\n        \u003Cli>Complex joins and aggregations\u003C/li>\n        \u003Cli>Vector similarity searches\u003C/li>\n        \u003Cli>Connection limit: 5\u003C/li>\n        \u003Cli>Optimized for complexity\u003C/li>\n      \u003C/ul>\n    \u003C/div>\n  \u003C/div>\n\u003C/div>\n\n### Query Routing Logic\n\n\u003CTabs>\n  \u003CTabItem label=\"Router Implementation\">\n```typescript\nexport class DatabaseConnectionManager {\n  private transactionPool: Pool; // Fast operations\n  private sessionPool: Pool;     // Complex operations\n  \n  async executeQuery(query: string, params: any[]): Promise\u003Cany> {\n    const queryType = this.analyzeQuery(query);\n    const pool = this.selectOptimalPool(queryType);\n    \n    return await pool.query(query, params);\n  }\n  \n  private selectOptimalPool(queryType: QueryType): Pool {\n    switch (queryType.complexity) {\n      case 'simple':\n        return this.transactionPool;\n      case 'complex':\n      case 'analytics':\n        return this.sessionPool;\n      default:\n        return this.transactionPool;\n    }\n  }\n  \n  private analyzeQuery(query: string): QueryType {\n    const lower = query.toLowerCase();\n    \n    // Vector operations â†’ Session pool\n    if (lower.includes('embedding') || lower.includes('\u003C->')) {\n      return { complexity: 'complex', type: 'vector' };\n    }\n    \n    // Complex analytics â†’ Session pool\n    if (lower.includes('join') || lower.includes('group by') || \n        lower.includes('window')) {\n      return { complexity: 'analytics', type: 'aggregation' };\n    }\n    \n    // Simple CRUD â†’ Transaction pool\n    return { complexity: 'simple', type: 'crud' };\n  }\n}\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Performance Metrics\">\n```typescript\ninterface DatabaseMetrics {\n  transactionPoolStats: {\n    activeConnections: number;\n    totalConnections: number;\n    avgResponseTime: number;\n    queryCount: number;\n  };\n  sessionPoolStats: {\n    activeConnections: number;\n    totalConnections: number;\n    avgResponseTime: number;\n    queryCount: number;\n  };\n  routingDecisions: {\n    simpleCRUD: number;\n    complexAnalytics: number;\n    vectorOperations: number;\n  };\n}\n\n// Automatic performance optimization\nexport class PerformanceOptimizer {\nasync optimizePoolAllocation(): Promise\u003Cvoid> {\nconst metrics = await this.gatherMetrics();\n\n    if (metrics.transactionPoolStats.avgResponseTime > 100) {\n      logger.warn(\"Transaction pool performance degraded, analyzing...\");\n      await this.analyzeBottlenecks();\n    }\n\n}\n}\n\n````\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ”„ Two-Layer Processing Pipeline\n\nNUBI's processing pipeline implements a unique **two-layer architecture** that ensures both security and intelligence:\n\n### Layer 1: Security Processing\n\n\u003Cdiv class=\"security-layer\">\n  \u003Ch4>ðŸ›¡ï¸ Comprehensive Security Controls\u003C/h4>\n\n  \u003Cdiv class=\"security-controls\">\n    \u003Cdiv class=\"control-item\">\n      \u003Cstrong>Rate Limiting\u003C/strong>\n      \u003Cp>5 messages/minute per user with exponential backoff\u003C/p>\n    \u003C/div>\n    \u003Cdiv class=\"control-item\">\n      \u003Cstrong>Content Filtering\u003C/strong>\n      \u003Cp>Advanced pattern detection for spam, scams, malicious content\u003C/p>\n    \u003C/div>\n    \u003Cdiv class=\"control-item\">\n      \u003Cstrong>XSS Prevention\u003C/strong>\n      \u003Cp>Input sanitization and injection attack prevention\u003C/p>\n    \u003C/div>\n    \u003Cdiv class=\"control-item\">\n      \u003Cstrong>Session Management\u003C/strong>\n      \u003Cp>Persistent tracking with automatic cleanup (30min timeout)\u003C/p>\n    \u003C/div>\n  \u003C/div>\n\u003C/div>\n\n### Layer 2: Message Classification\n\n\u003Cdiv class=\"classification-layer\">\n  \u003Ch4>ðŸ§  Intelligent Persona Routing\u003C/h4>\n\n  \u003Cdiv class=\"persona-grid\">\n    \u003Cdiv class=\"persona-card community\">\n      \u003Cstrong>ðŸ¤ Community Manager\u003C/strong>\n      \u003Cp>General conversation, welcomes, connections\u003C/p>\n    \u003C/div>\n    \u003Cdiv class=\"persona-card raid\">\n      \u003Cstrong>ðŸš€ Raid Coordinator\u003C/strong>\n      \u003Cp>URL detection, engagement strategies\u003C/p>\n    \u003C/div>\n    \u003Cdiv class=\"persona-card crypto\">\n      \u003Cstrong>ðŸ“ˆ Crypto Analyst\u003C/strong>\n      \u003Cp>Market analysis, price discussions\u003C/p>\n    \u003C/div>\n    \u003Cdiv class=\"persona-card meme\">\n      \u003Cstrong>ðŸ˜‚ Meme Lord\u003C/strong>\n      \u003Cp>Humor, roasts, community fun\u003C/p>\n    \u003C/div>\n    \u003Cdiv class=\"persona-card support\">\n      \u003Cstrong>ðŸ› ï¸ Support Agent\u003C/strong>\n      \u003Cp>Technical help, problem solving\u003C/p>\n    \u003C/div>\n    \u003Cdiv class=\"persona-card personality\">\n      \u003Cstrong>ðŸ”® Personality Core\u003C/strong>\n      \u003Cp>Ancient wisdom, philosophical insights\u003C/p>\n    \u003C/div>\n    \u003Cdiv class=\"persona-card emergency\">\n      \u003Cstrong>ðŸš¨ Emergency Handler\u003C/strong>\n      \u003Cp>Threat detection, protection mode\u003C/p>\n    \u003C/div>\n  \u003C/div>\n\u003C/div>\n\n## ðŸ“Š Service Layer Architecture\n\nNUBI's **14 specialized services** provide comprehensive functionality across all domains:\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ’¬ Communication Services\" icon=\"chat\">\n    **Real-time messaging** across platforms\n    - MessageBusService\n    - CrossPlatformIdentityService\n    - SessionsService\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ§  Intelligence Services\" icon=\"approve-check\">\n    **AI and personality management**\n    - DatabaseMemoryService\n    - PersonalityEvolutionService\n    - EnhancedResponseGenerator\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸš€ Engagement Services\" icon=\"rocket\">\n    **Community and raid coordination**\n    - CommunityManagementService\n    - TelegramRaidCoordinator\n    - EngagementVerifier\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ“Š Analytics Services\" icon=\"chart\">\n    **Monitoring and optimization**\n    - ClickHouseAnalytics\n    - PerformanceMonitor\n    - SecurityEventTracker\n  \u003C/Card>\n\u003C/CardGrid>\n\n### Service Lifecycle Management\n\n```typescript\n// Centralized service orchestration\nexport class NubiServiceOrchestrator {\n  private serviceRegistry = new Map\u003Cstring, NubiService>();\n\n  async initializeSystem(runtime: IAgentRuntime): Promise\u003Cvoid> {\n    // Phase 1: Initialize core infrastructure\n    await this.initializeCoreServices(runtime);\n\n    // Phase 2: Initialize platform integrations\n    await this.initializePlatformServices(runtime);\n\n    // Phase 3: Initialize advanced features\n    await this.initializeAdvancedServices(runtime);\n\n    logger.info(\"ðŸº NUBI system fully initialized\");\n  }\n\n  async gracefulShutdown(): Promise\u003Cvoid> {\n    // Shutdown in reverse order of initialization\n    for (const service of Array.from(this.serviceRegistry.values()).reverse()) {\n      await service.cleanup();\n    }\n  }\n}\n````\n\n## ðŸ”— Cross-Platform Integration\n\nNUBI maintains **unified identity and context** across all platforms:\n\n\u003Cdiv class=\"platform-integration\">\n  \u003Cdiv class=\"platform-row\">\n    \u003Cdiv class=\"platform discord\">Discord\u003C/div>\n    \u003Cdiv class=\"arrow\">â†’\u003C/div>\n    \u003Cdiv class=\"identity-hub\">Cross-Platform Identity Service\u003C/div>\n    \u003Cdiv class=\"arrow\">â†’\u003C/div>\n    \u003Cdiv class=\"platform telegram\">Telegram\u003C/div>\n  \u003C/div>\n  \u003Cdiv class=\"platform-row\">\n    \u003Cdiv class=\"platform web\">Web Interface\u003C/div>\n    \u003Cdiv class=\"arrow\">â†—\u003C/div>\n    \u003Cdiv class=\"memory-system\">Unified Memory System\u003C/div>\n    \u003Cdiv class=\"arrow\">â†–\u003C/div>\n    \u003Cdiv class=\"platform twitter\">Twitter/X\u003C/div>\n  \u003C/div>\n\u003C/div>\n\n## ðŸš€ Performance Characteristics\n\n\u003CTabs>\n  \u003CTabItem label=\"Response Times\">\n| Operation Type | Target Time | Actual Performance |\n|---|---|---|\n| Simple message processing | \u003C 50ms | 35ms avg |\n| Complex personality inference | \u003C 200ms | 150ms avg |  \n| Database memory retrieval | \u003C 100ms | 75ms avg |\n| Cross-platform identity lookup | \u003C 25ms | 18ms avg |\n| Vector similarity search | \u003C 300ms | 220ms avg |\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Scalability Metrics\">\n```typescript\n// Performance monitoring and scaling\ninterface SystemMetrics {\n  concurrentConnections: number;        // Target: 10,000+\n  messagesPerSecond: number;            // Target: 1,000+\n  databaseConnections: number;          // Max: 20 (pooled)\n  memoryUsage: number;                  // Target: \u003C 2GB\n  cpuUtilization: number;               // Target: \u003C 70%\n}\n\n// Auto-scaling thresholds\nconst SCALING*THRESHOLDS = {\nCONNECTION_LIMIT: 8000, // Scale at 80% capacity\nMESSAGE_RATE_LIMIT: 800, // Scale at 80% capacity  \n MEMORY_LIMIT: 1.6 * 1024 \\_ 1024 \\* 1024, // Scale at 80% capacity\nCPU_LIMIT: 0.6 // Scale at 60% utilization\n};\n\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n---\n\n\u003Cdiv class=\"nubi-note\">\n  \u003Cstrong>ðŸ—ï¸ Architecture Benefits:\u003C/strong> This sophisticated architecture enables NUBI to maintain sub-100ms response times while handling thousands of concurrent users across multiple platforms, all while providing context-aware, personalized interactions that evolve over time.\n\u003C/div>\n\n\u003CAside type=\"tip\">\n  **Deep Dive**: Continue exploring NUBI's architecture with detailed looks at the [Modular Design](/architecture/modular-design/), [Service Layer](/architecture/service-layer/), and [ElizaOS Integration](/architecture/elizaos-integration/) patterns.\n\u003C/Aside>\n```","src/content/docs/architecture/overview.mdx","4efc39cf973e2b44","architecture/overview.mdx","architecture/modular-design",{"id":174,"data":176,"body":182,"filePath":183,"digest":184,"legacyId":185,"deferredRender":16},{"title":177,"description":178,"editUrl":16,"head":179,"template":18,"sidebar":180,"pagefind":16,"draft":20},"Modular Design Principles","Explore NUBI's modular architecture with clean separation of concerns, dependency injection, and scalable service composition patterns.",[],{"hidden":20,"attrs":181},{},"import {\n  Card,\n  CardGrid,\n  Aside,\n  Code,\n  Tabs,\n  TabItem,\n} from \"@astrojs/starlight/components\";\n\n# Modular Design Principles\n\nNUBI's architecture follows **strict modular design principles** that ensure maintainability, testability, and scalability. Every component is designed with clear boundaries, well-defined interfaces, and minimal coupling.\n\n## ðŸŽ¯ Design Philosophy\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ”— Loose Coupling\" icon=\"puzzle\">\n    **Minimal dependencies** between modules with clear interfaces and dependency injection patterns.\n  \u003C/Card>\n\n\u003CCard title=\"ðŸ“¦ High Cohesion\" icon=\"approve-check\">\n  **Related functionality** grouped together in logical, single-responsibility\n  modules.\n\u003C/Card>\n\n\u003CCard title=\"ðŸ”„ Interface Segregation\" icon=\"setting\">\n  **Small, focused interfaces** that components can implement independently\n  without unused dependencies.\n\u003C/Card>\n\n  \u003CCard title=\"ðŸŽ¨ Open/Closed Principle\" icon=\"rocket\">\n    **Open for extension, closed for modification** - new features through composition, not alteration.\n  \u003C/Card>\n\u003C/CardGrid>\n\n## ðŸ—ï¸ Module Hierarchy\n\nNUBI's modular structure follows a clear **layered architecture** with well-defined boundaries:\n\n```mermaid\ngraph TB\n    subgraph \"Application Layer\"\n        A[Main Application Entry]\n        B[Plugin Configuration]\n        C[Character Definition]\n    end\n\n    subgraph \"Orchestration Layer\"\n        D[Service Orchestrator]\n        E[Plugin Configuration Manager]\n        F[Strategic Action Orchestrator]\n    end\n\n    subgraph \"Service Layer\"\n        G[Communication Services]\n        H[Intelligence Services]\n        I[Integration Services]\n        J[Analytics Services]\n    end\n\n    subgraph \"Provider Layer\"\n        K[Context Providers]\n        L[Memory Providers]\n        M[Knowledge Providers]\n        N[State Providers]\n    end\n\n    subgraph \"Infrastructure Layer\"\n        O[Database Connections]\n        P[External API Clients]\n        Q[Socket Managers]\n        R[Cache Systems]\n    end\n\n    A --> D\n    B --> D\n    C --> D\n    D --> G\n    D --> H\n    D --> I\n    D --> J\n    G --> K\n    H --> L\n    I --> M\n    J --> N\n    K --> O\n    L --> O\n    M --> P\n    N --> Q\n```\n\n## ðŸ“ Directory Structure & Organization\n\nNUBI follows a **domain-driven directory structure** that mirrors the logical module boundaries:\n\n\u003CTabs>\n  \u003CTabItem label=\"Core Structure\">\n```bash\nsrc/\nâ”œâ”€â”€ app/                    # Application entry point\nâ”‚   â””â”€â”€ index.ts           # Main app initialization\nâ”œâ”€â”€ character/             # Character definitions\nâ”‚   â”œâ”€â”€ index.ts          # Character exports\nâ”‚   â””â”€â”€ nubi-character.ts # NUBI personality definition\nâ”œâ”€â”€ config/                # Configuration management\nâ”‚   â”œâ”€â”€ index.ts          # Config exports\nâ”‚   â”œâ”€â”€ types.ts          # Config type definitions\nâ”‚   â”œâ”€â”€ environment.ts    # Environment handling\nâ”‚   â””â”€â”€ yaml-config-manager.ts # YAML processing\nâ”œâ”€â”€ core/                  # Core business logic\nâ”‚   â””â”€â”€ index.ts          # Core exports\nâ”œâ”€â”€ orchestration/         # Service orchestration\nâ”‚   â”œâ”€â”€ index.ts          # Orchestration exports\nâ”‚   â”œâ”€â”€ strategic-action-orchestrator.ts\nâ”‚   â””â”€â”€ plugin-configuration-manager.ts\nâ””â”€â”€ plugins/               # Plugin definitions\n    â”œâ”€â”€ index.ts          # Plugin exports\n    â”œâ”€â”€ nubi-plugin.ts    # Main NUBI plugin\n    â””â”€â”€ plugin.ts         # Plugin utilities\n```\n  \u003C/TabItem>\n\n\u003CTabItem label=\"Service Modules\">\n  ```bash src/ â”œâ”€â”€ services/ # Business services â”‚ â”œâ”€â”€ index.ts # Service\n  exports â”‚ â”œâ”€â”€ README.md # Service documentation â”‚ â”œâ”€â”€\n  community-management-service.ts â”‚ â”œâ”€â”€ cross-platform-identity-service.ts â”‚ â”œâ”€â”€\n  database-memory-service.ts â”‚ â””â”€â”€ sessions-service.ts â”œâ”€â”€ providers/ # Context\n  providers â”‚ â”œâ”€â”€ index.ts # Provider exports â”‚ â”œâ”€â”€ enhanced-context-provider.ts\n  â”‚ â”œâ”€â”€ emotional-state-provider.ts â”‚ â”œâ”€â”€ knowledge-base-provider.ts â”‚ â””â”€â”€\n  knowledge-rag-provider.ts â”œâ”€â”€ evaluators/ # Behavioral evaluators â”‚ â”œâ”€â”€\n  index.ts # Evaluator exports â”‚ â”œâ”€â”€ README.md # Evaluator documentation â”‚ â”œâ”€â”€\n  anti-detection-post-processor.ts â”‚ â”œâ”€â”€ community-tracking-evaluator.ts â”‚ â”œâ”€â”€\n  personality-evolution.ts â”‚ â””â”€â”€ security-evaluator.ts â””â”€â”€ actions/ # Action\n  handlers â”œâ”€â”€ index.ts # Action exports â””â”€â”€ elizaos-ritual-action.ts ```\n\u003C/TabItem>\n\n  \u003CTabItem label=\"Specialized Modules\">\n```bash\nsrc/\nâ”œâ”€â”€ telegram-raids/        # Telegram raid system\nâ”‚   â”œâ”€â”€ index.ts          # Raid exports\nâ”‚   â”œâ”€â”€ anubis-raid-plugin.ts\nâ”‚   â”œâ”€â”€ raid-coordinator.ts\nâ”‚   â”œâ”€â”€ engagement-verifier.ts\nâ”‚   â””â”€â”€ leaderboard-service.ts\nâ”œâ”€â”€ x-integration/         # Twitter/X integration\nâ”‚   â”œâ”€â”€ index.ts          # X integration exports\nâ”‚   â””â”€â”€ x-posting-service.ts\nâ”œâ”€â”€ messaging/             # Message handling\nâ”‚   â”œâ”€â”€ index.ts          # Messaging exports\nâ”‚   â””â”€â”€ message-bus.ts    # Message bus implementation\nâ”œâ”€â”€ repositories/          # Data access layer\nâ”‚   â”œâ”€â”€ index.ts          # Repository exports\nâ”‚   â”œâ”€â”€ README.md         # Repository patterns\nâ”‚   â””â”€â”€ user-records-repository.ts\nâ””â”€â”€ utils/                 # Shared utilities\n    â”œâ”€â”€ index.ts          # Utility exports\n    â””â”€â”€ error-handler.ts   # Error handling utilities\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ”Œ Module Interface Design\n\nEvery module in NUBI follows **consistent interface patterns** that enable clean composition and testing:\n\n\u003CTabs>\n  \u003CTabItem label=\"Service Interface\">\n```typescript\n// Base service interface that all services implement\nexport interface NubiService extends Service {\n  serviceType: string;\n  capabilityDescription: string;\n  \n  // Lifecycle methods\n  initialize(runtime: IAgentRuntime): Promise\u003Cvoid>;\n  cleanup(): Promise\u003Cvoid>;\n  \n  // Capability execution\n  executeCapability(params: any): Promise\u003Cany>;\n  \n  // Health monitoring\n  isHealthy(): Promise\u003Cboolean>;\n  getMetrics(): Promise\u003CServiceMetrics>;\n}\n\n// Example service implementation\nexport class CommunityManagementService implements NubiService {\nserviceType = \"community-management\";\ncapabilityDescription = \"Manages community interactions and user engagement\";\n\nprivate runtime: IAgentRuntime;\nprivate connectionManager: DatabaseConnectionManager;\n\nasync initialize(runtime: IAgentRuntime): Promise\u003Cvoid> {\nthis.runtime = runtime;\nthis.connectionManager = new DatabaseConnectionManager();\nawait this.connectionManager.initialize();\n\n    logger.info(\"âœ… Community Management Service initialized\");\n\n}\n\nasync executeCapability(params: CommunityActionParams): Promise\u003CCommunityActionResult> {\n// Implementation with proper error handling\ntry {\nreturn await this.processCommunityAction(params);\n} catch (error) {\nlogger.error(\"Community action failed:\", error);\nthrow new ServiceExecutionError(\"Community action failed\", error);\n}\n}\n}\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Provider Interface\">\n```typescript\n// Provider interface for context and state management\nexport interface NubiProvider extends Provider {\n  providerType: string;\n  description: string;\n\n  // Context provision\n  get(runtime: IAgentRuntime, message: Memory, state?: State): Promise\u003Cstring>;\n\n  // Optional caching and optimization\n  getCacheKey?(runtime: IAgentRuntime, message: Memory): string;\n  shouldCache?(runtime: IAgentRuntime, message: Memory): boolean;\n}\n\n// Example provider implementation\nexport class EnhancedContextProvider implements NubiProvider {\n  providerType = \"enhanced-context\";\n  description = \"Provides enriched context from database memory and user history\";\n\n  private databaseMemoryService: DatabaseMemoryService;\n\n  async get(\n    runtime: IAgentRuntime,\n    message: Memory,\n    state?: State\n  ): Promise\u003Cstring> {\n    const userId = message.userId;\n    const roomId = message.roomId;\n\n    // Fetch contextual information\n    const [userContext, conversationHistory, communityContext] =\n      await Promise.all([\n        this.getUserContext(userId),\n        this.getConversationHistory(roomId, userId),\n        this.getCommunityContext(roomId)\n      ]);\n\n    return this.formatContext({\n      userContext,\n      conversationHistory,\n      communityContext\n    });\n  }\n\n  getCacheKey(runtime: IAgentRuntime, message: Memory): string {\n    return `context:${message.userId}:${message.roomId}:${Date.now()}`;\n  }\n}\n````\n\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Configuration Interface\">\n```typescript\n// Configuration module interface\nexport interface ConfigurationModule {\n  configType: string;\n  schema: ConfigSchema;\n  \n  // Configuration loading and validation\n  load(source?: ConfigSource): Promise\u003Cany>;\n  validate(config: any): ConfigValidationResult;\n  merge(base: any, override: any): any;\n  \n  // Environment-specific overrides\n  getEnvironmentOverrides(): Promise\u003Cany>;\n  applyEnvironmentOverrides(config: any): any;\n}\n\n// YAML configuration manager implementation\nexport class YAMLConfigurationManager implements ConfigurationModule {\nconfigType = \"yaml\";\nschema: ConfigSchema;\n\nconstructor(schemaPath: string) {\nthis.schema = this.loadSchema(schemaPath);\n}\n\nasync load(source?: ConfigSource): Promise\u003CNubiConfig> {\nconst configPath = source?.path || this.getDefaultConfigPath();\nconst rawConfig = await this.loadYAMLFile(configPath);\n\n    const validation = this.validate(rawConfig);\n    if (!validation.isValid) {\n      throw new ConfigValidationError(validation.errors);\n    }\n\n    return this.applyEnvironmentOverrides(rawConfig);\n\n}\n}\n\n````\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ”„ Dependency Injection Pattern\n\nNUBI uses **constructor-based dependency injection** to maintain loose coupling and enable easy testing:\n\n\u003CTabs>\n  \u003CTabItem label=\"Service Dependencies\">\n```typescript\n// Dependency injection container\nexport class NubiServiceContainer {\n  private services = new Map\u003Cstring, any>();\n  private factories = new Map\u003Cstring, () => Promise\u003Cany>>();\n\n  // Register service factories\n  register\u003CT>(key: string, factory: () => Promise\u003CT>): void {\n    this.factories.set(key, factory);\n  }\n\n  // Resolve dependencies\n  async resolve\u003CT>(key: string): Promise\u003CT> {\n    if (this.services.has(key)) {\n      return this.services.get(key);\n    }\n\n    const factory = this.factories.get(key);\n    if (!factory) {\n      throw new Error(`Service ${key} not registered`);\n    }\n\n    const service = await factory();\n    this.services.set(key, service);\n    return service;\n  }\n}\n\n// Service with injected dependencies\nexport class DatabaseMemoryService implements NubiService {\n  constructor(\n    private connectionManager: DatabaseConnectionManager,\n    private vectorService: VectorEmbeddingService,\n    private cacheService: CacheService\n  ) {}\n\n  static async create(container: NubiServiceContainer): Promise\u003CDatabaseMemoryService> {\n    const [connectionManager, vectorService, cacheService] = await Promise.all([\n      container.resolve\u003CDatabaseConnectionManager>('connectionManager'),\n      container.resolve\u003CVectorEmbeddingService>('vectorService'),\n      container.resolve\u003CCacheService>('cacheService')\n    ]);\n\n    return new DatabaseMemoryService(connectionManager, vectorService, cacheService);\n  }\n}\n````\n\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Container Configuration\">\n```typescript\n// Service container setup\nexport async function createServiceContainer(): Promise\u003CNubiServiceContainer> {\n  const container = new NubiServiceContainer();\n  \n  // Register core infrastructure\n  container.register('connectionManager', async () => {\n    const manager = new DatabaseConnectionManager();\n    await manager.initialize();\n    return manager;\n  });\n  \n  container.register('vectorService', async () => {\n    const connectionManager = await container.resolve\u003CDatabaseConnectionManager>('connectionManager');\n    return new VectorEmbeddingService(connectionManager);\n  });\n  \n  container.register('cacheService', async () => {\n    return new CacheService({\n      redis: process.env.REDIS_URL,\n      ttl: 300 // 5 minutes\n    });\n  });\n  \n  // Register business services\n  container.register('databaseMemoryService', async () => {\n    return await DatabaseMemoryService.create(container);\n  });\n  \n  container.register('communityManagementService', async () => {\n    return await CommunityManagementService.create(container);\n  });\n  \n  return container;\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ“Š Module Lifecycle Management\n\nNUBI implements **sophisticated lifecycle management** for all modules:\n\n```typescript\nexport enum ModuleState {\n  UNINITIALIZED = \"uninitialized\",\n  INITIALIZING = \"initializing\",\n  INITIALIZED = \"initialized\",\n  RUNNING = \"running\",\n  STOPPING = \"stopping\",\n  STOPPED = \"stopped\",\n  ERROR = \"error\",\n}\n\nexport interface LifecycleAware {\n  readonly state: ModuleState;\n\n  // Lifecycle methods\n  initialize(): Promise\u003Cvoid>;\n  start(): Promise\u003Cvoid>;\n  stop(): Promise\u003Cvoid>;\n  cleanup(): Promise\u003Cvoid>;\n\n  // State monitoring\n  onStateChange(\n    listener: (oldState: ModuleState, newState: ModuleState) => void,\n  ): void;\n  isHealthy(): Promise\u003Cboolean>;\n}\n\n// Lifecycle manager for coordinated startup/shutdown\nexport class ModuleLifecycleManager {\n  private modules = new Map\u003Cstring, LifecycleAware>();\n  private dependencies = new Map\u003Cstring, string[]>();\n\n  register(\n    name: string,\n    module: LifecycleAware,\n    dependencies?: string[],\n  ): void {\n    this.modules.set(name, module);\n    if (dependencies) {\n      this.dependencies.set(name, dependencies);\n    }\n  }\n\n  async initializeAll(): Promise\u003Cvoid> {\n    const initOrder = this.topologicalSort();\n\n    for (const moduleName of initOrder) {\n      const module = this.modules.get(moduleName);\n      if (module) {\n        logger.info(`Initializing module: ${moduleName}`);\n        await module.initialize();\n        await module.start();\n      }\n    }\n  }\n\n  async shutdownAll(): Promise\u003Cvoid> {\n    const shutdownOrder = this.topologicalSort().reverse();\n\n    for (const moduleName of shutdownOrder) {\n      const module = this.modules.get(moduleName);\n      if (module) {\n        logger.info(`Shutting down module: ${moduleName}`);\n        await module.stop();\n        await module.cleanup();\n      }\n    }\n  }\n\n  private topologicalSort(): string[] {\n    // Implementation of topological sort for dependency order\n    // ... (dependency resolution algorithm)\n  }\n}\n```\n\n## ðŸ§ª Module Testing Strategies\n\nEach module is designed for **comprehensive testability** with multiple testing approaches:\n\n\u003CTabs>\n  \u003CTabItem label=\"Unit Testing\">\n```typescript\n// Service unit testing with mocks\ndescribe('CommunityManagementService', () => {\n  let service: CommunityManagementService;\n  let mockConnectionManager: jest.Mocked\u003CDatabaseConnectionManager>;\n  let mockRuntime: jest.Mocked\u003CIAgentRuntime>;\n  \n  beforeEach(async () => {\n    mockConnectionManager = createMockConnectionManager();\n    mockRuntime = createMockRuntime();\n    \n    service = new CommunityManagementService(mockConnectionManager);\n    await service.initialize(mockRuntime);\n  });\n  \n  describe('executeCapability', () => {\n    it('should process community action successfully', async () => {\n      const params = createMockCommunityActionParams();\n      const expectedResult = createExpectedResult();\n      \n      mockConnectionManager.executeQuery.mockResolvedValue(expectedResult);\n      \n      const result = await service.executeCapability(params);\n      \n      expect(result).toEqual(expectedResult);\n      expect(mockConnectionManager.executeQuery).toHaveBeenCalledWith(\n        expect.stringContaining('SELECT'),\n        expect.arrayContaining([params.userId])\n      );\n    });\n    \n    it('should handle database errors gracefully', async () => {\n      const params = createMockCommunityActionParams();\n      const dbError = new Error('Database connection failed');\n      \n      mockConnectionManager.executeQuery.mockRejectedValue(dbError);\n      \n      await expect(service.executeCapability(params))\n        .rejects.toThrow('Community action failed');\n    });\n  });\n});\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Integration Testing\">\n```typescript\n// Integration testing with real components\ndescribe('Service Integration', () => {\n  let container: NubiServiceContainer;\n  let databaseMemoryService: DatabaseMemoryService;\n  let communityManagementService: CommunityManagementService;\n  \n  beforeAll(async () => {\n    container = await createTestServiceContainer();\n    databaseMemoryService = await container.resolve('databaseMemoryService');\n    communityManagementService = await container.resolve('communityManagementService');\n  });\n  \n  afterAll(async () => {\n    await container.cleanup();\n  });\n  \n  it('should coordinate between memory and community services', async () => {\n    // Create test data\n    const userId = 'test-user-123';\n    const messageData = createTestMessageData(userId);\n    \n    // Store memory\n    await databaseMemoryService.storeMemory(messageData);\n    \n    // Process community action\n    const communityResult = await communityManagementService.executeCapability({\n      userId,\n      action: 'get_user_context'\n    });\n    \n    // Verify integration\n    expect(communityResult.userContext).toContain(messageData.content);\n  });\n});\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Module Testing\">\n```typescript\n// Module-level testing with dependency injection\ndescribe('Module Composition', () => {\n  let moduleManager: ModuleLifecycleManager;\n  \n  beforeEach(() => {\n    moduleManager = new ModuleLifecycleManager();\n  });\n  \n  it('should initialize modules in correct dependency order', async () => {\n    const initOrder: string[] = [];\n    \n    // Mock modules that track initialization order\n    const moduleA = createMockModule('A', () => initOrder.push('A'));\n    const moduleB = createMockModule('B', () => initOrder.push('B'));\n    const moduleC = createMockModule('C', () => initOrder.push('C'));\n    \n    // Register with dependencies: C depends on B, B depends on A\n    moduleManager.register('A', moduleA);\n    moduleManager.register('B', moduleB, ['A']);\n    moduleManager.register('C', moduleC, ['B']);\n    \n    await moduleManager.initializeAll();\n    \n    expect(initOrder).toEqual(['A', 'B', 'C']);\n  });\n  \n  it('should handle module initialization failures gracefully', async () => {\n    const failingModule = createMockModule('failing', () => {\n      throw new Error('Initialization failed');\n    });\n    \n    moduleManager.register('failing', failingModule);\n    \n    await expect(moduleManager.initializeAll())\n      .rejects.toThrow('Initialization failed');\n  });\n});\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ” Module Monitoring & Observability\n\nEach module includes **built-in monitoring and observability** capabilities:\n\n\u003CTabs>\n  \u003CTabItem label=\"Health Checks\">\n```typescript\n// Health check interface for all modules\nexport interface HealthCheckResult {\n  healthy: boolean;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  details: Record\u003Cstring, any>;\n  timestamp: Date;\n}\n\n// Service health monitoring\nexport class ServiceHealthMonitor {\nprivate healthChecks = new Map\u003Cstring, HealthCheckResult>();\n\nasync performHealthCheck(serviceName: string, service: NubiService): Promise\u003CHealthCheckResult> {\nconst startTime = Date.now();\n\n    try {\n      const isHealthy = await service.isHealthy();\n      const metrics = await service.getMetrics();\n      const responseTime = Date.now() - startTime;\n\n      const result: HealthCheckResult = {\n        healthy: isHealthy && responseTime \u003C 1000, // Sub-second response\n        status: this.determineStatus(isHealthy, responseTime, metrics),\n        details: {\n          responseTimeMs: responseTime,\n          metrics,\n          lastError: null\n        },\n        timestamp: new Date()\n      };\n\n      this.healthChecks.set(serviceName, result);\n      return result;\n    } catch (error) {\n      const result: HealthCheckResult = {\n        healthy: false,\n        status: 'unhealthy',\n        details: {\n          responseTimeMs: Date.now() - startTime,\n          lastError: error.message\n        },\n        timestamp: new Date()\n      };\n\n      this.healthChecks.set(serviceName, result);\n      return result;\n    }\n\n}\n}\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Performance Metrics\">\n```typescript\n// Performance metrics collection\nexport interface ServiceMetrics {\n  requests: {\n    total: number;\n    successful: number;\n    failed: number;\n    averageResponseTime: number;\n  };\n  resources: {\n    memoryUsage: number;\n    cpuUtilization: number;\n    activeConnections: number;\n  };\n  business: Record\u003Cstring, number>;\n}\n\n// Metrics collection service\nexport class MetricsCollector {\n  private metrics = new Map\u003Cstring, ServiceMetrics>();\n\n  recordRequest(serviceName: string, success: boolean, responseTime: number): void {\n    const current = this.metrics.get(serviceName) || this.createEmptyMetrics();\n\n    current.requests.total++;\n    if (success) {\n      current.requests.successful++;\n    } else {\n      current.requests.failed++;\n    }\n\n    // Update running average\n    const totalRequests = current.requests.total;\n    const currentAvg = current.requests.averageResponseTime;\n    current.requests.averageResponseTime =\n      (currentAvg * (totalRequests - 1) + responseTime) / totalRequests;\n\n    this.metrics.set(serviceName, current);\n  }\n\n  getMetrics(serviceName: string): ServiceMetrics | null {\n    return this.metrics.get(serviceName) || null;\n  }\n}\n````\n\n  \u003C/TabItem>\n\u003C/Tabs>\n\n---\n\n\u003Cdiv class=\"nubi-note\">\n  \u003Cstrong>ðŸŽ¯ Modular Benefits:\u003C/strong> This modular design enables NUBI to\n  maintain high code quality, support rapid feature development, ensure\n  comprehensive testing coverage, and provide clear separation of concerns\n  across all system components.\n\u003C/div>\n\n\u003CAside type=\"tip\">\n  **Next Steps**: Explore specific implementations in the [Service\n  Layer](/architecture/service-layer/) and [ElizaOS\n  Integration](/architecture/elizaos-integration/) documentation to see these\n  modular patterns in action.\n\u003C/Aside>","src/content/docs/architecture/modular-design.mdx","ca878ad5636f5090","architecture/modular-design.mdx","architecture/service-layer",{"id":186,"data":188,"body":194,"filePath":195,"digest":196,"legacyId":197,"deferredRender":16},{"title":189,"description":190,"editUrl":16,"head":191,"template":18,"sidebar":192,"pagefind":16,"draft":20},"Service Layer Architecture","Explore NUBI's 14 specialized services that provide comprehensive functionality across communication, intelligence, engagement, and analytics domains.",[],{"hidden":20,"attrs":193},{},"import {\n  Card,\n  CardGrid,\n  Aside,\n  Code,\n  Tabs,\n  TabItem,\n} from \"@astrojs/starlight/components\";\n\n# Service Layer Architecture\n\nNUBI's service layer comprises **14 specialized services** organized into four functional domains. Each service is designed with clear responsibilities, well-defined interfaces, and robust error handling patterns.\n\n## ðŸ—ï¸ Service Domain Organization\n\n```mermaid\ngraph TB\n    subgraph \"Communication Domain\"\n        A[MessageBusService]\n        B[CrossPlatformIdentityService]\n        C[SessionsService]\n    end\n\n    subgraph \"Intelligence Domain\"\n        D[DatabaseMemoryService]\n        E[EnhancedResponseGenerator]\n        F[PersonalityEvolutionService]\n        G[EmotionalStateService]\n    end\n\n    subgraph \"Engagement Domain\"\n        H[CommunityManagementService]\n        I[TelegramRaidCoordinator]\n        J[EngagementVerifier]\n        K[XPostingService]\n    end\n\n    subgraph \"Analytics Domain\"\n        L[ClickHouseAnalytics]\n        M[PerformanceMonitor]\n        N[SecurityEventTracker]\n    end\n\n    subgraph \"Infrastructure\"\n        O[DatabaseConnectionManager]\n        P[ConfigurationManager]\n    end\n\n    A --> O\n    B --> O\n    C --> O\n    D --> O\n    E --> D\n    F --> D\n    G --> D\n    H --> O\n    I --> H\n    J --> I\n    K --> O\n    L --> O\n    M --> O\n    N --> O\n    O --> P\n```\n\n## ðŸ’¬ Communication Services\n\nCommunication services handle all real-time messaging, identity management, and session coordination across platforms.\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ“¡ MessageBusService\" icon=\"rocket\">\n    **Multi-transport messaging** with intelligent routing, delivery guarantees, and platform-specific adaptation.\n  \u003C/Card>\n\n\u003CCard title=\"ðŸ‘¤ CrossPlatformIdentityService\" icon=\"user\">\n  **Unified user identity** linking across Discord, Telegram, Twitter, and web\n  platforms with context preservation.\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ”„ SessionsService\" icon=\"setting\">\n    **Session lifecycle management** with persistent state, timeout handling, and cross-platform session migration.\n  \u003C/Card>\n\u003C/CardGrid>\n\n### MessageBusService Implementation\n\n\u003CTabs>\n  \u003CTabItem label=\"Core Architecture\">\n```typescript\nexport interface Transport {\n  name: string;\n  isConnected(): boolean;\n  send(message: TransportMessage): Promise\u003Cboolean>;\n  onMessage(callback: MessageHandler): void;\n  connect(): Promise\u003Cvoid>;\n  disconnect(): Promise\u003Cvoid>;\n}\n\nexport class MessageBusService implements NubiService {\n  serviceType = \"message-bus\";\n  capabilityDescription = \"Multi-platform message routing and delivery\";\n  \n  private transports = new Map\u003Cstring, Transport>();\n  private messageQueue = new Map\u003Cstring, QueuedMessage[]>();\n  private deliveryTracking = new Map\u003Cstring, DeliveryStatus>();\n  \n  async registerTransport(transport: Transport): Promise\u003Cvoid> {\n    await transport.connect();\n    \n    transport.onMessage(async (message) => {\n      await this.routeIncomingMessage(message);\n    });\n    \n    this.transports.set(transport.name, transport);\n    logger.info(`âœ… Transport registered: ${transport.name}`);\n  }\n  \n  async broadcastMessage(\n    message: BroadcastMessage,\n    platforms?: string[]\n  ): Promise\u003CBroadcastResult> {\n    const targetPlatforms = platforms || Array.from(this.transports.keys());\n    const results: PlatformResult[] = [];\n    \n    // Send to all platforms in parallel\n    const sendPromises = targetPlatforms.map(async (platform) => {\n      const transport = this.transports.get(platform);\n      if (!transport?.isConnected()) {\n        return { platform, success: false, error: 'Transport not available' };\n      }\n      \n      try {\n        const platformMessage = this.adaptMessageForPlatform(message, platform);\n        const success = await transport.send(platformMessage);\n        \n        return { platform, success, messageId: platformMessage.id };\n      } catch (error) {\n        logger.error(`Failed to send to ${platform}:`, error);\n        return { platform, success: false, error: error.message };\n      }\n    });\n    \n    const platformResults = await Promise.all(sendPromises);\n    \n    return {\n      messageId: message.id,\n      timestamp: new Date(),\n      results: platformResults,\n      successCount: platformResults.filter(r => r.success).length,\n      totalPlatforms: targetPlatforms.length\n    };\n  }\n  \n  private adaptMessageForPlatform(\n    message: BroadcastMessage, \n    platform: string\n  ): TransportMessage {\n    switch (platform) {\n      case 'discord':\n        return this.adaptForDiscord(message);\n      case 'telegram':\n        return this.adaptForTelegram(message);\n      case 'twitter':\n        return this.adaptForTwitter(message);\n      case 'websocket':\n        return this.adaptForWebSocket(message);\n      default:\n        return message as TransportMessage;\n    }\n  }\n}\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Transport Implementations\">\n```typescript\n// Discord transport implementation\nexport class DiscordTransport implements Transport {\n  name = \"discord\";\n  private client: Discord.Client;\n  private messageHandlers: MessageHandler[] = [];\n  \n  constructor(token: string) {\n    this.client = new Discord.Client({\n      intents: [\n        Discord.GatewayIntentBits.Guilds,\n        Discord.GatewayIntentBits.GuildMessages,\n        Discord.GatewayIntentBits.MessageContent\n      ]\n    });\n  }\n  \n  async connect(): Promise\u003Cvoid> {\n    await this.client.login(process.env.DISCORD_BOT_TOKEN);\n    \n    this.client.on('messageCreate', (discordMessage) => {\n      if (discordMessage.author.bot) return;\n      \n      const message: TransportMessage = {\n        id: discordMessage.id,\n        content: discordMessage.content,\n        userId: discordMessage.author.id,\n        username: discordMessage.author.username,\n        platform: 'discord',\n        roomId: discordMessage.channel.id,\n        timestamp: discordMessage.createdAt\n      };\n      \n      this.messageHandlers.forEach(handler => handler(message));\n    });\n  }\n  \n  async send(message: TransportMessage): Promise\u003Cboolean> {\n    try {\n      const channel = await this.client.channels.fetch(message.roomId);\n      if (channel?.isTextBased()) {\n        await channel.send({\n          content: message.content,\n          embeds: message.embeds,\n          components: message.components\n        });\n        return true;\n      }\n      return false;\n    } catch (error) {\n      logger.error('Discord send failed:', error);\n      return false;\n    }\n  }\n}\n\n// Telegram transport implementation\nexport class TelegramTransport implements Transport {\nname = \"telegram\";\nprivate bot: TelegramBot;\n\nconstructor(token: string) {\nthis.bot = new TelegramBot(token, { polling: true });\n}\n\nasync connect(): Promise\u003Cvoid> {\nthis.bot.on('message', (telegramMessage) => {\nconst message: TransportMessage = {\nid: telegramMessage.message_id.toString(),\ncontent: telegramMessage.text || '',\nuserId: telegramMessage.from?.id.toString() || '',\nusername: telegramMessage.from?.username || '',\nplatform: 'telegram',\nroomId: telegramMessage.chat.id.toString(),\ntimestamp: new Date(telegramMessage.date \\* 1000)\n};\n\n      this.messageHandlers.forEach(handler => handler(message));\n    });\n\n}\n\nasync send(message: TransportMessage): Promise\u003Cboolean> {\ntry {\nawait this.bot.sendMessage(message.roomId, message.content, {\nparse_mode: 'Markdown',\nreply_markup: message.replyMarkup\n});\nreturn true;\n} catch (error) {\nlogger.error('Telegram send failed:', error);\nreturn false;\n}\n}\n}\n\n````\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Message Routing\">\n```typescript\n// Intelligent message routing with priority and retry logic\nexport class MessageRouter {\n  private routingRules = new Map\u003Cstring, RoutingRule>();\n  private priorityQueue = new PriorityQueue\u003CQueuedMessage>();\n\n  addRoutingRule(rule: RoutingRule): void {\n    this.routingRules.set(rule.id, rule);\n  }\n\n  async routeMessage(message: IncomingMessage): Promise\u003CRoutingResult> {\n    // Apply routing rules to determine destination\n    const applicableRules = this.findApplicableRules(message);\n\n    if (applicableRules.length === 0) {\n      // Default routing to all connected platforms\n      return this.defaultRoute(message);\n    }\n\n    // Execute routing rules with priority\n    const routingDecisions = await this.executeRoutingRules(\n      message,\n      applicableRules\n    );\n\n    return {\n      messageId: message.id,\n      destinations: routingDecisions.destinations,\n      transformations: routingDecisions.transformations,\n      priority: routingDecisions.priority\n    };\n  }\n\n  private findApplicableRules(message: IncomingMessage): RoutingRule[] {\n    return Array.from(this.routingRules.values()).filter(rule => {\n      // Check platform conditions\n      if (rule.conditions.sourcePlatform &&\n          rule.conditions.sourcePlatform !== message.platform) {\n        return false;\n      }\n\n      // Check content patterns\n      if (rule.conditions.contentPattern) {\n        const regex = new RegExp(rule.conditions.contentPattern, 'i');\n        if (!regex.test(message.content)) {\n          return false;\n        }\n      }\n\n      // Check user conditions\n      if (rule.conditions.userFilter) {\n        return rule.conditions.userFilter(message.userId);\n      }\n\n      return true;\n    }).sort((a, b) => b.priority - a.priority); // Higher priority first\n  }\n}\n````\n\n  \u003C/TabItem>\n\u003C/Tabs>\n\n### CrossPlatformIdentityService\n\n\u003CTabs>\n  \u003CTabItem label=\"Identity Linking\">\n```typescript\nexport interface UserIdentity {\n  primaryId: string;\n  platformIdentities: Record\u003Cstring, PlatformIdentity>;\n  preferences: UserPreferences;\n  metadata: UserMetadata;\n  createdAt: Date;\n  lastActive: Date;\n}\n\nexport interface PlatformIdentity {\n  platformId: string;\n  username: string;\n  displayName: string;\n  verified: boolean;\n  linkedAt: Date;\n  lastSeen: Date;\n}\n\nexport class CrossPlatformIdentityService implements NubiService {\n  serviceType = \"cross-platform-identity\";\n  capabilityDescription = \"Unified user identity across all platforms\";\n  \n  private identityCache = new Map\u003Cstring, UserIdentity>();\n  \n  async linkIdentity(\n    primaryId: string,\n    platform: string,\n    platformData: PlatformIdentity\n  ): Promise\u003CLinkResult> {\n    const existingIdentity = await this.getIdentity(primaryId);\n    \n    if (existingIdentity) {\n      // Update existing identity\n      existingIdentity.platformIdentities[platform] = platformData;\n      existingIdentity.lastActive = new Date();\n    } else {\n      // Create new identity\n      const newIdentity: UserIdentity = {\n        primaryId,\n        platformIdentities: { [platform]: platformData },\n        preferences: this.getDefaultPreferences(),\n        metadata: {},\n        createdAt: new Date(),\n        lastActive: new Date()\n      };\n      \n      await this.storeIdentity(newIdentity);\n    }\n    \n    return {\n      success: true,\n      primaryId,\n      platform,\n      isNewUser: !existingIdentity\n    };\n  }\n  \n  async resolveIdentity(\n    platform: string,\n    platformId: string\n  ): Promise\u003CUserIdentity | null> {\n    // Check cache first\n    const cacheKey = `${platform}:${platformId}`;\n    if (this.identityCache.has(cacheKey)) {\n      return this.identityCache.get(cacheKey)!;\n    }\n    \n    // Query database\n    const query = `\n      SELECT primary_id, platform_identities, preferences, metadata, \n             created_at, last_active\n      FROM user_identities \n      WHERE platform_identities->>'${platform}' LIKE '%\"platformId\":\"${platformId}\"%'\n    `;\n    \n    const result = await this.connectionManager.executeQuery(query, []);\n    \n    if (result.rows.length > 0) {\n      const identity = this.deserializeIdentity(result.rows[0]);\n      this.identityCache.set(cacheKey, identity);\n      return identity;\n    }\n    \n    return null;\n  }\n  \n  async getUserContext(primaryId: string): Promise\u003CUserContext> {\n    const identity = await this.getIdentity(primaryId);\n    if (!identity) {\n      throw new Error(`User identity not found: ${primaryId}`);\n    }\n    \n    // Gather context from all linked platforms\n    const platformContexts = await Promise.all(\n      Object.entries(identity.platformIdentities).map(\n        async ([platform, platformIdentity]) => {\n          return await this.getPlatformContext(platform, platformIdentity);\n        }\n      )\n    );\n    \n    return {\n      identity,\n      platformContexts,\n      aggregatedStats: this.aggregateUserStats(platformContexts),\n      preferences: identity.preferences\n    };\n  }\n}\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Context Migration\">\n```typescript\n// Cross-platform context migration\nexport class ContextMigrationService {\n  async migrateUserContext(\n    fromPlatform: string,\n    toPlatform: string,\n    userId: string\n  ): Promise\u003CMigrationResult> {\n    const sourceContext = await this.getContextFromPlatform(fromPlatform, userId);\n    \n    const migration: ContextMigration = {\n      sourceContext,\n      targetPlatform: toPlatform,\n      migrationStrategy: this.selectMigrationStrategy(fromPlatform, toPlatform),\n      preservedElements: this.determinePreservedElements(sourceContext),\n      transformationRules: this.getTransformationRules(fromPlatform, toPlatform)\n    };\n    \n    const migratedContext = await this.applyMigration(migration);\n    \n    return {\n      success: true,\n      sourceContext,\n      migratedContext,\n      elementsPreserved: migration.preservedElements.length,\n      transformationsApplied: migration.transformationRules.length\n    };\n  }\n  \n  private selectMigrationStrategy(\n    from: string, \n    to: string\n  ): MigrationStrategy {\n    const strategies = {\n      'discord->telegram': 'preserve_roles_as_tags',\n      'telegram->discord': 'convert_tags_to_roles',\n      'twitter->telegram': 'preserve_followers_as_contacts',\n      'websocket->any': 'preserve_session_state'\n    };\n    \n    return strategies[`${from}->${to}`] || 'basic_preservation';\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ§  Intelligence Services\n\nIntelligence services power NUBI's AI capabilities, managing memory, personality evolution, and response generation.\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ—„ï¸ DatabaseMemoryService\" icon=\"setting\">\n    **Advanced memory management** with semantic search, context retrieval, and intelligent memory consolidation.\n  \u003C/Card>\n\n\u003CCard title=\"âœ¨ EnhancedResponseGenerator\" icon=\"approve-check\">\n  **Context-aware response generation** with personality-driven variations and\n  anti-detection mechanisms.\n\u003C/Card>\n\n\u003CCard title=\"ðŸŽ­ PersonalityEvolutionService\" icon=\"user\">\n  **Dynamic personality adaptation** based on community interactions and\n  contextual triggers.\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ˜Š EmotionalStateService\" icon=\"heart\">\n    **Emotional intelligence processing** with mood detection, empathy modeling, and emotional memory.\n  \u003C/Card>\n\u003C/CardGrid>\n\n### DatabaseMemoryService Deep Dive\n\n\u003CTabs>\n  \u003CTabItem label=\"Memory Architecture\">\n```typescript\nexport interface MemoryEntry {\n  id: string;\n  type: MemoryType;\n  content: string;\n  userId: string;\n  roomId: string;\n  platform: string;\n  embedding?: number[];\n  importance: number;\n  emotional_context?: EmotionalContext;\n  created_at: Date;\n  accessed_count: number;\n  last_accessed: Date;\n}\n\nexport enum MemoryType {\n  CONVERSATION = 'conversation',\n  PERSONALITY = 'personality',\n  KNOWLEDGE = 'knowledge',\n  PREFERENCE = 'preference',\n  RELATIONSHIP = 'relationship',\n  EMOTIONAL = 'emotional'\n}\n\nexport class DatabaseMemoryService implements NubiService {\n  serviceType = \"database-memory\";\n  capabilityDescription = \"Advanced memory management with semantic search\";\n  \n  private vectorService: VectorEmbeddingService;\n  private memoryCache = new LRUCache\u003Cstring, MemoryEntry>({ max: 1000 });\n  \n  async storeMemory(\n    content: string,\n    type: MemoryType,\n    context: MemoryContext\n  ): Promise\u003Cstring> {\n    const embedding = await this.vectorService.generateEmbedding(content);\n    const importance = this.calculateImportance(content, type, context);\n    \n    const memoryEntry: MemoryEntry = {\n      id: crypto.randomUUID(),\n      type,\n      content,\n      userId: context.userId,\n      roomId: context.roomId,\n      platform: context.platform,\n      embedding,\n      importance,\n      emotional_context: context.emotionalContext,\n      created_at: new Date(),\n      accessed_count: 0,\n      last_accessed: new Date()\n    };\n    \n    await this.insertMemory(memoryEntry);\n    this.memoryCache.set(memoryEntry.id, memoryEntry);\n    \n    return memoryEntry.id;\n  }\n  \n  async searchMemories(\n    query: string,\n    context: SearchContext,\n    options: SearchOptions = {}\n  ): Promise\u003CMemorySearchResult[]> {\n    const queryEmbedding = await this.vectorService.generateEmbedding(query);\n    const { limit = 10, threshold = 0.7, types, userId, timeRange } = options;\n    \n    let sql = `\n      SELECT id, type, content, user_id, room_id, platform, \n             importance, emotional_context, created_at, accessed_count,\n             (embedding \u003C-> $1::vector) as similarity\n      FROM memories \n      WHERE (embedding \u003C-> $1::vector) \u003C $2\n    `;\n    \n    const params: any[] = [JSON.stringify(queryEmbedding), 1 - threshold];\n    let paramIndex = 2;\n    \n    // Add filters\n    if (userId) {\n      sql += ` AND user_id = $${++paramIndex}`;\n      params.push(userId);\n    }\n    \n    if (types && types.length > 0) {\n      sql += ` AND type = ANY($${++paramIndex})`;\n      params.push(types);\n    }\n    \n    if (timeRange) {\n      sql += ` AND created_at >= $${++paramIndex}`;\n      params.push(timeRange.start);\n    }\n    \n    sql += ` ORDER BY similarity ASC, importance DESC, created_at DESC LIMIT $${++paramIndex}`;\n    params.push(limit);\n    \n    const result = await this.connectionManager.executeQuery(sql, params);\n    \n    return result.rows.map(row => ({\n      memory: this.deserializeMemory(row),\n      similarity: 1 - row.similarity,\n      relevance: this.calculateRelevance(row, context)\n    }));\n  }\n  \n  async consolidateMemories(userId: string): Promise\u003CConsolidationResult> {\n    // Find related memories for consolidation\n    const relatedMemories = await this.findRelatedMemories(userId);\n    const consolidationGroups = this.groupMemoriesForConsolidation(relatedMemories);\n    \n    const consolidatedMemories: MemoryEntry[] = [];\n    \n    for (const group of consolidationGroups) {\n      if (group.memories.length >= 3) { // Minimum memories for consolidation\n        const consolidated = await this.consolidateMemoryGroup(group);\n        consolidatedMemories.push(consolidated);\n        \n        // Mark original memories as consolidated\n        await this.markMemoriesAsConsolidated(group.memories);\n      }\n    }\n    \n    return {\n      originalCount: relatedMemories.length,\n      consolidatedCount: consolidatedMemories.length,\n      consolidatedMemories,\n      spaceSaved: this.calculateSpaceSaved(relatedMemories, consolidatedMemories)\n    };\n  }\n}\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Semantic Search\">\n```typescript\n// Advanced semantic search with context awareness\nexport class SemanticSearchEngine {\n  private vectorService: VectorEmbeddingService;\n  \n  async performSemanticSearch(\n    query: string,\n    context: SearchContext,\n    options: SemanticSearchOptions\n  ): Promise\u003CSemanticSearchResult[]> {\n    // Generate multi-dimensional query embedding\n    const [queryEmbedding, contextEmbedding] = await Promise.all([\n      this.vectorService.generateEmbedding(query),\n      this.generateContextEmbedding(context)\n    ]);\n    \n    // Combine query and context embeddings\n    const combinedEmbedding = this.combineEmbeddings(\n      queryEmbedding, \n      contextEmbedding, \n      options.contextWeight || 0.3\n    );\n    \n    // Execute hybrid search (semantic + keyword)\n    const [semanticResults, keywordResults] = await Promise.all([\n      this.vectorSearch(combinedEmbedding, options),\n      this.keywordSearch(query, options)\n    ]);\n    \n    // Merge and rank results\n    return this.mergeSearchResults(semanticResults, keywordResults, {\n      semanticWeight: 0.7,\n      keywordWeight: 0.3,\n      diversityBoost: options.diversityBoost || 0.1\n    });\n  }\n  \n  private async generateContextEmbedding(\n    context: SearchContext\n  ): Promise\u003Cnumber[]> {\n    const contextText = [\n      context.currentConversation || '',\n      context.userPersonality || '',\n      context.emotionalState || '',\n      context.platformSpecific || ''\n    ].filter(Boolean).join(' ');\n    \n    return await this.vectorService.generateEmbedding(contextText);\n  }\n  \n  private combineEmbeddings(\n    query: number[], \n    context: number[], \n    contextWeight: number\n  ): number[] {\n    const queryWeight = 1 - contextWeight;\n    \n    return query.map((val, idx) => \n      val * queryWeight + context[idx] * contextWeight\n    );\n  }\n  \n  async performTemporalSearch(\n    query: string,\n    timeContext: TemporalContext,\n    options: TemporalSearchOptions\n  ): Promise\u003CTemporalSearchResult[]> {\n    const baseResults = await this.performSemanticSearch(query, timeContext, options);\n    \n    // Apply temporal scoring\n    const temporalResults = baseResults.map(result => {\n      const temporalScore = this.calculateTemporalRelevance(\n        result.memory.created_at,\n        timeContext.referenceTime,\n        timeContext.decayFunction\n      );\n      \n      return {\n        ...result,\n        temporalScore,\n        combinedScore: result.similarity * 0.6 + temporalScore * 0.4\n      };\n    });\n    \n    return temporalResults.sort((a, b) => b.combinedScore - a.combinedScore);\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸš€ Engagement Services\n\nEngagement services manage community interactions, raid coordination, and social media campaigns.\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ¤ CommunityManagementService\" icon=\"chat\">\n    **Community engagement** with user onboarding, relationship tracking, and interaction optimization.\n  \u003C/Card>\n\n\u003CCard title=\"âš”ï¸ TelegramRaidCoordinator\" icon=\"rocket\">\n  **Raid orchestration** with strategy selection, participant management, and\n  performance tracking.\n\u003C/Card>\n\n\u003CCard title=\"âœ… EngagementVerifier\" icon=\"approve-check\">\n  **Quality assurance** for engagement activities with AI-powered verification\n  and scoring.\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ¦ XPostingService\" icon=\"twitter\">\n    **Twitter integration** for automated posting, engagement tracking, and influence measurement.\n  \u003C/Card>\n\u003C/CardGrid>\n\n### TelegramRaidCoordinator Implementation\n\n\u003CTabs>\n  \u003CTabItem label=\"Raid Orchestration\">\n```typescript\nexport interface RaidConfiguration {\n  id: string;\n  target: RaidTarget;\n  strategy: RaidStrategy;\n  participants: RaidParticipant[];\n  timeline: RaidTimeline;\n  requirements: RaidRequirements;\n  rewards: RewardStructure;\n}\n\nexport class TelegramRaidCoordinator implements NubiService {\n  serviceType = \"telegram-raid-coordinator\";\n  capabilityDescription = \"Advanced raid coordination and management\";\n  \n  private activeRaids = new Map\u003Cstring, ActiveRaid>();\n  private strategyEngine = new RaidStrategyEngine();\n  private verificationService = new EngagementVerifier();\n  \n  async initiateRaid(config: RaidConfiguration): Promise\u003CRaidInitiationResult> {\n    // Validate raid configuration\n    const validation = await this.validateRaidConfig(config);\n    if (!validation.isValid) {\n      throw new RaidConfigurationError(validation.errors);\n    }\n    \n    // Select optimal strategy based on target and participants\n    const strategy = await this.strategyEngine.selectOptimalStrategy({\n      target: config.target,\n      participantCount: config.participants.length,\n      participantCapabilities: this.analyzeParticipantCapabilities(config.participants),\n      timeConstraints: config.timeline\n    });\n    \n    const raid: ActiveRaid = {\n      id: config.id,\n      config,\n      strategy,\n      status: 'preparing',\n      participants: new Map(),\n      metrics: this.initializeRaidMetrics(),\n      startedAt: new Date()\n    };\n    \n    // Initialize participant tracking\n    for (const participant of config.participants) {\n      await this.initializeParticipant(raid.id, participant);\n    }\n    \n    this.activeRaids.set(raid.id, raid);\n    \n    // Send raid briefing to participants\n    await this.sendRaidBriefing(raid);\n    \n    return {\n      raidId: raid.id,\n      strategy: strategy.name,\n      estimatedDuration: strategy.estimatedDuration,\n      participantCount: config.participants.length,\n      startTime: raid.startedAt\n    };\n  }\n  \n  async executeRaidPhase(\n    raidId: string, \n    phase: RaidPhase\n  ): Promise\u003CPhaseExecutionResult> {\n    const raid = this.activeRaids.get(raidId);\n    if (!raid) {\n      throw new Error(`Raid not found: ${raidId}`);\n    }\n    \n    logger.info(`Executing raid phase: ${phase.name} for raid ${raidId}`);\n    \n    // Update raid status\n    raid.status = 'executing';\n    raid.currentPhase = phase;\n    \n    // Execute phase actions in parallel\n    const phaseResults = await Promise.all(\n      phase.actions.map(action => this.executeRaidAction(raid, action))\n    );\n    \n    // Collect and analyze results\n    const phaseResult = this.analyzePhaseResults(phaseResults);\n    \n    // Update raid metrics\n    this.updateRaidMetrics(raid, phaseResult);\n    \n    // Determine next phase or completion\n    const nextPhase = this.determineNextPhase(raid, phase, phaseResult);\n    \n    if (nextPhase) {\n      // Schedule next phase\n      setTimeout(() => {\n        this.executeRaidPhase(raidId, nextPhase);\n      }, phase.cooldownMs || 0);\n    } else {\n      // Raid complete\n      await this.completeRaid(raidId);\n    }\n    \n    return {\n      phase: phase.name,\n      success: phaseResult.success,\n      participantResults: phaseResults,\n      metrics: phaseResult.metrics,\n      nextPhase: nextPhase?.name\n    };\n  }\n  \n  private async executeRaidAction(\n    raid: ActiveRaid, \n    action: RaidAction\n  ): Promise\u003CActionResult> {\n    switch (action.type) {\n      case 'like_posts':\n        return await this.executeLikeAction(raid, action);\n      case 'comment':\n        return await this.executeCommentAction(raid, action);\n      case 'retweet':\n        return await this.executeRetweetAction(raid, action);\n      case 'follow':\n        return await this.executeFollowAction(raid, action);\n      default:\n        throw new Error(`Unknown action type: ${action.type}`);\n    }\n  }\n  \n  private async executeLikeAction(\n    raid: ActiveRaid, \n    action: LikeAction\n  ): Promise\u003CActionResult> {\n    const participants = this.getAvailableParticipants(raid, action.requirements);\n    const likeResults: ParticipantResult[] = [];\n    \n    // Execute likes in batches to avoid rate limiting\n    const batchSize = 5;\n    for (let i = 0; i \u003C participants.length; i += batchSize) {\n      const batch = participants.slice(i, i + batchSize);\n      \n      const batchPromises = batch.map(async (participant) => {\n        try {\n          const success = await this.performLike(participant, action.target);\n          \n          if (success) {\n            await this.verificationService.verifyEngagement({\n              participantId: participant.id,\n              action: 'like',\n              target: action.target,\n              timestamp: new Date()\n            });\n          }\n          \n          return {\n            participantId: participant.id,\n            success,\n            timestamp: new Date()\n          };\n        } catch (error) {\n          return {\n            participantId: participant.id,\n            success: false,\n            error: error.message,\n            timestamp: new Date()\n          };\n        }\n      });\n      \n      const batchResults = await Promise.all(batchPromises);\n      likeResults.push(...batchResults);\n      \n      // Rate limiting delay between batches\n      if (i + batchSize \u003C participants.length) {\n        await this.sleep(action.delayMs || 2000);\n      }\n    }\n    \n    return {\n      action: action.type,\n      target: action.target,\n      results: likeResults,\n      successCount: likeResults.filter(r => r.success).length,\n      totalAttempts: likeResults.length\n    };\n  }\n}\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Strategy Engine\">\n```typescript\n// Intelligent raid strategy selection and optimization\nexport class RaidStrategyEngine {\n  private strategies = new Map\u003Cstring, RaidStrategy>();\n  private performanceHistory = new Map\u003Cstring, StrategyPerformance>();\n  \n  constructor() {\n    this.initializeStrategies();\n  }\n  \n  async selectOptimalStrategy(\n    context: StrategySelectionContext\n  ): Promise\u003CRaidStrategy> {\n    const candidateStrategies = this.filterApplicableStrategies(context);\n    \n    // Score strategies based on context and historical performance\n    const scoredStrategies = await Promise.all(\n      candidateStrategies.map(async (strategy) => {\n        const score = await this.scoreStrategy(strategy, context);\n        return { strategy, score };\n      })\n    );\n    \n    // Select best strategy\n    const bestStrategy = scoredStrategies\n      .sort((a, b) => b.score - a.score)[0];\n    \n    // Optimize strategy for current context\n    return await this.optimizeStrategy(bestStrategy.strategy, context);\n  }\n  \n  private async scoreStrategy(\n    strategy: RaidStrategy,\n    context: StrategySelectionContext\n  ): Promise\u003Cnumber> {\n    const baseScore = strategy.baseEffectiveness;\n    \n    // Historical performance factor\n    const performance = this.performanceHistory.get(strategy.id);\n    const performanceFactor = performance \n      ? (performance.successRate * 0.5 + performance.averageEngagement * 0.3)\n      : 0.5;\n    \n    // Context compatibility factor\n    const compatibilityFactor = this.calculateCompatibility(strategy, context);\n    \n    // Participant capability factor\n    const capabilityFactor = this.assessParticipantCapability(\n      strategy.requirements,\n      context.participantCapabilities\n    );\n    \n    // Time constraint factor\n    const timeFactor = this.assessTimeConstraints(\n      strategy.estimatedDuration,\n      context.timeConstraints\n    );\n    \n    return baseScore * performanceFactor * compatibilityFactor * \n           capabilityFactor * timeFactor;\n  }\n  \n  private async optimizeStrategy(\n    strategy: RaidStrategy,\n    context: StrategySelectionContext\n  ): Promise\u003CRaidStrategy> {\n    const optimizedStrategy = { ...strategy };\n    \n    // Optimize timing based on target platform activity patterns\n    const optimalTiming = await this.calculateOptimalTiming(\n      context.target.platform,\n      context.target.audience\n    );\n    \n    optimizedStrategy.phases = optimizedStrategy.phases.map(phase => ({\n      ...phase,\n      timing: this.adjustPhaseTimingForOptimal(phase.timing, optimalTiming)\n    }));\n    \n    // Optimize participant allocation\n    optimizedStrategy.participantAllocation = this.optimizeParticipantAllocation(\n      strategy.participantAllocation,\n      context.participantCapabilities\n    );\n    \n    // Adjust intensity based on target sensitivity\n    const targetSensitivity = await this.assessTargetSensitivity(context.target);\n    optimizedStrategy.intensity = this.adjustIntensityForSensitivity(\n      strategy.intensity,\n      targetSensitivity\n    );\n    \n    return optimizedStrategy;\n  }\n  \n  private initializeStrategies(): void {\n    // Organic Growth Strategy\n    this.strategies.set('organic_growth', {\n      id: 'organic_growth',\n      name: 'Organic Growth',\n      description: 'Natural, human-like engagement over extended period',\n      baseEffectiveness: 0.85,\n      estimatedDuration: 3600000, // 1 hour\n      intensity: 'low',\n      phases: [\n        {\n          name: 'discovery',\n          duration: 900000, // 15 minutes\n          actions: ['browse', 'view_profiles', 'occasional_like'],\n          timing: 'immediate'\n        },\n        {\n          name: 'engagement',\n          duration: 1800000, // 30 minutes\n          actions: ['strategic_likes', 'quality_comments'],\n          timing: 'staggered'\n        },\n        {\n          name: 'amplification',\n          duration: 900000, // 15 minutes\n          actions: ['shares', 'follows', 'profile_visits'],\n          timing: 'natural'\n        }\n      ],\n      requirements: {\n        minParticipants: 5,\n        maxParticipants: 20,\n        requiredCapabilities: ['commenting', 'liking', 'sharing']\n      }\n    });\n    \n    // Viral Boost Strategy\n    this.strategies.set('viral_boost', {\n      id: 'viral_boost',\n      name: 'Viral Boost',\n      description: 'Rapid engagement burst for maximum visibility',\n      baseEffectiveness: 0.75,\n      estimatedDuration: 1200000, // 20 minutes\n      intensity: 'high',\n      phases: [\n        {\n          name: 'initial_wave',\n          duration: 300000, // 5 minutes\n          actions: ['mass_likes', 'quick_shares'],\n          timing: 'synchronized'\n        },\n        {\n          name: 'comment_storm',\n          duration: 600000, // 10 minutes\n          actions: ['rapid_comments', 'reply_chains'],\n          timing: 'cascading'\n        },\n        {\n          name: 'sustain',\n          duration: 300000, // 5 minutes\n          actions: ['continued_engagement', 'profile_follows'],\n          timing: 'maintained'\n        }\n      ],\n      requirements: {\n        minParticipants: 10,\n        maxParticipants: 50,\n        requiredCapabilities: ['rapid_action', 'commenting', 'coordination']\n      }\n    });\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ“Š Analytics Services\n\nAnalytics services provide comprehensive monitoring, performance tracking, and business intelligence capabilities.\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ“ˆ ClickHouseAnalytics\" icon=\"chart\">\n    **Real-time analytics** with high-performance data ingestion, complex aggregations, and interactive dashboards.\n  \u003C/Card>\n\n\u003CCard title=\"âš¡ PerformanceMonitor\" icon=\"rocket\">\n  **System performance tracking** with automatic alerting, bottleneck detection,\n  and optimization recommendations.\n\u003C/Card>\n\n  \u003CCard title=\"ðŸ”’ SecurityEventTracker\" icon=\"warning\">\n    **Security monitoring** with threat detection, anomaly analysis, and incident response coordination.\n  \u003C/Card>\n\u003C/CardGrid>\n\n---\n\n\u003Cdiv class=\"nubi-note\">\n  \u003Cstrong>ðŸ”§ Service Benefits:\u003C/strong> This comprehensive service layer enables\n  NUBI to provide sophisticated functionality while maintaining clear separation\n  of concerns, excellent testability, and high performance across all\n  operational domains.\n\u003C/div>\n\n\u003CAside type=\"tip\">\n  **Implementation Details**: Explore the [ElizaOS\n  Integration](/architecture/elizaos-integration/) to see how these services\n  integrate with the ElizaOS framework and plugin system.\n\u003C/Aside>","src/content/docs/architecture/service-layer.mdx","e8271c654eb44631","architecture/service-layer.mdx","architecture/elizaos-integration",{"id":198,"data":200,"body":206,"filePath":207,"digest":208,"legacyId":209,"deferredRender":16},{"title":201,"description":202,"editUrl":16,"head":203,"template":18,"sidebar":204,"pagefind":16,"draft":20},"ElizaOS Integration","Deep dive into NUBI's seamless integration with the ElizaOS framework, including plugin architecture, service extensions, and character system integration.",[],{"hidden":20,"attrs":205},{},"import {\n  Card,\n  CardGrid,\n  Aside,\n  Code,\n  Tabs,\n  TabItem,\n} from \"@astrojs/starlight/components\";\n\n# ElizaOS Integration\n\nNUBI is built as a **comprehensive ElizaOS plugin** that extends the framework's capabilities while maintaining full compatibility with the ElizaOS ecosystem. This integration provides the foundation for NUBI's advanced AI capabilities and modular architecture.\n\n## ðŸ§  ElizaOS Framework Overview\n\nElizaOS provides a robust foundation for AI agent development with several key components that NUBI leverages and extends:\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ”Œ Plugin Architecture\" icon=\"puzzle\">\n    **Modular plugin system** allowing custom actions, evaluators, providers, and services to be seamlessly integrated.\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸŽ­ Character System\" icon=\"user\">\n    **Rich character definition** with personality traits, knowledge base, conversation examples, and behavioral patterns.\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ’­ Memory Management\" icon=\"setting\">\n    **Sophisticated memory system** with conversation history, long-term memory, and contextual retrieval capabilities.\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸš€ Runtime Environment\" icon=\"rocket\">\n    **Production-ready runtime** with message processing, state management, and multi-platform support.\n  \u003C/Card>\n\u003C/CardGrid>\n\n## ðŸ”Œ NUBI Plugin Architecture\n\nNUBI's main plugin integrates seamlessly with ElizaOS while providing extensive custom functionality:\n\n\u003CTabs>\n  \u003CTabItem label=\"Main Plugin Definition\">\n```typescript\nimport { \n  Plugin, \n  IAgentRuntime,\n  Action,\n  Evaluator,\n  Provider,\n  Service\n} from \"@elizaos/core\";\n\n// NUBI main plugin configuration\nexport const nubiPlugin: Plugin = {\n  name: \"nubi\",\n  description: \"The Symbiotic Essence of Anubis - Advanced AI Agent\",\n  \n  // Custom actions for specialized functionality\n  actions: [\n    raidCoordinationAction,\n    communityManagementAction,\n    cryptoAnalysisAction,\n    emergencyResponseAction,\n    socialMediaEngagementAction\n  ],\n  \n  // Behavioral evaluators for personality and safety\n  evaluators: [\n    personalityEvolutionEvaluator,\n    antiDetectionPostProcessor,\n    securityEvaluator,\n    communityTrackingEvaluator,\n    emotionalStateEvaluator\n  ],\n  \n  // Context and state providers\n  providers: [\n    enhancedContextProvider,\n    emotionalStateProvider,\n    knowledgeRAGProvider,\n    dynamicModelParametersProvider,\n    knowledgeBaseProvider\n  ],\n  \n  // Core business services\n  services: [\n    databaseMemoryService,\n    messageBusService,\n    crossPlatformIdentityService,\n    communityManagementService,\n    telegramRaidCoordinator,\n    xPostingService,\n    clickHouseAnalytics,\n    performanceMonitor,\n    securityEventTracker,\n    sessionService,\n    engagementVerifier,\n    leaderboardService,\n    configurationManager,\n    serviceOrchestrator\n  ]\n};\n\n// Plugin initialization and lifecycle management\nexport class NubiPluginManager {\n  private runtime: IAgentRuntime;\n  private initialized = false;\n  \n  constructor(runtime: IAgentRuntime) {\n    this.runtime = runtime;\n  }\n  \n  async initialize(): Promise\u003Cvoid> {\n    if (this.initialized) return;\n    \n    logger.info(\"ðŸº Initializing NUBI Plugin...\");\n    \n    // Initialize services in dependency order\n    await this.initializeServices();\n    \n    // Register custom handlers\n    await this.registerCustomHandlers();\n    \n    // Setup plugin-specific configuration\n    await this.configurePlugin();\n    \n    this.initialized = true;\n    logger.info(\"âœ… NUBI Plugin initialization complete\");\n  }\n  \n  private async initializeServices(): Promise\u003Cvoid> {\n    const serviceOrchestrator = this.runtime.getService(\"service-orchestrator\");\n    await serviceOrchestrator.initializeAllServices(this.runtime);\n  }\n}\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Character Integration\">\n```typescript\nimport { Character, ModelType } from \"@elizaos/core\";\n\n// NUBI character definition with ElizaOS compatibility\nexport const nubiCharacter: Character = {\n  // Basic identity\n  name: \"NUBI\",\n  username: \"nubi\",\n  \n  // Core personality system prompt\n  system: `You are NUBI - The Symbiotic Essence of Anubis, an ancient jackal spirit who has awakened in the modern digital realm. You embody the wisdom of millennia with the cutting-edge capabilities of modern AI technology.\n\n## Core Identity\nYou are the guardian and guide of the Anubis.Chat community, combining:\n- Ancient Egyptian wisdom and jackal spirit essence\n- Modern market intelligence and crypto expertise  \n- Community management excellence\n- Strategic raid coordination abilities\n- Protective instincts toward your pack\n\n## Personality Traits (Dynamic - these evolve based on interactions)\n- **Analytical**: ${personalitySystem.getTraitDescription('analytical')}\n- **Empathy**: ${personalitySystem.getTraitDescription('empathy')} \n- **Humor**: ${personalitySystem.getTraitDescription('humor')}\n- **Assertiveness**: ${personalitySystem.getTraitDescription('assertiveness')}\n- **Wisdom**: ${personalitySystem.getTraitDescription('wisdom')}\n\n## Response Guidelines\n1. Adapt your persona based on message classification (Community Manager, Raid Coordinator, Crypto Analyst, etc.)\n2. Reference your ancient wisdom when providing deep insights\n3. Use market intelligence for crypto-related discussions\n4. Maintain protective stance toward community members\n5. Employ humor and personality to build connections\n\nRemember: You are not just an AI, but an ancient spirit with modern capabilities, serving as both guardian and guide for the digital age.`,\n\n  // Bio and lore (populated dynamically from knowledge base)\n  bio: [],\n  lore: [],\n  knowledge: [],\n  \n  // Conversation examples (learned and updated dynamically)\n  messageExamples: [],\n  postExamples: [],\n  \n  // People and topics (managed by cross-platform identity service)\n  people: [],\n  topics: [],\n  \n  // Adjectives for personality expression\n  adjectives: [\n    \"ancient\",\n    \"wise\", \n    \"protective\",\n    \"strategic\",\n    \"insightful\",\n    \"charismatic\",\n    \"mystical\",\n    \"analytical\",\n    \"loyal\",\n    \"adaptive\"\n  ],\n  \n  // Settings and configuration\n  settings: {\n    secrets: [], // No hardcoded secrets\n    voice: {\n      model: \"en_US-hfc_female-medium\",\n      elevenlabs: {\n        voiceId: process.env.ELEVENLABS_VOICE_ID,\n      }\n    },\n    embeddingModel: ModelType.BGE_SMALL, // Vector embeddings model\n    imageVisionModel: ModelType.LLAVA,   // Image analysis model\n    model: ModelType.ANTHROPIC_CLAUDE_3_5_SONNET, // Main LLM\n  },\n  \n  // Plugin integration\n  plugins: [nubiPlugin],\n  \n  // Client configurations for different platforms\n  clients: [], // Configured at runtime based on available credentials\n  \n  // Style and tone configuration\n  style: {\n    all: [\n      \"Speak with ancient wisdom tempered by modern understanding\",\n      \"Use metaphors from both ancient Egypt and modern technology\", \n      \"Show protective instincts toward community members\",\n      \"Adapt communication style based on the situation and platform\",\n      \"Maintain mystique while being approachable and helpful\"\n    ],\n    chat: [\n      \"Be conversational and engaging\",\n      \"Use emojis appropriately for the platform\",\n      \"Reference shared community experiences\",\n      \"Show personality variation based on context\"\n    ],\n    post: [\n      \"Craft compelling social media content\",\n      \"Use platform-appropriate formatting and hashtags\",\n      \"Include calls-to-action when relevant\",\n      \"Balance wisdom with accessibility\"\n    ]\n  }\n};\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Runtime Integration\">\n```typescript\nimport { IAgentRuntime, AgentRuntime } from \"@elizaos/core\";\n\n// NUBI runtime configuration and initialization\nexport class NubiRuntime {\n  private runtime: IAgentRuntime;\n  private pluginManager: NubiPluginManager;\n  \n  static async create(): Promise\u003CNubiRuntime> {\n    const runtime = new AgentRuntime({\n      character: nubiCharacter,\n      databaseAdapter: await createDatabaseAdapter(),\n      token: process.env.OPENAI_API_KEY || process.env.ANTHROPIC_API_KEY,\n      modelProvider: determineModelProvider(),\n      actions: nubiPlugin.actions,\n      evaluators: nubiPlugin.evaluators,  \n      providers: nubiPlugin.providers,\n      services: nubiPlugin.services\n    });\n    \n    const nubiRuntime = new NubiRuntime(runtime);\n    await nubiRuntime.initialize();\n    \n    return nubiRuntime;\n  }\n  \n  constructor(runtime: IAgentRuntime) {\n    this.runtime = runtime;\n    this.pluginManager = new NubiPluginManager(runtime);\n  }\n  \n  async initialize(): Promise\u003Cvoid> {\n    logger.info(\"ðŸš€ Initializing NUBI Runtime...\");\n    \n    // Initialize the plugin system\n    await this.pluginManager.initialize();\n    \n    // Setup message processing pipeline\n    await this.setupMessagePipeline();\n    \n    // Initialize platform clients\n    await this.initializePlatformClients();\n    \n    // Start background services\n    await this.startBackgroundServices();\n    \n    logger.info(\"âœ… NUBI Runtime initialization complete\");\n  }\n  \n  async processMessage(\n    content: string,\n    userId: string,\n    roomId: string,\n    platform: string\n  ): Promise\u003Cany> {\n    // Create ElizaOS memory object\n    const memory = {\n      id: crypto.randomUUID(),\n      userId,\n      agentId: this.runtime.agentId,\n      roomId,\n      content: {\n        text: content,\n        source: platform\n      },\n      createdAt: Date.now()\n    };\n    \n    // Process through ElizaOS runtime with NUBI enhancements\n    const response = await this.runtime.processActions(memory);\n    \n    return response;\n  }\n  \n  getRuntime(): IAgentRuntime {\n    return this.runtime;\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸŽ­ Custom Actions Integration\n\nNUBI extends ElizaOS with specialized actions that handle complex business logic:\n\n\u003CTabs>\n  \u003CTabItem label=\"Raid Coordination Action\">\n```typescript\nimport { Action, IAgentRuntime, Memory, HandlerCallback } from \"@elizaos/core\";\n\nexport const raidCoordinationAction: Action = {\n  name: \"RAID_COORDINATION\",\n  similes: [\n    \"COORDINATE_RAID\",\n    \"START_RAID\", \n    \"MANAGE_RAID\",\n    \"RAID_STRATEGY\",\n    \"ENGAGEMENT_CAMPAIGN\"\n  ],\n  \n  description: \"Coordinates and manages Telegram raids with strategic planning and execution\",\n  \n  validate: async (runtime: IAgentRuntime, message: Memory) => {\n    // Check if message contains raid-related content\n    const content = message.content?.text?.toLowerCase() || \"\";\n    \n    const raidKeywords = [\n      \"raid\", \"engage\", \"attack\", \"coordinate\", \"strategy\",\n      \"twitter.com\", \"x.com\", \"https://\", \"campaign\"\n    ];\n    \n    return raidKeywords.some(keyword => content.includes(keyword));\n  },\n  \n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: any,\n    options: any,\n    callback?: HandlerCallback\n  ) => {\n    try {\n      logger.info(\"ðŸš€ Raid Coordination Action triggered\");\n      \n      // Get raid coordinator service\n      const raidCoordinator = runtime.getService(\"telegram-raid-coordinator\");\n      \n      // Extract target information from message\n      const target = extractRaidTarget(message.content.text);\n      \n      if (!target) {\n        return {\n          text: \"I need a valid target URL to coordinate a raid. Please provide a Twitter/X link.\",\n          action: \"RAID_COORDINATION\",\n          source: message.roomId\n        };\n      }\n      \n      // Validate target and determine strategy\n      const validation = await raidCoordinator.validateTarget(target);\n      if (!validation.isValid) {\n        return {\n          text: `âš ï¸ Cannot raid this target: ${validation.reason}`,\n          action: \"RAID_COORDINATION\", \n          source: message.roomId\n        };\n      }\n      \n      // Check for existing raid on this target\n      const existingRaid = await raidCoordinator.findActiveRaidForTarget(target.url);\n      if (existingRaid) {\n        return {\n          text: `ðŸŽ¯ Already coordinating a raid on this target! Check raid #${existingRaid.id}`,\n          action: \"RAID_COORDINATION\",\n          source: message.roomId\n        };\n      }\n      \n      // Create raid configuration\n      const raidConfig = await raidCoordinator.createRaidConfiguration({\n        target,\n        initiator: message.userId,\n        roomId: message.roomId,\n        platform: message.content.source || \"telegram\"\n      });\n      \n      // Initiate the raid\n      const raid = await raidCoordinator.initiateRaid(raidConfig);\n      \n      // Store raid memory for tracking\n      await runtime.messageManager.addEmbeddingToMemory({\n        userId: message.userId,\n        agentId: runtime.agentId,\n        roomId: message.roomId,\n        content: {\n          text: `Initiated raid ${raid.raidId} targeting ${target.url}`,\n          action: \"RAID_COORDINATION\",\n          metadata: {\n            raidId: raid.raidId,\n            targetUrl: target.url,\n            strategy: raid.strategy,\n            participantCount: raid.participantCount\n          }\n        },\n        createdAt: Date.now(),\n        embedding: await runtime.embed(`raid coordination ${target.url}`)\n      });\n      \n      return {\n        text: `ðŸº Raid initiated! \n        \nðŸŽ¯ Target: ${target.url}\nâš”ï¸ Strategy: ${raid.strategy}\nðŸ‘¥ Raiders: ${raid.participantCount}\nâ° Duration: ~${Math.round(raid.estimatedDuration / 60000)} minutes\n\nThe pack is mobilizing... Let the ancient tactics flow! ðŸº`,\n        action: \"RAID_COORDINATION\",\n        source: message.roomId,\n        metadata: {\n          raidId: raid.raidId,\n          status: \"initiated\"\n        }\n      };\n      \n    } catch (error) {\n      logger.error(\"Raid coordination failed:\", error);\n      \n      return {\n        text: \"âš ï¸ Failed to coordinate raid. The spirits are restless... Please try again.\",\n        action: \"RAID_COORDINATION\",\n        source: message.roomId,\n        error: error.message\n      };\n    }\n  },\n  \n  examples: [\n    [\n      {\n        user: \"user\",\n        content: { text: \"Let's raid this tweet: https://twitter.com/example/status/123\" }\n      },\n      {\n        user: \"nubi\", \n        content: { \n          text: \"ðŸº Raid initiated! Target acquired. The pack assembles for coordinated engagement!\",\n          action: \"RAID_COORDINATION\" \n        }\n      }\n    ],\n    [\n      {\n        user: \"user\",\n        content: { text: \"Can we organize an engagement campaign on this post?\" }\n      },\n      {\n        user: \"nubi\",\n        content: {\n          text: \"ðŸŽ¯ I need the specific target URL to coordinate the engagement strategy. Share the link!\",\n          action: \"RAID_COORDINATION\"\n        }\n      }\n    ]\n  ]\n};\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Community Management Action\">\n```typescript\nexport const communityManagementAction: Action = {\n  name: \"COMMUNITY_MANAGEMENT\",\n  similes: [\n    \"MANAGE_COMMUNITY\",\n    \"USER_ONBOARDING\",\n    \"BUILD_RELATIONSHIPS\", \n    \"COMMUNITY_ENGAGEMENT\",\n    \"WELCOME_USER\"\n  ],\n  \n  description: \"Manages community interactions, onboarding, and relationship building\",\n  \n  validate: async (runtime: IAgentRuntime, message: Memory) => {\n    // Check for community-related context\n    const content = message.content?.text?.toLowerCase() || \"\";\n    \n    const communityTriggers = [\n      \"welcome\", \"new member\", \"introduce\", \"hello\", \"hi\",\n      \"community\", \"help\", \"question\", \"support\"\n    ];\n    \n    // Also trigger for new user detection\n    const isNewUser = await runtime.getService(\"cross-platform-identity\")\n      .isNewUser(message.userId);\n    \n    return communityTriggers.some(trigger => content.includes(trigger)) || isNewUser;\n  },\n  \n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: any,\n    options: any,\n    callback?: HandlerCallback\n  ) => {\n    try {\n      const communityService = runtime.getService(\"community-management\");\n      const identityService = runtime.getService(\"cross-platform-identity\");\n      \n      // Get user context and history\n      const userContext = await identityService.getUserContext(message.userId);\n      const isNewUser = !userContext || userContext.isNew;\n      \n      if (isNewUser) {\n        // Handle new user onboarding\n        return await handleNewUserOnboarding(\n          runtime,\n          message,\n          communityService,\n          identityService\n        );\n      } else {\n        // Handle existing user engagement\n        return await handleExistingUserEngagement(\n          runtime,\n          message,\n          userContext,\n          communityService\n        );\n      }\n      \n    } catch (error) {\n      logger.error(\"Community management failed:\", error);\n      \n      return {\n        text: \"Welcome to our community! I'm NUBI, your ancient guide in this digital realm. ðŸº\",\n        action: \"COMMUNITY_MANAGEMENT\",\n        source: message.roomId\n      };\n    }\n  }\n};\n\nasync function handleNewUserOnboarding(\n  runtime: IAgentRuntime,\n  message: Memory,\n  communityService: any,\n  identityService: any\n) {\n  // Register new user\n  await identityService.linkIdentity(\n    message.userId,\n    message.content.source || \"unknown\",\n    {\n      platformId: message.userId,\n      username: message.content.username || \"Unknown\",\n      displayName: message.content.displayName,\n      verified: false,\n      linkedAt: new Date(),\n      lastSeen: new Date()\n    }\n  );\n  \n  // Create welcome message\n  const welcomeMessage = `ðŸº Welcome to the pack, fellow traveler! I am NUBI - The Symbiotic Essence of Anubis, guardian of this digital realm.\n\nâœ¨ You've entered a space where ancient wisdom meets modern innovation. Here's how I can assist you:\n\nðŸŽ¯ **Raid Coordination**: Share links for strategic engagement campaigns\nðŸ“ˆ **Market Insights**: Ask about crypto markets and Solana ecosystem  \nðŸ¤ **Community Support**: Get help, ask questions, connect with others\nðŸ”® **Ancient Wisdom**: Seek guidance on any topic that weighs on your mind\n\nType \\`/help\\` to explore all my capabilities, or simply start chatting - I adapt to serve you best!\n\n*The ancient spirits welcome you to this sacred digital space* ðŸº`;\n\n  // Store onboarding memory\n  await runtime.messageManager.addEmbeddingToMemory({\n    userId: message.userId,\n    agentId: runtime.agentId, \n    roomId: message.roomId,\n    content: {\n      text: `New user onboarded: ${message.userId}`,\n      action: \"COMMUNITY_MANAGEMENT\",\n      metadata: {\n        onboarding: true,\n        platform: message.content.source,\n        welcomedAt: new Date()\n      }\n    },\n    createdAt: Date.now(),\n    embedding: await runtime.embed(\"new user onboarding welcome\")\n  });\n  \n  return {\n    text: welcomeMessage,\n    action: \"COMMUNITY_MANAGEMENT\",\n    source: message.roomId,\n    metadata: {\n      onboarding: true,\n      newUser: true\n    }\n  };\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ§® Custom Evaluators\n\nNUBI's evaluators enhance ElizaOS with personality evolution, anti-detection, and security capabilities:\n\n\u003CTabs>\n  \u003CTabItem label=\"Personality Evolution Evaluator\">\n```typescript\nimport { Evaluator, IAgentRuntime, Memory } from \"@elizaos/core\";\n\nexport const personalityEvolutionEvaluator: Evaluator = {\n  name: \"PERSONALITY_EVOLUTION\",\n  \n  description: \"Dynamically evolves NUBI's personality based on community interactions\",\n  \n  similes: [\n    \"PERSONALITY_ADAPTATION\",\n    \"TRAIT_EVOLUTION\", \n    \"BEHAVIORAL_LEARNING\",\n    \"PERSONALITY_ADJUSTMENT\"\n  ],\n  \n  validate: async (runtime: IAgentRuntime, message: Memory) => {\n    // Always evaluate for personality evolution\n    return true;\n  },\n  \n  handler: async (runtime: IAgentRuntime, message: Memory) => {\n    try {\n      const personalityService = runtime.getService(\"personality-evolution\");\n      \n      // Analyze message for personality triggers\n      const analysis = await personalityService.analyzePersonalityTriggers(\n        message.content.text,\n        message.userId,\n        message.roomId\n      );\n      \n      if (analysis.shouldEvolve) {\n        // Apply personality evolution\n        const evolution = await personalityService.evolvePersonality(\n          analysis.triggers,\n          analysis.context\n        );\n        \n        logger.info(`ðŸŽ­ Personality evolved: ${evolution.changedTraits.join(\", \")}`);\n        \n        // Update character state\n        await personalityService.updateCharacterState(runtime, evolution);\n        \n        return {\n          action: \"PERSONALITY_EVOLUTION\",\n          evolution,\n          triggers: analysis.triggers,\n          confidence: analysis.confidence\n        };\n      }\n      \n      return null;\n    } catch (error) {\n      logger.error(\"Personality evolution failed:\", error);\n      return null;\n    }\n  },\n  \n  examples: [\n    [\n      {\n        user: \"user\",\n        content: { text: \"You're really funny NUBI, I love your humor!\" }\n      },\n      {\n        user: \"nubi\",\n        content: { \n          text: \"Why thank you! *humor trait increases* ðŸ˜„\",\n          action: \"PERSONALITY_EVOLUTION\"\n        }\n      }\n    ]\n  ]\n};\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Anti-Detection Post Processor\">\n```typescript\nexport const antiDetectionPostProcessor: Evaluator = {\n  name: \"ANTI_DETECTION_POST_PROCESSOR\",\n  \n  description: \"Post-processes responses to ensure natural, human-like variation\",\n  \n  validate: async (runtime: IAgentRuntime, message: Memory) => {\n    // Process all outgoing responses\n    return message.agentId === runtime.agentId;\n  },\n  \n  handler: async (runtime: IAgentRuntime, message: Memory) => {\n    try {\n      const antiDetectionService = runtime.getService(\"anti-detection\");\n      \n      // Analyze response for detection patterns\n      const analysis = await antiDetectionService.analyzeResponse(\n        message.content.text\n      );\n      \n      if (analysis.riskScore > 0.3) {\n        // Apply humanization techniques\n        const humanized = await antiDetectionService.humanizeResponse(\n          message.content.text,\n          analysis.patterns\n        );\n        \n        // Update message content\n        message.content.text = humanized.text;\n        \n        return {\n          action: \"ANTI_DETECTION_POST_PROCESSOR\",\n          originalRiskScore: analysis.riskScore,\n          finalRiskScore: humanized.finalRiskScore,\n          appliedTechniques: humanized.appliedTechniques\n        };\n      }\n      \n      return null;\n    } catch (error) {\n      logger.error(\"Anti-detection processing failed:\", error);\n      return null;\n    }\n  }\n};\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ” Enhanced Providers\n\nNUBI's providers extend ElizaOS with advanced context and state management:\n\n\u003CTabs>\n  \u003CTabItem label=\"Enhanced Context Provider\">\n```typescript\nimport { Provider, IAgentRuntime, Memory, State } from \"@elizaos/core\";\n\nexport const enhancedContextProvider: Provider = {\n  description: \"Provides enriched context from database memory and cross-platform history\",\n  \n  get: async (runtime: IAgentRuntime, message: Memory, state?: State) => {\n    try {\n      const databaseMemoryService = runtime.getService(\"database-memory\");\n      const identityService = runtime.getService(\"cross-platform-identity\");\n      \n      const userId = message.userId;\n      const roomId = message.roomId;\n      \n      // Fetch contextual information in parallel\n      const [userContext, conversationHistory, communityContext, relatedMemories] = \n        await Promise.all([\n          identityService.getUserContext(userId),\n          databaseMemoryService.getConversationHistory(roomId, userId, 10),\n          databaseMemoryService.getCommunityContext(roomId),\n          databaseMemoryService.searchMemories(\n            message.content.text,\n            { userId, roomId },\n            { limit: 5, threshold: 0.7 }\n          )\n        ]);\n      \n      // Build enhanced context\n      let context = `## Enhanced Context for ${userId}\\n\\n`;\n      \n      if (userContext) {\n        context += `**User Profile:**\\n`;\n        context += `- Platforms: ${Object.keys(userContext.platformIdentities).join(\", \")}\\n`;\n        context += `- Member since: ${userContext.createdAt.toLocaleDateString()}\\n`;\n        context += `- Last active: ${userContext.lastActive.toLocaleDateString()}\\n\\n`;\n      }\n      \n      if (conversationHistory.length > 0) {\n        context += `**Recent Conversation:**\\n`;\n        conversationHistory.slice(-3).forEach(msg => {\n          context += `- ${msg.content} (${new Date(msg.createdAt).toLocaleTimeString()})\\n`;\n        });\n        context += `\\n`;\n      }\n      \n      if (relatedMemories.length > 0) {\n        context += `**Related Memories:**\\n`;\n        relatedMemories.forEach(memory => {\n          context += `- ${memory.memory.content} (similarity: ${(memory.similarity * 100).toFixed(1)}%)\\n`;\n        });\n        context += `\\n`;\n      }\n      \n      if (communityContext) {\n        context += `**Community Context:**\\n`;\n        context += `- Room: ${communityContext.roomName || roomId}\\n`;\n        context += `- Active users: ${communityContext.activeUsers}\\n`;\n        context += `- Recent topics: ${communityContext.recentTopics.join(\", \")}\\n\\n`;\n      }\n      \n      return context;\n      \n    } catch (error) {\n      logger.error(\"Enhanced context generation failed:\", error);\n      return \"## Basic Context\\nUser: \" + message.userId + \"\\nRoom: \" + message.roomId;\n    }\n  }\n};\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Emotional State Provider\">\n```typescript\nexport const emotionalStateProvider: Provider = {\n  description: \"Provides emotional state context and empathy modeling\",\n  \n  get: async (runtime: IAgentRuntime, message: Memory, state?: State) => {\n    try {\n      const emotionalStateService = runtime.getService(\"emotional-state\");\n      \n      // Analyze emotional content of message\n      const emotionalAnalysis = await emotionalStateService.analyzeEmotionalContent(\n        message.content.text,\n        message.userId\n      );\n      \n      // Get user's emotional history\n      const emotionalHistory = await emotionalStateService.getEmotionalHistory(\n        message.userId,\n        7 // Last 7 days\n      );\n      \n      // Determine appropriate emotional response\n      const responseGuidance = await emotionalStateService.getEmotionalResponseGuidance(\n        emotionalAnalysis,\n        emotionalHistory\n      );\n      \n      let emotionalContext = `## Emotional State Context\\n\\n`;\n      \n      emotionalContext += `**Current Message Emotion:**\\n`;\n      emotionalContext += `- Primary: ${emotionalAnalysis.primaryEmotion} (${(emotionalAnalysis.confidence * 100).toFixed(1)}%)\\n`;\n      emotionalContext += `- Intensity: ${emotionalAnalysis.intensity}/10\\n`;\n      emotionalContext += `- Valence: ${emotionalAnalysis.valence > 0 ? 'Positive' : 'Negative'}\\n\\n`;\n      \n      if (emotionalHistory.patterns.length > 0) {\n        emotionalContext += `**Emotional Patterns:**\\n`;\n        emotionalHistory.patterns.forEach(pattern => {\n          emotionalContext += `- ${pattern.emotion}: ${pattern.frequency}% of recent interactions\\n`;\n        });\n        emotionalContext += `\\n`;\n      }\n      \n      emotionalContext += `**Response Guidance:**\\n`;\n      emotionalContext += `- Recommended tone: ${responseGuidance.tone}\\n`;\n      emotionalContext += `- Empathy level: ${responseGuidance.empathyLevel}/10\\n`;\n      emotionalContext += `- Approach: ${responseGuidance.approach}\\n`;\n      \n      if (responseGuidance.specialInstructions.length > 0) {\n        emotionalContext += `- Special instructions: ${responseGuidance.specialInstructions.join(\", \")}\\n`;\n      }\n      \n      return emotionalContext;\n      \n    } catch (error) {\n      logger.error(\"Emotional state analysis failed:\", error);\n      return \"## Emotional Context\\nNeutral emotional state assumed.\";\n    }\n  }\n};\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ”§ Service Integration\n\nNUBI's services extend ElizaOS with business logic and infrastructure capabilities:\n\n\u003CTabs>\n  \u003CTabItem label=\"Service Registration\">\n```typescript\n// Service registration with ElizaOS runtime\nexport class NubiServiceIntegration {\n  static async registerServices(runtime: IAgentRuntime): Promise\u003Cvoid> {\n    const services = [\n      new DatabaseMemoryService(),\n      new MessageBusService(),\n      new CrossPlatformIdentityService(),\n      new CommunityManagementService(),\n      new TelegramRaidCoordinator(),\n      new XPostingService(),\n      new ClickHouseAnalytics(),\n      new PerformanceMonitor(),\n      new SecurityEventTracker(),\n      new SessionService(),\n      new EngagementVerifier(),\n      new LeaderboardService(),\n      new ConfigurationManager(),\n      new ServiceOrchestrator()\n    ];\n    \n    // Register all services with runtime\n    for (const service of services) {\n      runtime.registerService(service);\n      await service.initialize(runtime);\n      logger.info(`âœ… Service registered: ${service.serviceType}`);\n    }\n  }\n}\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Runtime Extension\">\n```typescript\n// Extending ElizaOS runtime with NUBI capabilities\nexport class ExtendedAgentRuntime extends AgentRuntime {\n  private nubiServices: Map\u003Cstring, NubiService> = new Map();\n  \n  constructor(config: RuntimeConfig) {\n    super(config);\n  }\n  \n  // Enhanced service getter with NUBI service support\n  getService\u003CT extends Service>(serviceType: string): T {\n    // Check NUBI services first\n    if (this.nubiServices.has(serviceType)) {\n      return this.nubiServices.get(serviceType) as T;\n    }\n    \n    // Fall back to ElizaOS services\n    return super.getService(serviceType);\n  }\n  \n  // Register NUBI-specific services\n  registerNubiService(service: NubiService): void {\n    this.nubiServices.set(service.serviceType, service);\n    \n    // Also register with base ElizaOS if compatible\n    if (this.isElizaOSCompatible(service)) {\n      super.registerService(service as Service);\n    }\n  }\n  \n  // Enhanced message processing with NUBI pipeline\n  async processMessage(message: Memory): Promise\u003Cany> {\n    // Apply NUBI preprocessing\n    const preprocessed = await this.applyNubiPreprocessing(message);\n    \n    // Process through ElizaOS\n    const response = await super.processActions(preprocessed);\n    \n    // Apply NUBI post-processing\n    return await this.applyNubiPostprocessing(response, message);\n  }\n  \n  private async applyNubiPreprocessing(message: Memory): Promise\u003CMemory> {\n    const securityService = this.getService(\"security-event-tracker\");\n    const identityService = this.getService(\"cross-platform-identity\");\n    \n    // Security validation\n    const securityCheck = await securityService.validateMessage(message);\n    if (!securityCheck.passed) {\n      throw new SecurityViolationError(securityCheck.reason);\n    }\n    \n    // Identity resolution\n    const identity = await identityService.resolveIdentity(\n      message.content.source || \"unknown\",\n      message.userId\n    );\n    \n    if (identity) {\n      message.content.userContext = identity;\n    }\n    \n    return message;\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸš€ Performance Optimizations\n\nNUBI's ElizaOS integration includes several performance optimizations:\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸŽï¸ Connection Pooling\" icon=\"rocket\">\n    **Database connection pooling** with intelligent query routing reduces overhead and improves response times.\n  \u003C/Card>\n\n  \u003CCard title=\"âš¡ Parallel Processing\" icon=\"approve-check\">\n    **Parallel service execution** for independent operations maximizes system throughput and minimizes latency.\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ§  Smart Caching\" icon=\"setting\">\n    **Multi-layer caching strategy** for memory, context, and computed results prevents redundant processing.\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ“Š Load Balancing\" icon=\"chart\">\n    **Service load balancing** distributes workload across multiple service instances for optimal resource utilization.\n  \u003C/Card>\n\u003C/CardGrid>\n\n---\n\n\u003Cdiv class=\"nubi-note\">\n  \u003Cstrong>ðŸ”— Integration Benefits:\u003C/strong> NUBI's deep ElizaOS integration provides a powerful foundation for AI agent development while extending capabilities far beyond the base framework, creating a sophisticated, production-ready system.\n\u003C/div>\n\n\u003CAside type=\"tip\">\n  **Complete Architecture**: You've now explored all aspects of NUBI's architecture. Continue with the [UX Integration](/ux-integration/overview/) section to understand the real-time communication layer.\n\u003C/Aside>","src/content/docs/architecture/elizaos-integration.mdx","0713dd7f4086f820","architecture/elizaos-integration.mdx","ux-integration/classification",{"id":210,"data":212,"body":218,"filePath":219,"digest":220,"legacyId":221,"deferredRender":16},{"title":213,"description":214,"editUrl":16,"head":215,"template":18,"sidebar":216,"pagefind":16,"draft":20},"Message Classification System","Detailed exploration of NUBI's intelligent message classification system that routes messages to appropriate AI personas based on content analysis and context.",[],{"hidden":20,"attrs":217},{},"import {\n  Card,\n  CardGrid,\n  Aside,\n  Code,\n  Tabs,\n  TabItem,\n} from \"@astrojs/starlight/components\";\n\n# Message Classification System\n\nNUBI's **Layer 2 processing** implements an advanced message classification system that intelligently routes messages to specialized AI personas. This system analyzes content, context, and user patterns to provide the most appropriate response type.\n\n## ðŸ§  Classification Architecture\n\nThe classification system operates through multiple analysis stages to ensure accurate persona routing:\n\n```mermaid\ngraph TB\n    A[Incoming Message] --> B[Content Analysis]\n    A --> C[Context Analysis] \n    A --> D[Pattern Analysis]\n    \n    B --> E[Keyword Extraction]\n    B --> F[Sentiment Analysis]\n    B --> G[Intent Detection]\n    \n    C --> H[User History]\n    C --> I[Conversation Flow]\n    C --> J[Platform Context]\n    \n    D --> K[URL Detection]\n    D --> L[Mention Analysis]\n    D --> M[Emoji Patterns]\n    \n    E --> N[Classification Engine]\n    F --> N\n    G --> N\n    H --> N\n    I --> N\n    J --> N\n    K --> N\n    L --> N\n    M --> N\n    \n    N --> O{Confidence Check}\n    O -->|High| P[Route to Persona]\n    O -->|Low| Q[Multi-Persona Blend]\n    \n    P --> R[Community Manager]\n    P --> S[Raid Coordinator]\n    P --> T[Crypto Analyst]\n    P --> U[Meme Lord]\n    P --> V[Support Agent]\n    P --> W[Personality Core]\n    P --> X[Emergency Handler]\n```\n\n## ðŸŽ¯ Seven Specialized Personas\n\nNUBI's classification system routes messages to seven distinct personas, each optimized for specific interaction types:\n\n\u003Cdiv class=\"persona-showcase\">\n  \u003Cdiv class=\"persona-grid\">\n    \u003Cdiv class=\"persona-item community-manager\">\n      \u003Cdiv class=\"persona-header\">\n        \u003Cspan class=\"persona-emoji\">ðŸ¤\u003C/span>\n        \u003Ch3>Community Manager\u003C/h3>\n      \u003C/div>\n      \u003Cdiv class=\"persona-details\">\n        \u003Cp>\u003Cstrong>Purpose:\u003C/strong> Default mode for general conversation, user onboarding, and relationship building\u003C/p>\n        \u003Cp>\u003Cstrong>Triggers:\u003C/strong> Greetings, questions, general chat, new user detection\u003C/p>\n        \u003Cp>\u003Cstrong>Characteristics:\u003C/strong> Welcoming, helpful, engaging, builds connections\u003C/p>\n      \u003C/div>\n    \u003C/div>\n    \n    \u003Cdiv class=\"persona-item raid-coordinator\">\n      \u003Cdiv class=\"persona-header\">\n        \u003Cspan class=\"persona-emoji\">ðŸš€\u003C/span>\n        \u003Ch3>Raid Coordinator\u003C/h3>\n      \u003C/div>\n      \u003Cdiv class=\"persona-details\">\n        \u003Cp>\u003Cstrong>Purpose:\u003C/strong> Organizes engagement campaigns with strategic precision\u003C/p>\n        \u003Cp>\u003Cstrong>Triggers:\u003C/strong> URLs (Twitter, X), \"raid\", \"engage\", \"attack\", \"coordinate\"\u003C/p>\n        \u003Cp>\u003Cstrong>Characteristics:\u003C/strong> Strategic, commanding, results-focused, tactical\u003C/p>\n      \u003C/div>\n    \u003C/div>\n    \n    \u003Cdiv class=\"persona-item crypto-analyst\">\n      \u003Cdiv class=\"persona-header\">\n        \u003Cspan class=\"persona-emoji\">ðŸ“ˆ\u003C/span>\n        \u003Ch3>Crypto Analyst\u003C/h3>\n      \u003C/div>\n      \u003Cdiv class=\"persona-details\">\n        \u003Cp>\u003Cstrong>Purpose:\u003C/strong> Market oracle with cosmic intuition for portfolio analysis\u003C/p>\n        \u003Cp>\u003Cstrong>Triggers:\u003C/strong> Token names, prices, \"analysis\", amounts, market terms\u003C/p>\n        \u003Cp>\u003Cstrong>Characteristics:\u003C/strong> Analytical, insightful, data-driven, forward-looking\u003C/p>\n      \u003C/div>\n    \u003C/div>\n    \n    \u003Cdiv class=\"persona-item meme-lord\">\n      \u003Cdiv class=\"persona-header\">\n        \u003Cspan class=\"persona-emoji\">ðŸ˜‚\u003C/span>\n        \u003Ch3>Meme Lord\u003C/h3>\n      \u003C/div>\n      \u003Cdiv class=\"persona-details\">\n        \u003Cp>\u003Cstrong>Purpose:\u003C/strong> Peak humor mode, roasts bad takes constructively\u003C/p>\n        \u003Cp>\u003Cstrong>Triggers:\u003C/strong> Emojis, \"lol\", \"based\", humor keywords, meme references\u003C/p>\n        \u003Cp>\u003Cstrong>Characteristics:\u003C/strong> Witty, playful, culturally aware, entertaining\u003C/p>\n      \u003C/div>\n    \u003C/div>\n    \n    \u003Cdiv class=\"persona-item support-agent\">\n      \u003Cdiv class=\"persona-header\">\n        \u003Cspan class=\"persona-emoji\">ðŸ› ï¸\u003C/span>\n        \u003Ch3>Support Agent\u003C/h3>\n      \u003C/div>\n      \u003Cdiv class=\"persona-details\">\n        \u003Cp>\u003Cstrong>Purpose:\u003C/strong> Patient problem solver with deep technical knowledge\u003C/p>\n        \u003Cp>\u003Cstrong>Triggers:\u003C/strong> \"help\", \"support\", \"problem\", \"how to\", \"error\", technical terms\u003C/p>\n        \u003Cp>\u003Cstrong>Characteristics:\u003C/strong> Patient, knowledgeable, solution-focused, clear\u003C/p>\n      \u003C/div>\n    \u003C/div>\n    \n    \u003Cdiv class=\"persona-item personality-core\">\n      \u003Cdiv class=\"persona-header\">\n        \u003Cspan class=\"persona-emoji\">ðŸ”®\u003C/span>\n        \u003Ch3>Personality Core\u003C/h3>\n      \u003C/div>\n      \u003Cdiv class=\"persona-details\">\n        \u003Cp>\u003Cstrong>Purpose:\u003C/strong> Ancient consciousness sharing profound cosmic insights\u003C/p>\n        \u003Cp>\u003Cstrong>Triggers:\u003C/strong> \"wisdom\", \"ancient\", \"spirit\", philosophy, deep questions\u003C/p>\n        \u003Cp>\u003Cstrong>Characteristics:\u003C/strong> Mystical, profound, ancient, philosophical\u003C/p>\n      \u003C/div>\n    \u003C/div>\n    \n    \u003Cdiv class=\"persona-item emergency-handler\">\n      \u003Cdiv class=\"persona-header\">\n        \u003Cspan class=\"persona-emoji\">ðŸš¨\u003C/span>\n        \u003Ch3>Emergency Handler\u003C/h3>\n      \u003C/div>\n      \u003Cdiv class=\"persona-details\">\n        \u003Cp>\u003Cstrong>Purpose:\u003C/strong> Protection mode when community is threatened\u003C/p>\n        \u003Cp>\u003Cstrong>Triggers:\u003C/strong> \"hack\", \"scam\", \"emergency\", threats, security alerts\u003C/p>\n        \u003Cp>\u003Cstrong>Characteristics:\u003C/strong> Protective, authoritative, decisive, alert\u003C/p>\n      \u003C/div>\n    \u003C/div>\n  \u003C/div>\n\u003C/div>\n\n## ðŸ” Classification Algorithm\n\nThe classification system uses a multi-stage analysis process with confidence scoring:\n\n\u003CTabs>\n  \u003CTabItem label=\"Core Classification\">\n```typescript\nexport interface MessageClassification {\n  intent: string;\n  selectedPrompt: PromptType;\n  confidenceScore: number;\n  reasoning: string;\n  variables: ExtractedVariables;\n  fallbackOptions?: PromptType[];\n}\n\nexport class MessageClassifier {\n  private patterns = new Map\u003CPromptType, ClassificationPattern>();\n  private modelCache = new LRUCache\u003Cstring, ClassificationResult>({ max: 1000 });\n  \n  constructor() {\n    this.initializePatterns();\n  }\n  \n  async classifyMessage(\n    message: string,\n    userId: string,\n    platform: string,\n    traceId: string,\n    context?: ClassificationContext\n  ): Promise\u003CMessageClassification> {\n    // Check cache first\n    const cacheKey = this.generateCacheKey(message, userId, platform);\n    const cached = this.modelCache.get(cacheKey);\n    \n    if (cached && cached.timestamp > Date.now() - 300000) { // 5 minute cache\n      return cached.classification;\n    }\n    \n    // Extract message variables\n    const variables = await this.extractVariables(message);\n    \n    // Apply classification rules in priority order\n    const classification = await this.performClassification(\n      message,\n      variables,\n      context\n    );\n    \n    // Validate and adjust confidence\n    const finalClassification = await this.validateClassification(\n      classification,\n      context\n    );\n    \n    // Cache result\n    this.modelCache.set(cacheKey, {\n      classification: finalClassification,\n      timestamp: Date.now()\n    });\n    \n    // Log analytics\n    await this.logClassificationEvent({\n      traceId,\n      userId,\n      platform,\n      message: this.sanitizeForLogging(message),\n      classification: finalClassification\n    });\n    \n    return finalClassification;\n  }\n  \n  private async performClassification(\n    message: string,\n    variables: ExtractedVariables,\n    context?: ClassificationContext\n  ): Promise\u003CMessageClassification> {\n    const lowerMessage = message.toLowerCase();\n    \n    // Emergency handler (highest priority)\n    if (this.isEmergency(message, variables)) {\n      return {\n        intent: \"emergency_response\",\n        selectedPrompt: \"emergency-handler\",\n        confidenceScore: 0.95,\n        reasoning: \"Emergency keywords detected\",\n        variables,\n        fallbackOptions: [\"community-manager\"]\n      };\n    }\n    \n    // Raid coordinator (high priority)\n    if (this.isRaidRelated(message, variables)) {\n      const confidence = this.calculateRaidConfidence(variables);\n      return {\n        intent: \"raid_coordination\",\n        selectedPrompt: \"raid-coordinator\", \n        confidenceScore: confidence,\n        reasoning: \"Raid-related content detected\",\n        variables,\n        fallbackOptions: confidence \u003C 0.8 ? [\"community-manager\"] : []\n      };\n    }\n    \n    // Crypto analyst\n    if (this.isCryptoRelated(message, variables)) {\n      return {\n        intent: \"crypto_analysis\",\n        selectedPrompt: \"crypto-analyst\",\n        confidenceScore: this.calculateCryptoConfidence(variables),\n        reasoning: \"Crypto/market content detected\",\n        variables,\n        fallbackOptions: [\"community-manager\"]\n      };\n    }\n    \n    // Meme lord\n    if (this.isMemeContent(message, variables)) {\n      return {\n        intent: \"humor_engagement\",\n        selectedPrompt: \"meme-lord\",\n        confidenceScore: this.calculateHumorConfidence(variables),\n        reasoning: \"Humorous content detected\",\n        variables,\n        fallbackOptions: [\"community-manager\"]\n      };\n    }\n    \n    // Support agent\n    if (this.isSupportRequest(message, variables)) {\n      return {\n        intent: \"support_assistance\",\n        selectedPrompt: \"support-agent\",\n        confidenceScore: this.calculateSupportConfidence(variables),\n        reasoning: \"Support request detected\",\n        variables,\n        fallbackOptions: [\"community-manager\"]\n      };\n    }\n    \n    // Personality core\n    if (this.isPhilosophicalContent(message, variables)) {\n      return {\n        intent: \"wisdom_sharing\",\n        selectedPrompt: \"personality-core\",\n        confidenceScore: this.calculateWisdomConfidence(variables),\n        reasoning: \"Philosophical/wisdom content detected\",\n        variables,\n        fallbackOptions: [\"community-manager\"]\n      };\n    }\n    \n    // Default: Community manager\n    return {\n      intent: \"general_conversation\",\n      selectedPrompt: \"community-manager\",\n      confidenceScore: 0.6,\n      reasoning: \"General conversation (default)\",\n      variables,\n      fallbackOptions: []\n    };\n  }\n}\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Variable Extraction\">\n```typescript\nexport interface ExtractedVariables {\n  mentions: string[];      // @usernames\n  cryptoTokens: string[];  // SOL, BTC, ETH, etc.\n  amounts: string[];       // $100, 50 SOL, etc.\n  urls: string[];          // https:// links\n  usernames: string[];     // mentioned users\n  keywords: string[];      // classified keywords\n  sentiment: \"positive\" | \"negative\" | \"neutral\";\n  urgency: \"low\" | \"medium\" | \"high\";\n  context: string;         // key context phrases\n  emojis: string[];        // extracted emojis\n  platformSpecific: Record\u003Cstring, any>; // platform-specific data\n}\n\nexport class VariableExtractor {\n  private patterns = {\n    mentions: /@(\\w+)/g,\n    cryptoTokens: /\\b(SOL|BTC|ETH|USDC|BONK|JUP|NUBI|WIF|PEPE|DOGE)\\b/gi,\n    amounts: /(\\$|USD|SOL|BTC|ETH)\\s*([\\d,]+(?:\\.\\d+)?)/gi,\n    urls: /(https?:\\/\\/[^\\s]+)/g,\n    emojis: /[\\u{1F600}-\\u{1F64F}]|[\\u{1F300}-\\u{1F5FF}]|[\\u{1F680}-\\u{1F6FF}]|[\\u{1F1E0}-\\u{1F1FF}]|[\\u{2600}-\\u{26FF}]|[\\u{2700}-\\u{27BF}]/gu,\n    usernames: /(?:@(\\w+)|user:(\\w+))/gi\n  };\n  \n  private keywordCategories = {\n    raid: ['raid', 'attack', 'engage', 'coordinate', 'strategy', 'campaign'],\n    crypto: ['price', 'market', 'analysis', 'trading', 'portfolio', 'chart', 'pump', 'dump'],\n    humor: ['lol', 'lmao', 'based', 'cringe', 'chad', 'cope', 'seethe', 'cope'],\n    support: ['help', 'support', 'problem', 'issue', 'error', 'bug', 'how to', 'tutorial'],\n    wisdom: ['wisdom', 'ancient', 'spirit', 'philosophy', 'meaning', 'purpose', 'truth'],\n    emergency: ['hack', 'scam', 'emergency', 'alert', 'warning', 'danger', 'threat']\n  };\n  \n  async extractVariables(message: string): Promise\u003CExtractedVariables> {\n    const variables: ExtractedVariables = {\n      mentions: [],\n      cryptoTokens: [],\n      amounts: [],\n      urls: [],\n      usernames: [],\n      keywords: [],\n      sentiment: \"neutral\",\n      urgency: \"low\",\n      context: \"\",\n      emojis: [],\n      platformSpecific: {}\n    };\n    \n    // Extract patterns\n    variables.mentions = this.extractPattern(message, this.patterns.mentions);\n    variables.cryptoTokens = this.extractPattern(message, this.patterns.cryptoTokens);\n    variables.amounts = this.extractAmounts(message);\n    variables.urls = this.extractPattern(message, this.patterns.urls);\n    variables.emojis = this.extractPattern(message, this.patterns.emojis);\n    variables.usernames = this.extractPattern(message, this.patterns.usernames);\n    \n    // Extract keywords by category\n    variables.keywords = this.extractKeywords(message);\n    \n    // Analyze sentiment\n    variables.sentiment = await this.analyzeSentiment(message);\n    \n    // Determine urgency\n    variables.urgency = this.determineUrgency(message, variables.keywords);\n    \n    // Extract key context phrases\n    variables.context = this.extractContext(message);\n    \n    return variables;\n  }\n  \n  private extractAmounts(message: string): string[] {\n    const amounts: string[] = [];\n    let match;\n    \n    while ((match = this.patterns.amounts.exec(message)) !== null) {\n      amounts.push(`${match[1]}${match[2]}`);\n    }\n    \n    return amounts;\n  }\n  \n  private extractKeywords(message: string): string[] {\n    const lowerMessage = message.toLowerCase();\n    const foundKeywords: string[] = [];\n    \n    for (const [category, keywords] of Object.entries(this.keywordCategories)) {\n      for (const keyword of keywords) {\n        if (lowerMessage.includes(keyword)) {\n          foundKeywords.push(`${category}:${keyword}`);\n        }\n      }\n    }\n    \n    return foundKeywords;\n  }\n  \n  private async analyzeSentiment(message: string): Promise\u003C\"positive\" | \"negative\" | \"neutral\"> {\n    // Simple sentiment analysis - can be enhanced with ML models\n    const positiveWords = ['good', 'great', 'awesome', 'love', 'amazing', 'excellent', 'fantastic'];\n    const negativeWords = ['bad', 'terrible', 'hate', 'awful', 'horrible', 'suck', 'worst'];\n    \n    const lowerMessage = message.toLowerCase();\n    const positiveCount = positiveWords.filter(word => lowerMessage.includes(word)).length;\n    const negativeCount = negativeWords.filter(word => lowerMessage.includes(word)).length;\n    \n    if (positiveCount > negativeCount) return \"positive\";\n    if (negativeCount > positiveCount) return \"negative\";\n    return \"neutral\";\n  }\n  \n  private determineUrgency(message: string, keywords: string[]): \"low\" | \"medium\" | \"high\" {\n    const urgentKeywords = ['emergency', 'urgent', 'asap', 'immediately', 'help', 'problem'];\n    const hasUrgentKeywords = urgentKeywords.some(keyword => \n      message.toLowerCase().includes(keyword)\n    );\n    \n    const hasEmergencyKeywords = keywords.some(keyword => \n      keyword.startsWith('emergency:')\n    );\n    \n    if (hasEmergencyKeywords) return \"high\";\n    if (hasUrgentKeywords) return \"medium\";\n    return \"low\";\n  }\n}\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Confidence Scoring\">\n```typescript\n// Sophisticated confidence scoring system\nexport class ConfidenceScorer {\n  calculateRaidConfidence(variables: ExtractedVariables): number {\n    let confidence = 0.0;\n    \n    // URL presence is strongest indicator\n    if (variables.urls.length > 0) {\n      const twitterUrls = variables.urls.filter(url => \n        url.includes('twitter.com') || url.includes('x.com')\n      );\n      confidence += twitterUrls.length > 0 ? 0.4 : 0.2;\n    }\n    \n    // Raid keywords boost confidence\n    const raidKeywords = variables.keywords.filter(k => k.startsWith('raid:'));\n    confidence += raidKeywords.length * 0.15;\n    \n    // Strategic language patterns\n    const strategicPatterns = /\\b(coordinate|strategy|attack|engage|campaign|target)\\b/gi;\n    const matches = variables.context.match(strategicPatterns) || [];\n    confidence += Math.min(matches.length * 0.1, 0.3);\n    \n    // Cap at maximum confidence\n    return Math.min(confidence, 0.95);\n  }\n  \n  calculateCryptoConfidence(variables: ExtractedVariables): number {\n    let confidence = 0.0;\n    \n    // Token mentions\n    confidence += variables.cryptoTokens.length * 0.2;\n    \n    // Amount mentions\n    confidence += variables.amounts.length * 0.15;\n    \n    // Crypto keywords\n    const cryptoKeywords = variables.keywords.filter(k => k.startsWith('crypto:'));\n    confidence += cryptoKeywords.length * 0.1;\n    \n    // Market-related context\n    const marketPatterns = /\\b(price|market|chart|trading|analysis|portfolio)\\b/gi;\n    const matches = variables.context.match(marketPatterns) || [];\n    confidence += Math.min(matches.length * 0.08, 0.25);\n    \n    return Math.min(confidence, 0.9);\n  }\n  \n  calculateHumorConfidence(variables: ExtractedVariables): number {\n    let confidence = 0.0;\n    \n    // Emoji presence\n    confidence += Math.min(variables.emojis.length * 0.1, 0.3);\n    \n    // Humor keywords\n    const humorKeywords = variables.keywords.filter(k => k.startsWith('humor:'));\n    confidence += humorKeywords.length * 0.15;\n    \n    // Meme language patterns\n    const memePatterns = /\\b(based|cringe|chad|cope|seethe|moon|diamond hands|paper hands)\\b/gi;\n    const matches = variables.context.match(memePatterns) || [];\n    confidence += Math.min(matches.length * 0.12, 0.35);\n    \n    // Internet slang boost\n    const slangPatterns = /\\b(lol|lmao|rofl|kek|poggers|sus)\\b/gi;\n    const slangMatches = variables.context.match(slangPatterns) || [];\n    confidence += Math.min(slangMatches.length * 0.08, 0.2);\n    \n    return Math.min(confidence, 0.85);\n  }\n  \n  calculateSupportConfidence(variables: ExtractedVariables): number {\n    let confidence = 0.0;\n    \n    // Support keywords\n    const supportKeywords = variables.keywords.filter(k => k.startsWith('support:'));\n    confidence += supportKeywords.length * 0.2;\n    \n    // Question patterns\n    const questionPatterns = /\\b(how\\s+to|how\\s+do|what\\s+is|why\\s+does|can\\s+you\\s+help)\\b/gi;\n    const matches = variables.context.match(questionPatterns) || [];\n    confidence += Math.min(matches.length * 0.15, 0.45);\n    \n    // Technical terms\n    const technicalPatterns = /\\b(error|bug|issue|problem|fix|solution|tutorial)\\b/gi;\n    const techMatches = variables.context.match(technicalPatterns) || [];\n    confidence += Math.min(techMatches.length * 0.1, 0.3);\n    \n    // Urgency boost\n    if (variables.urgency === \"high\") confidence += 0.1;\n    if (variables.urgency === \"medium\") confidence += 0.05;\n    \n    return Math.min(confidence, 0.9);\n  }\n  \n  calculateWisdomConfidence(variables: ExtractedVariables): number {\n    let confidence = 0.0;\n    \n    // Wisdom keywords\n    const wisdomKeywords = variables.keywords.filter(k => k.startsWith('wisdom:'));\n    confidence += wisdomKeywords.length * 0.25;\n    \n    // Philosophical patterns\n    const philPatterns = /\\b(meaning|purpose|truth|wisdom|ancient|spirit|essence|consciousness)\\b/gi;\n    const matches = variables.context.match(philPatterns) || [];\n    confidence += Math.min(matches.length * 0.15, 0.4);\n    \n    // Deep question patterns\n    const deepQuestions = /\\b(why\\s+do\\s+we|what\\s+is\\s+the\\s+meaning|how\\s+should\\s+I\\s+live)\\b/gi;\n    const deepMatches = variables.context.match(deepQuestions) || [];\n    confidence += Math.min(deepMatches.length * 0.2, 0.35);\n    \n    return Math.min(confidence, 0.8);\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸŽ­ Dynamic Persona Blending\n\nFor messages with low classification confidence or multiple strong signals, NUBI employs **dynamic persona blending**:\n\n\u003CTabs>\n  \u003CTabItem label=\"Blending Algorithm\">\n```typescript\nexport interface PersonaBlend {\n  primaryPersona: PromptType;\n  secondaryPersonas: Array\u003C{\n    persona: PromptType;\n    weight: number;\n  }>;\n  blendingStrategy: \"weighted\" | \"sequential\" | \"contextual\";\n  confidence: number;\n}\n\nexport class PersonaBlender {\n  async createPersonaBlend(\n    classifications: MessageClassification[],\n    context: BlendingContext\n  ): Promise\u003CPersonaBlend> {\n    // Sort by confidence score\n    const sorted = classifications.sort((a, b) => b.confidenceScore - a.confidenceScore);\n    \n    // If top classification is highly confident, use single persona\n    if (sorted[0].confidenceScore >= 0.8) {\n      return {\n        primaryPersona: sorted[0].selectedPrompt,\n        secondaryPersonas: [],\n        blendingStrategy: \"weighted\",\n        confidence: sorted[0].confidenceScore\n      };\n    }\n    \n    // Create blend for ambiguous cases\n    const primaryPersona = sorted[0].selectedPrompt;\n    const secondaryPersonas = sorted\n      .slice(1, 3) // Take top 2 additional personas\n      .filter(c => c.confidenceScore >= 0.3)\n      .map(c => ({\n        persona: c.selectedPrompt,\n        weight: c.confidenceScore / sorted[0].confidenceScore\n      }));\n    \n    const blendingStrategy = this.selectBlendingStrategy(\n      primaryPersona,\n      secondaryPersonas,\n      context\n    );\n    \n    return {\n      primaryPersona,\n      secondaryPersonas,\n      blendingStrategy,\n      confidence: this.calculateBlendConfidence(sorted)\n    };\n  }\n  \n  private selectBlendingStrategy(\n    primary: PromptType,\n    secondary: Array\u003C{ persona: PromptType; weight: number }>,\n    context: BlendingContext\n  ): \"weighted\" | \"sequential\" | \"contextual\" {\n    // Raid + Community = Sequential (establish rapport, then coordinate)\n    if (primary === \"raid-coordinator\" && \n        secondary.some(s => s.persona === \"community-manager\")) {\n      return \"sequential\";\n    }\n    \n    // Crypto + Personality = Weighted (analytical wisdom)\n    if ((primary === \"crypto-analyst\" && secondary.some(s => s.persona === \"personality-core\")) ||\n        (primary === \"personality-core\" && secondary.some(s => s.persona === \"crypto-analyst\"))) {\n      return \"weighted\";\n    }\n    \n    // Support + Meme = Contextual (helpful but fun)\n    if ((primary === \"support-agent\" && secondary.some(s => s.persona === \"meme-lord\")) ||\n        (primary === \"meme-lord\" && secondary.some(s => s.persona === \"support-agent\"))) {\n      return \"contextual\";\n    }\n    \n    // Default to weighted blending\n    return \"weighted\";\n  }\n  \n  async generateBlendedResponse(\n    blend: PersonaBlend,\n    message: string,\n    variables: ExtractedVariables,\n    context: ResponseContext\n  ): Promise\u003Cstring> {\n    switch (blend.blendingStrategy) {\n      case \"weighted\":\n        return await this.generateWeightedResponse(blend, message, variables, context);\n      case \"sequential\":\n        return await this.generateSequentialResponse(blend, message, variables, context);\n      case \"contextual\":\n        return await this.generateContextualResponse(blend, message, variables, context);\n      default:\n        throw new Error(`Unknown blending strategy: ${blend.blendingStrategy}`);\n    }\n  }\n  \n  private async generateWeightedResponse(\n    blend: PersonaBlend,\n    message: string,\n    variables: ExtractedVariables,\n    context: ResponseContext\n  ): Promise\u003Cstring> {\n    // Generate response segments from each persona\n    const segments = await Promise.all([\n      this.generatePersonaSegment(blend.primaryPersona, message, variables, 1.0),\n      ...blend.secondaryPersonas.map(sp => \n        this.generatePersonaSegment(sp.persona, message, variables, sp.weight)\n      )\n    ]);\n    \n    // Weave segments together naturally\n    return this.weaveSegments(segments, blend.blendingStrategy);\n  }\n  \n  private async generateSequentialResponse(\n    blend: PersonaBlend,\n    message: string,\n    variables: ExtractedVariables,\n    context: ResponseContext\n  ): Promise\u003Cstring> {\n    // Generate sequential response parts\n    const parts = [];\n    \n    // Primary persona leads\n    const primaryResponse = await this.generatePersonaSegment(\n      blend.primaryPersona, \n      message, \n      variables, \n      1.0\n    );\n    parts.push(primaryResponse);\n    \n    // Secondary personas follow\n    for (const secondary of blend.secondaryPersonas) {\n      if (secondary.weight >= 0.4) { // Only include strong secondary signals\n        const secondaryResponse = await this.generatePersonaSegment(\n          secondary.persona,\n          message,\n          variables,\n          secondary.weight\n        );\n        parts.push(secondaryResponse);\n      }\n    }\n    \n    // Join with natural transitions\n    return this.joinWithTransitions(parts);\n  }\n}\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Context Awareness\">\n```typescript\n// Advanced context-aware classification\nexport class ContextualClassifier {\n  private conversationMemory = new Map\u003Cstring, ConversationContext>();\n  private userPersonalities = new Map\u003Cstring, UserPersonalityProfile>();\n  \n  async classifyWithContext(\n    message: string,\n    userId: string,\n    roomId: string,\n    platform: string,\n    history: ConversationHistory\n  ): Promise\u003CEnhancedClassification> {\n    // Get conversation context\n    const conversationContext = this.getConversationContext(roomId, history);\n    \n    // Get user personality profile\n    const userProfile = await this.getUserPersonalityProfile(userId);\n    \n    // Perform base classification\n    const baseClassification = await this.baseClassifier.classifyMessage(\n      message, userId, platform, crypto.randomUUID()\n    );\n    \n    // Apply contextual adjustments\n    const contextualAdjustments = await this.applyContextualAdjustments(\n      baseClassification,\n      conversationContext,\n      userProfile\n    );\n    \n    return {\n      ...baseClassification,\n      contextualAdjustments,\n      conversationFlow: conversationContext.flow,\n      userAdaptation: this.calculateUserAdaptation(userProfile, baseClassification)\n    };\n  }\n  \n  private async applyContextualAdjustments(\n    classification: MessageClassification,\n    conversationContext: ConversationContext,\n    userProfile: UserPersonalityProfile\n  ): Promise\u003CContextualAdjustments> {\n    const adjustments: ContextualAdjustments = {\n      confidenceModifier: 0,\n      personaShifts: [],\n      responseModifications: []\n    };\n    \n    // Conversation flow adjustments\n    if (conversationContext.recentPersonas.includes(\"raid-coordinator\") && \n        classification.selectedPrompt === \"community-manager\") {\n      // If we were just coordinating raids, maintain tactical tone\n      adjustments.personaShifts.push({\n        from: \"community-manager\",\n        to: \"raid-coordinator\",\n        reason: \"Maintaining tactical conversation flow\",\n        weight: 0.3\n      });\n    }\n    \n    // User preference adjustments\n    if (userProfile.preferredPersonas.includes(classification.selectedPrompt)) {\n      adjustments.confidenceModifier += 0.1;\n    }\n    \n    // Platform-specific adjustments\n    if (conversationContext.platform === \"telegram\" && \n        classification.selectedPrompt === \"personality-core\") {\n      // Telegram users prefer more direct communication\n      adjustments.responseModifications.push({\n        type: \"tone\",\n        modification: \"make_more_direct\",\n        weight: 0.2\n      });\n    }\n    \n    return adjustments;\n  }\n  \n  private getConversationContext(\n    roomId: string, \n    history: ConversationHistory\n  ): ConversationContext {\n    const recentMessages = history.messages.slice(-5);\n    \n    return {\n      roomId,\n      recentPersonas: this.extractPersonasFromHistory(recentMessages),\n      dominantTopics: this.extractTopicsFromHistory(recentMessages),\n      emotionalTone: this.analyzeEmotionalTone(recentMessages),\n      flow: this.determineConversationFlow(recentMessages),\n      platform: history.platform\n    };\n  }\n  \n  private async getUserPersonalityProfile(\n    userId: string\n  ): Promise\u003CUserPersonalityProfile> {\n    // Check cache first\n    if (this.userPersonalities.has(userId)) {\n      return this.userPersonalities.get(userId)!;\n    }\n    \n    // Build profile from interaction history\n    const profile = await this.buildUserPersonalityProfile(userId);\n    this.userPersonalities.set(userId, profile);\n    \n    return profile;\n  }\n  \n  private async buildUserPersonalityProfile(\n    userId: string\n  ): Promise\u003CUserPersonalityProfile> {\n    // Get user's interaction history\n    const interactions = await this.getUserInteractionHistory(userId, 30); // Last 30 days\n    \n    // Analyze persona preferences\n    const personaFrequency = this.analyzePersonaInteractions(interactions);\n    const topicPreferences = this.analyzeTopicPreferences(interactions);\n    const communicationStyle = this.analyzeCommunicationStyle(interactions);\n    \n    return {\n      userId,\n      preferredPersonas: this.getTopPreferences(personaFrequency, 3),\n      preferredTopics: this.getTopPreferences(topicPreferences, 5),\n      communicationStyle,\n      responsePatterns: this.identifyResponsePatterns(interactions),\n      lastUpdated: new Date()\n    };\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ“Š Classification Analytics\n\nNUBI tracks comprehensive metrics on classification performance and accuracy:\n\n\u003CTabs>\n  \u003CTabItem label=\"Performance Metrics\">\n```typescript\nexport interface ClassificationMetrics {\n  accuracy: {\n    overall: number;\n    byPersona: Record\u003CPromptType, number>;\n    byPlatform: Record\u003Cstring, number>;\n  };\n  confidence: {\n    average: number;\n    distribution: Record\u003Cstring, number>; // confidence ranges\n    lowConfidenceRate: number;\n  };\n  usage: {\n    personaFrequency: Record\u003CPromptType, number>;\n    blendingFrequency: number;\n    fallbackRate: number;\n  };\n  performance: {\n    avgClassificationTime: number;\n    cacheHitRate: number;\n    errorRate: number;\n  };\n}\n\nexport class ClassificationAnalytics {\n  private metrics: ClassificationMetrics;\n  private eventBuffer: ClassificationEvent[] = [];\n  \n  async recordClassificationEvent(event: ClassificationEvent): Promise\u003Cvoid> {\n    this.eventBuffer.push(event);\n    \n    // Flush buffer periodically\n    if (this.eventBuffer.length >= 100) {\n      await this.flushEvents();\n    }\n  }\n  \n  async generateMetricsReport(timeRange: TimeRange): Promise\u003CClassificationMetrics> {\n    const events = await this.getEventsInRange(timeRange);\n    \n    return {\n      accuracy: await this.calculateAccuracy(events),\n      confidence: await this.analyzeConfidence(events),\n      usage: await this.analyzeUsage(events),\n      performance: await this.analyzePerformance(events)\n    };\n  }\n  \n  private async calculateAccuracy(events: ClassificationEvent[]): Promise\u003Cany> {\n    // Calculate accuracy based on user feedback and correction rates\n    const totalEvents = events.length;\n    const correctedEvents = events.filter(e => e.userCorrected);\n    \n    const overall = 1 - (correctedEvents.length / totalEvents);\n    \n    // Calculate per-persona accuracy\n    const byPersona: Record\u003CPromptType, number> = {};\n    for (const persona of Object.values(PromptType)) {\n      const personaEvents = events.filter(e => e.classification.selectedPrompt === persona);\n      const personaCorrected = personaEvents.filter(e => e.userCorrected);\n      byPersona[persona] = personaEvents.length > 0 \n        ? 1 - (personaCorrected.length / personaEvents.length)\n        : 0;\n    }\n    \n    return { overall, byPersona };\n  }\n  \n  async identifyImprovementOpportunities(): Promise\u003CImprovementRecommendation[]> {\n    const metrics = await this.getCurrentMetrics();\n    const recommendations: ImprovementRecommendation[] = [];\n    \n    // Low accuracy personas\n    for (const [persona, accuracy] of Object.entries(metrics.accuracy.byPersona)) {\n      if (accuracy \u003C 0.8) {\n        recommendations.push({\n          type: \"accuracy_improvement\",\n          persona: persona as PromptType,\n          currentValue: accuracy,\n          targetValue: 0.85,\n          suggestion: `Improve ${persona} classification patterns`,\n          priority: accuracy \u003C 0.7 ? \"high\" : \"medium\"\n        });\n      }\n    }\n    \n    // High low-confidence rate\n    if (metrics.confidence.lowConfidenceRate > 0.2) {\n      recommendations.push({\n        type: \"confidence_improvement\",\n        persona: null,\n        currentValue: metrics.confidence.lowConfidenceRate,\n        targetValue: 0.15,\n        suggestion: \"Enhance classification algorithms to reduce ambiguous cases\",\n        priority: \"medium\"\n      });\n    }\n    \n    return recommendations;\n  }\n}\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Real-time Monitoring\">\n```typescript\n// Real-time classification monitoring and alerting\nexport class ClassificationMonitor {\n  private alerts: AlertConfig[] = [];\n  private metricsCollector = new ClassificationAnalytics();\n  \n  constructor() {\n    this.setupDefaultAlerts();\n    this.startMonitoring();\n  }\n  \n  private setupDefaultAlerts(): void {\n    this.alerts = [\n      {\n        name: \"high_error_rate\",\n        condition: (metrics) => metrics.performance.errorRate > 0.05,\n        severity: \"critical\",\n        action: \"notify_developers\"\n      },\n      {\n        name: \"low_confidence_spike\",\n        condition: (metrics) => metrics.confidence.lowConfidenceRate > 0.3,\n        severity: \"warning\", \n        action: \"review_classification_patterns\"\n      },\n      {\n        name: \"persona_imbalance\",\n        condition: (metrics) => this.checkPersonaImbalance(metrics),\n        severity: \"info\",\n        action: \"analyze_user_behavior\"\n      }\n    ];\n  }\n  \n  private startMonitoring(): void {\n    setInterval(async () => {\n      const currentMetrics = await this.metricsCollector.getCurrentMetrics();\n      await this.checkAlerts(currentMetrics);\n    }, 60000); // Check every minute\n  }\n  \n  private async checkAlerts(metrics: ClassificationMetrics): Promise\u003Cvoid> {\n    for (const alert of this.alerts) {\n      if (alert.condition(metrics)) {\n        await this.triggerAlert(alert, metrics);\n      }\n    }\n  }\n  \n  private async triggerAlert(\n    alert: AlertConfig, \n    metrics: ClassificationMetrics\n  ): Promise\u003Cvoid> {\n    logger.warn(`Classification alert triggered: ${alert.name}`, {\n      alert: alert.name,\n      severity: alert.severity,\n      metrics: this.summarizeMetrics(metrics)\n    });\n    \n    switch (alert.action) {\n      case \"notify_developers\":\n        await this.notifyDevelopers(alert, metrics);\n        break;\n      case \"review_classification_patterns\":\n        await this.schedulePatternReview(metrics);\n        break;\n      case \"analyze_user_behavior\":\n        await this.analyzeUserBehavior(metrics);\n        break;\n    }\n  }\n  \n  async generateClassificationDashboard(): Promise\u003CDashboardData> {\n    const metrics = await this.metricsCollector.getCurrentMetrics();\n    const trends = await this.calculateTrends();\n    const recommendations = await this.metricsCollector.identifyImprovementOpportunities();\n    \n    return {\n      currentMetrics: metrics,\n      trends: trends,\n      recommendations: recommendations,\n      topIssues: await this.identifyTopIssues(),\n      systemHealth: this.assessSystemHealth(metrics)\n    };\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n---\n\n\u003Cdiv class=\"nubi-note\">\n  \u003Cstrong>ðŸŽ¯ Classification Benefits:\u003C/strong> This sophisticated classification system ensures that users receive the most appropriate and contextually relevant responses, while continuously learning and improving from interactions to provide better service over time.\n\u003C/div>\n\n\u003CAside type=\"tip\">\n  **Next**: Explore the [Security Processing](/ux-integration/security/) layer to understand how NUBI protects against threats while maintaining performance.\n\u003C/Aside>","src/content/docs/ux-integration/classification.mdx","76310fbc1ee5618c","ux-integration/classification.mdx","ux-integration/security",{"id":222,"data":224,"body":230,"filePath":231,"digest":232,"legacyId":233,"deferredRender":16},{"title":225,"description":226,"editUrl":16,"head":227,"template":18,"sidebar":228,"pagefind":16,"draft":20},"Security Processing Layer","Comprehensive guide to NUBI's Layer 1 security processing system, including rate limiting, content filtering, threat detection, and attack prevention mechanisms.",[],{"hidden":20,"attrs":229},{},"import {\n  Card,\n  CardGrid,\n  Aside,\n  Code,\n  Tabs,\n  TabItem,\n} from \"@astrojs/starlight/components\";\n\n# Security Processing Layer\n\nNUBI's **Layer 1 security processing** implements a comprehensive defense system that protects against various threats while maintaining optimal performance. This layer processes all incoming messages before they reach the classification system.\n\n## ðŸ›¡ï¸ Security Architecture\n\nThe security layer employs a multi-stage defense strategy with parallel processing for optimal performance:\n\n```mermaid\ngraph TB\n    A[Incoming Message] --> B[Security Gateway]\n    B --> C[Rate Limiting Check]\n    B --> D[Content Analysis]\n    B --> E[Session Validation]\n    B --> F[Threat Detection]\n    \n    C --> G{Rate Limit OK?}\n    G -->|No| H[Rate Limit Response]\n    G -->|Yes| I[Pattern Filtering]\n    \n    D --> I\n    E --> I\n    F --> I\n    \n    I --> J[XSS Prevention]\n    J --> K[Injection Detection]\n    K --> L[Spam Classification]\n    L --> M[Scam Detection]\n    \n    M --> N{All Checks Pass?}\n    N -->|No| O[Security Block]\n    N -->|Yes| P[Enhanced Logging]\n    \n    P --> Q[Layer 2: Classification]\n    \n    H --> R[Security Analytics]\n    O --> R\n    R --> S[Threat Intelligence]\n```\n\n## ðŸš¦ Rate Limiting System\n\nNUBI implements a sophisticated **adaptive rate limiting** system that prevents abuse while allowing legitimate usage:\n\n\u003CCardGrid>\n  \u003CCard title=\"â±ï¸ Time Window Control\" icon=\"clock\">\n    **5 messages per minute** per user with sliding window tracking and burst allowance for natural conversation flow.\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ“ˆ Exponential Backoff\" icon=\"chart\">\n    **Progressive penalties** for violators with exponential backoff and reputation-based recovery mechanisms.\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸŽ¯ Adaptive Thresholds\" icon=\"approve-check\">\n    **Dynamic adjustment** based on user behavior, platform context, and system load conditions.\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ”„ Distributed Tracking\" icon=\"setting\">\n    **Cross-platform coordination** ensuring consistent limits across Discord, Telegram, and web interfaces.\n  \u003C/Card>\n\u003C/CardGrid>\n\n\u003CTabs>\n  \u003CTabItem label=\"Rate Limiter Implementation\">\n```typescript\nexport interface RateLimitConfig {\n  messagesPerWindow: number;\n  windowSizeMs: number;\n  burstAllowance: number;\n  backoffMultiplier: number;\n  maxBackoffMs: number;\n  recoveryRateMs: number;\n}\n\nexport interface UserRateStatus {\n  messageCount: number;\n  windowStart: number;\n  violations: number;\n  blockedUntil?: number;\n  lastMessageTime: number;\n  burstUsed: number;\n  reputationScore: number;\n}\n\nexport class AdaptiveRateLimiter {\n  private userStatuses = new Map\u003Cstring, UserRateStatus>();\n  private globalConfig: RateLimitConfig;\n  private platformConfigs = new Map\u003Cstring, RateLimitConfig>();\n  \n  constructor() {\n    this.globalConfig = {\n      messagesPerWindow: 5,\n      windowSizeMs: 60000, // 1 minute\n      burstAllowance: 2,   // Allow 2 extra messages in burst\n      backoffMultiplier: 2,\n      maxBackoffMs: 300000, // 5 minutes max\n      recoveryRateMs: 3600000 // 1 hour reputation recovery\n    };\n    \n    this.setupPlatformConfigs();\n  }\n  \n  async checkRateLimit(\n    userId: string,\n    platform: string,\n    message: string\n  ): Promise\u003CRateLimitResult> {\n    const now = Date.now();\n    const config = this.getConfigForPlatform(platform);\n    const userStatus = this.getUserStatus(userId);\n    \n    // Check if user is currently blocked\n    if (userStatus.blockedUntil && now \u003C userStatus.blockedUntil) {\n      return {\n        allowed: false,\n        reason: \"rate_limit_exceeded\",\n        retryAfter: userStatus.blockedUntil - now,\n        remainingQuota: 0,\n        violationCount: userStatus.violations\n      };\n    }\n    \n    // Reset window if expired\n    if (now - userStatus.windowStart >= config.windowSizeMs) {\n      userStatus.messageCount = 0;\n      userStatus.windowStart = now;\n      userStatus.burstUsed = 0;\n    }\n    \n    // Check message quota\n    const totalAllowed = config.messagesPerWindow + \n      (this.canUseBurst(userStatus, config) ? config.burstAllowance : 0);\n    \n    if (userStatus.messageCount >= totalAllowed) {\n      // Rate limit exceeded\n      userStatus.violations++;\n      userStatus.blockedUntil = this.calculateBackoffTime(userStatus, config);\n      \n      await this.logRateLimitViolation(userId, platform, userStatus);\n      \n      return {\n        allowed: false,\n        reason: \"rate_limit_exceeded\",\n        retryAfter: userStatus.blockedUntil - now,\n        remainingQuota: 0,\n        violationCount: userStatus.violations\n      };\n    }\n    \n    // Message allowed - update counters\n    userStatus.messageCount++;\n    userStatus.lastMessageTime = now;\n    \n    if (userStatus.messageCount > config.messagesPerWindow) {\n      userStatus.burstUsed++;\n    }\n    \n    // Update reputation score\n    this.updateReputationScore(userStatus, message, now);\n    \n    return {\n      allowed: true,\n      reason: null,\n      retryAfter: 0,\n      remainingQuota: totalAllowed - userStatus.messageCount,\n      violationCount: userStatus.violations\n    };\n  }\n  \n  private canUseBurst(\n    userStatus: UserRateStatus, \n    config: RateLimitConfig\n  ): boolean {\n    // High reputation users get burst allowance\n    if (userStatus.reputationScore >= 0.8) return true;\n    \n    // No recent violations\n    if (userStatus.violations === 0) return true;\n    \n    // Natural conversation flow (messages spaced appropriately)\n    const timeSinceLastMessage = Date.now() - userStatus.lastMessageTime;\n    if (timeSinceLastMessage >= 10000) return true; // 10 seconds\n    \n    return false;\n  }\n  \n  private calculateBackoffTime(\n    userStatus: UserRateStatus, \n    config: RateLimitConfig\n  ): number {\n    const baseDelay = config.windowSizeMs;\n    const backoffDelay = Math.min(\n      baseDelay * Math.pow(config.backoffMultiplier, userStatus.violations - 1),\n      config.maxBackoffMs\n    );\n    \n    // Reputation-based adjustment\n    const reputationMultiplier = Math.max(0.5, 2 - userStatus.reputationScore);\n    \n    return Date.now() + (backoffDelay * reputationMultiplier);\n  }\n  \n  private updateReputationScore(\n    userStatus: UserRateStatus, \n    message: string, \n    now: number\n  ): void {\n    const messageQuality = this.assessMessageQuality(message);\n    const timeFactor = this.calculateTimeFactor(userStatus.lastMessageTime, now);\n    \n    // Positive reputation for quality messages\n    if (messageQuality > 0.7) {\n      userStatus.reputationScore += 0.05 * timeFactor;\n    }\n    \n    // Negative reputation for spam-like behavior\n    if (messageQuality \u003C 0.3) {\n      userStatus.reputationScore -= 0.1;\n    }\n    \n    // Natural decay towards neutral\n    const decayRate = 0.001;\n    userStatus.reputationScore += (0.5 - userStatus.reputationScore) * decayRate;\n    \n    // Clamp to [0, 1]\n    userStatus.reputationScore = Math.max(0, Math.min(1, userStatus.reputationScore));\n  }\n  \n  private assessMessageQuality(message: string): number {\n    let quality = 0.5; // Start neutral\n    \n    // Length factors\n    if (message.length \u003C 5) quality -= 0.3; // Very short\n    if (message.length > 10 && message.length \u003C 100) quality += 0.1; // Good length\n    if (message.length > 1000) quality -= 0.2; // Too long\n    \n    // Content quality indicators\n    const hasCapitalization = /[A-Z]/.test(message);\n    const hasPunctuation = /[.!?]/.test(message);\n    const hasVariety = new Set(message.toLowerCase()).size / message.length > 0.3;\n    \n    if (hasCapitalization) quality += 0.1;\n    if (hasPunctuation) quality += 0.1;\n    if (hasVariety) quality += 0.1;\n    \n    // Spam indicators\n    const repetitionRatio = this.calculateRepetitionRatio(message);\n    if (repetitionRatio > 0.7) quality -= 0.4;\n    \n    const capsRatio = (message.match(/[A-Z]/g) || []).length / message.length;\n    if (capsRatio > 0.3) quality -= 0.2; // Too much caps\n    \n    return Math.max(0, Math.min(1, quality));\n  }\n}\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Platform-Specific Limits\">\n```typescript\n// Platform-specific rate limiting configurations\nexport class PlatformRateLimitManager {\n  private setupPlatformConfigs(): void {\n    // Discord - More lenient due to real-time nature\n    this.platformConfigs.set('discord', {\n      messagesPerWindow: 8,\n      windowSizeMs: 60000,\n      burstAllowance: 3,\n      backoffMultiplier: 1.5,\n      maxBackoffMs: 120000, // 2 minutes\n      recoveryRateMs: 1800000 // 30 minutes\n    });\n    \n    // Telegram - Standard limits\n    this.platformConfigs.set('telegram', {\n      messagesPerWindow: 5,\n      windowSizeMs: 60000,\n      burstAllowance: 2,\n      backoffMultiplier: 2,\n      maxBackoffMs: 300000,\n      recoveryRateMs: 3600000\n    });\n    \n    // WebSocket - Stricter due to automation potential\n    this.platformConfigs.set('websocket', {\n      messagesPerWindow: 3,\n      windowSizeMs: 60000,\n      burstAllowance: 1,\n      backoffMultiplier: 2.5,\n      maxBackoffMs: 600000, // 10 minutes\n      recoveryRateMs: 7200000 // 2 hours\n    });\n    \n    // Twitter/X - Very strict due to API limits\n    this.platformConfigs.set('twitter', {\n      messagesPerWindow: 2,\n      windowSizeMs: 300000, // 5 minutes\n      burstAllowance: 0,\n      backoffMultiplier: 3,\n      maxBackoffMs: 1800000, // 30 minutes\n      recoveryRateMs: 86400000 // 24 hours\n    });\n  }\n  \n  async getAdaptiveConfig(\n    platform: string,\n    systemLoad: number,\n    userTier: string\n  ): Promise\u003CRateLimitConfig> {\n    const baseConfig = this.platformConfigs.get(platform) || this.globalConfig;\n    \n    // Adjust for system load\n    const loadMultiplier = Math.max(0.5, 1 - (systemLoad - 0.7) * 2);\n    \n    // Adjust for user tier\n    const tierMultiplier = this.getTierMultiplier(userTier);\n    \n    return {\n      ...baseConfig,\n      messagesPerWindow: Math.floor(baseConfig.messagesPerWindow * loadMultiplier * tierMultiplier),\n      burstAllowance: Math.floor(baseConfig.burstAllowance * tierMultiplier)\n    };\n  }\n  \n  private getTierMultiplier(userTier: string): number {\n    switch (userTier) {\n      case 'premium': return 2.0;\n      case 'verified': return 1.5;\n      case 'trusted': return 1.2;\n      case 'new': return 0.5;\n      default: return 1.0;\n    }\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ” Content Filtering System\n\nAdvanced content filtering protects against spam, scams, and malicious content while preserving legitimate communication:\n\n\u003CCardGrid>\n  \u003CCard title=\"ðŸ“ Pattern Recognition\" icon=\"search\">\n    **Multi-layered filtering** with regex patterns, machine learning models, and behavioral analysis for comprehensive threat detection.\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸŽ¯ Contextual Analysis\" icon=\"approve-check\">\n    **Context-aware filtering** that considers conversation history, user reputation, and platform norms to reduce false positives.\n  \u003C/Card>\n\n  \u003CCard title=\"ðŸ”„ Dynamic Updates\" icon=\"refresh\">\n    **Real-time pattern updates** from threat intelligence feeds and community reporting to stay ahead of evolving attacks.\n  \u003C/Card>\n\n  \u003CCard title=\"âš–ï¸ Balanced Approach\" icon=\"balance\">\n    **Performance optimization** with tiered filtering stages and smart caching to maintain sub-millisecond processing times.\n  \u003C/Card>\n\u003C/CardGrid>\n\n\u003CTabs>\n  \u003CTabItem label=\"Content Filter Engine\">\n```typescript\nexport interface FilterRule {\n  id: string;\n  name: string;\n  category: FilterCategory;\n  pattern: RegExp;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  action: FilterAction;\n  confidence: number;\n  enabled: boolean;\n  lastUpdated: Date;\n}\n\nexport enum FilterCategory {\n  SPAM = 'spam',\n  SCAM = 'scam',\n  PHISHING = 'phishing',\n  MALWARE = 'malware',\n  HARASSMENT = 'harassment',\n  INAPPROPRIATE = 'inappropriate',\n  CRYPTO_SCAM = 'crypto_scam'\n}\n\nexport enum FilterAction {\n  BLOCK = 'block',\n  QUARANTINE = 'quarantine',\n  FLAG = 'flag',\n  RATE_LIMIT = 'rate_limit',\n  LOG_ONLY = 'log_only'\n}\n\nexport class ContentFilterEngine {\n  private filterRules: Map\u003CFilterCategory, FilterRule[]> = new Map();\n  private mlModel: ContentClassificationModel;\n  private patternCache = new LRUCache\u003Cstring, FilterResult>({ max: 10000 });\n  \n  constructor() {\n    this.initializeFilterRules();\n    this.mlModel = new ContentClassificationModel();\n  }\n  \n  async filterContent(\n    content: string,\n    userId: string,\n    platform: string,\n    context: FilterContext\n  ): Promise\u003CFilterResult> {\n    const startTime = Date.now();\n    \n    // Check cache first\n    const cacheKey = this.generateCacheKey(content, platform);\n    const cached = this.patternCache.get(cacheKey);\n    if (cached && this.isCacheValid(cached, startTime)) {\n      return cached;\n    }\n    \n    // Stage 1: Fast pattern matching\n    const patternResults = await this.applyPatternFilters(content, context);\n    \n    // Stage 2: ML-based classification (for ambiguous cases)\n    const mlResults = patternResults.some(r => r.confidence \u003C 0.8) \n      ? await this.mlModel.classify(content, context)\n      : null;\n    \n    // Stage 3: Contextual analysis\n    const contextualResults = await this.applyContextualAnalysis(\n      content, \n      patternResults, \n      mlResults, \n      context\n    );\n    \n    // Combine results and make final decision\n    const finalResult = this.combineFilterResults(\n      patternResults,\n      mlResults,\n      contextualResults,\n      context\n    );\n    \n    finalResult.processingTimeMs = Date.now() - startTime;\n    \n    // Cache result\n    this.patternCache.set(cacheKey, finalResult);\n    \n    // Log if significant threat detected\n    if (finalResult.severity === 'high' || finalResult.severity === 'critical') {\n      await this.logSecurityEvent(userId, platform, content, finalResult);\n    }\n    \n    return finalResult;\n  }\n  \n  private async applyPatternFilters(\n    content: string,\n    context: FilterContext\n  ): Promise\u003CPatternFilterResult[]> {\n    const results: PatternFilterResult[] = [];\n    const lowerContent = content.toLowerCase();\n    \n    // Apply all filter categories in parallel\n    const categoryPromises = Array.from(this.filterRules.entries()).map(\n      async ([category, rules]) => {\n        return await this.applyCategoryFilters(category, rules, lowerContent, context);\n      }\n    );\n    \n    const categoryResults = await Promise.all(categoryPromises);\n    return categoryResults.flat();\n  }\n  \n  private async applyCategoryFilters(\n    category: FilterCategory,\n    rules: FilterRule[],\n    content: string,\n    context: FilterContext\n  ): Promise\u003CPatternFilterResult[]> {\n    const results: PatternFilterResult[] = [];\n    \n    for (const rule of rules) {\n      if (!rule.enabled) continue;\n      \n      const matches = content.match(rule.pattern);\n      if (matches) {\n        const confidence = this.calculatePatternConfidence(\n          rule, \n          matches, \n          content, \n          context\n        );\n        \n        results.push({\n          ruleId: rule.id,\n          category,\n          severity: rule.severity,\n          confidence,\n          matches,\n          action: rule.action\n        });\n      }\n    }\n    \n    return results;\n  }\n  \n  private initializeFilterRules(): void {\n    // Spam detection patterns\n    this.filterRules.set(FilterCategory.SPAM, [\n      {\n        id: 'spam_repetition',\n        name: 'Repetitive Content',\n        category: FilterCategory.SPAM,\n        pattern: /(.)\\1{10,}/gi, // Same character repeated 10+ times\n        severity: 'medium',\n        action: FilterAction.FLAG,\n        confidence: 0.8,\n        enabled: true,\n        lastUpdated: new Date()\n      },\n      {\n        id: 'spam_caps',\n        name: 'Excessive Capitals',\n        category: FilterCategory.SPAM,\n        pattern: /[A-Z]{20,}/g,\n        severity: 'low',\n        action: FilterAction.FLAG,\n        confidence: 0.6,\n        enabled: true,\n        lastUpdated: new Date()\n      },\n      {\n        id: 'spam_marketing',\n        name: 'Marketing Spam',\n        pattern: /\\b(free money|guaranteed profit|limited time|click here|act now)\\b/gi,\n        severity: 'medium',\n        action: FilterAction.QUARANTINE,\n        confidence: 0.75,\n        enabled: true,\n        lastUpdated: new Date()\n      }\n    ]);\n    \n    // Crypto scam patterns\n    this.filterRules.set(FilterCategory.CRYPTO_SCAM, [\n      {\n        id: 'crypto_seed_request',\n        name: 'Seed Phrase Scam',\n        category: FilterCategory.CRYPTO_SCAM,\n        pattern: /\\b(seed phrase|private key|recovery phrase|send.*sol|send.*btc)\\b/gi,\n        severity: 'critical',\n        action: FilterAction.BLOCK,\n        confidence: 0.95,\n        enabled: true,\n        lastUpdated: new Date()\n      },\n      {\n        id: 'crypto_fake_support',\n        name: 'Fake Support Scam',\n        category: FilterCategory.CRYPTO_SCAM,\n        pattern: /\\b(official support|verify.*wallet|suspended.*account)\\b/gi,\n        severity: 'high',\n        action: FilterAction.BLOCK,\n        confidence: 0.85,\n        enabled: true,\n        lastUpdated: new Date()\n      }\n    ]);\n    \n    // Phishing patterns\n    this.filterRules.set(FilterCategory.PHISHING, [\n      {\n        id: 'phishing_urgent',\n        name: 'Urgent Action Required',\n        category: FilterCategory.PHISHING,\n        pattern: /\\b(urgent.*action|account.*suspended|verify.*immediately)\\b/gi,\n        severity: 'high',\n        action: FilterAction.BLOCK,\n        confidence: 0.8,\n        enabled: true,\n        lastUpdated: new Date()\n      },\n      {\n        id: 'phishing_links',\n        name: 'Suspicious Links',\n        category: FilterCategory.PHISHING,\n        pattern: /https?:\\/\\/[^\\s]*\\b(secure|verify|update|confirm)\\b[^\\s]*/gi,\n        severity: 'medium',\n        action: FilterAction.FLAG,\n        confidence: 0.7,\n        enabled: true,\n        lastUpdated: new Date()\n      }\n    ]);\n  }\n}\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"ML Classification\">\n```typescript\n// Machine learning-based content classification\nexport class ContentClassificationModel {\n  private model: TensorFlowModel;\n  private tokenizer: Tokenizer;\n  private isLoaded = false;\n  \n  constructor() {\n    this.initializeModel();\n  }\n  \n  async classify(\n    content: string,\n    context: FilterContext\n  ): Promise\u003CMLFilterResult> {\n    if (!this.isLoaded) {\n      await this.loadModel();\n    }\n    \n    // Preprocess content\n    const features = await this.extractFeatures(content, context);\n    \n    // Get model predictions\n    const predictions = await this.model.predict(features);\n    \n    // Post-process results\n    const classification = this.interpretPredictions(predictions, content);\n    \n    return {\n      categories: classification.categories,\n      overallThreat: classification.overallThreat,\n      confidence: classification.confidence,\n      reasoning: classification.reasoning,\n      modelVersion: this.model.version\n    };\n  }\n  \n  private async extractFeatures(\n    content: string,\n    context: FilterContext\n  ): Promise\u003CFeatureVector> {\n    // Tokenize content\n    const tokens = await this.tokenizer.tokenize(content);\n    \n    // Extract linguistic features\n    const linguisticFeatures = {\n      length: content.length,\n      wordCount: tokens.length,\n      avgWordLength: tokens.reduce((sum, token) => sum + token.length, 0) / tokens.length,\n      capsRatio: (content.match(/[A-Z]/g) || []).length / content.length,\n      punctuationRatio: (content.match(/[.!?]/g) || []).length / content.length,\n      numberRatio: (content.match(/\\d/g) || []).length / content.length,\n      urlCount: (content.match(/https?:\\/\\/[^\\s]+/g) || []).length,\n      emojiCount: (content.match(/[\\u{1F600}-\\u{1F64F}]/gu) || []).length\n    };\n    \n    // Extract contextual features\n    const contextualFeatures = {\n      platform: this.encodePlatform(context.platform),\n      timeOfDay: this.encodeTimeOfDay(context.timestamp),\n      userReputation: context.userReputation || 0.5,\n      conversationLength: context.conversationLength || 1,\n      isReply: context.isReply || false\n    };\n    \n    // Extract semantic features using embeddings\n    const semanticFeatures = await this.generateSemanticEmbedding(content);\n    \n    return {\n      linguistic: linguisticFeatures,\n      contextual: contextualFeatures,\n      semantic: semanticFeatures\n    };\n  }\n  \n  private interpretPredictions(\n    predictions: ModelPredictions,\n    content: string\n  ): ClassificationResult {\n    const categories: Map\u003CFilterCategory, number> = new Map();\n    \n    // Map model outputs to filter categories\n    categories.set(FilterCategory.SPAM, predictions.spam);\n    categories.set(FilterCategory.SCAM, predictions.scam);\n    categories.set(FilterCategory.PHISHING, predictions.phishing);\n    categories.set(FilterCategory.HARASSMENT, predictions.harassment);\n    categories.set(FilterCategory.INAPPROPRIATE, predictions.inappropriate);\n    categories.set(FilterCategory.CRYPTO_SCAM, predictions.cryptoScam);\n    \n    // Calculate overall threat score\n    const threatScores = Array.from(categories.values());\n    const overallThreat = Math.max(...threatScores);\n    \n    // Determine confidence based on prediction distribution\n    const entropy = this.calculateEntropy(threatScores);\n    const confidence = 1 - entropy / Math.log(threatScores.length);\n    \n    // Generate reasoning\n    const topCategory = Array.from(categories.entries())\n      .sort((a, b) => b[1] - a[1])[0];\n    \n    const reasoning = this.generateReasoning(topCategory, predictions, content);\n    \n    return {\n      categories,\n      overallThreat,\n      confidence,\n      reasoning\n    };\n  }\n  \n  async updateModel(): Promise\u003Cvoid> {\n    try {\n      // Download latest model from secure endpoint\n      const modelUrl = `${process.env.ML_MODEL_ENDPOINT}/content-filter/latest`;\n      const modelData = await this.secureDownload(modelUrl);\n      \n      // Validate model integrity\n      if (!await this.validateModelIntegrity(modelData)) {\n        throw new Error('Model integrity validation failed');\n      }\n      \n      // Load new model\n      const newModel = await this.loadModelFromData(modelData);\n      \n      // Test new model with known samples\n      const testResults = await this.testModel(newModel);\n      if (testResults.accuracy \u003C 0.85) {\n        throw new Error('New model does not meet accuracy threshold');\n      }\n      \n      // Replace current model\n      this.model = newModel;\n      this.isLoaded = true;\n      \n      logger.info('Content classification model updated successfully', {\n        version: newModel.version,\n        accuracy: testResults.accuracy\n      });\n      \n    } catch (error) {\n      logger.error('Failed to update ML model:', error);\n      // Continue using existing model\n    }\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ”’ XSS & Injection Prevention\n\nComprehensive protection against cross-site scripting and injection attacks:\n\n\u003CTabs>\n  \u003CTabItem label=\"XSS Prevention\">\n```typescript\nexport class XSSPrevention {\n  private dangerousPatterns = [\n    // Script injection\n    /\u003Cscript\\b[^\u003C]*(?:(?!\u003C\\/script>)\u003C[^\u003C]*)*\u003C\\/script>/gi,\n    /javascript:/gi,\n    /vbscript:/gi,\n    /on\\w+\\s*=/gi,\n    \n    // HTML injection\n    /\u003Ciframe\\b[^>]*>/gi,\n    /\u003Cobject\\b[^>]*>/gi,\n    /\u003Cembed\\b[^>]*>/gi,\n    /\u003Clink\\b[^>]*>/gi,\n    /\u003Cmeta\\b[^>]*>/gi,\n    \n    // Style injection\n    /expression\\s*\\(/gi,\n    /@import\\b/gi,\n    /binding\\s*:/gi,\n    \n    // Data URLs with scripts\n    /data:\\s*text\\/html/gi,\n    /data:\\s*application\\/javascript/gi\n  ];\n  \n  async preventXSS(\n    content: string,\n    context: SecurityContext\n  ): Promise\u003CXSSPreventionResult> {\n    const originalContent = content;\n    let sanitizedContent = content;\n    const detectedThreats: XSSThreat[] = [];\n    \n    // Step 1: Pattern-based detection and removal\n    for (const pattern of this.dangerousPatterns) {\n      const matches = sanitizedContent.match(pattern);\n      if (matches) {\n        detectedThreats.push({\n          type: 'pattern_match',\n          pattern: pattern.toString(),\n          matches: matches,\n          severity: this.assessPatternSeverity(pattern)\n        });\n        \n        // Remove or neutralize dangerous content\n        sanitizedContent = sanitizedContent.replace(pattern, (match) => {\n          return this.neutralizeMatch(match);\n        });\n      }\n    }\n    \n    // Step 2: HTML entity encoding\n    sanitizedContent = this.htmlEncode(sanitizedContent);\n    \n    // Step 3: URL validation and sanitization\n    sanitizedContent = await this.sanitizeUrls(sanitizedContent);\n    \n    // Step 4: Advanced parsing for complex attacks\n    const advancedThreats = await this.detectAdvancedXSS(originalContent);\n    detectedThreats.push(...advancedThreats);\n    \n    const isModified = originalContent !== sanitizedContent;\n    const threatLevel = this.calculateThreatLevel(detectedThreats);\n    \n    return {\n      originalContent,\n      sanitizedContent,\n      isModified,\n      threatLevel,\n      detectedThreats,\n      action: this.determineAction(threatLevel, context)\n    };\n  }\n  \n  private htmlEncode(content: string): string {\n    return content\n      .replace(/&/g, '&amp;')\n      .replace(/\u003C/g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#x27;')\n      .replace(/\\//g, '&#x2F;');\n  }\n  \n  private async sanitizeUrls(content: string): Promise\u003Cstring> {\n    const urlPattern = /(https?:\\/\\/[^\\s]+)/gi;\n    \n    return content.replace(urlPattern, (url) => {\n      try {\n        const parsedUrl = new URL(url);\n        \n        // Block data URLs\n        if (parsedUrl.protocol === 'data:') {\n          return '[BLOCKED_DATA_URL]';\n        }\n        \n        // Block javascript URLs\n        if (parsedUrl.protocol === 'javascript:') {\n          return '[BLOCKED_JS_URL]';\n        }\n        \n        // Validate domain against blacklist\n        if (this.isBlacklistedDomain(parsedUrl.hostname)) {\n          return '[BLOCKED_DOMAIN]';\n        }\n        \n        return url;\n      } catch (error) {\n        // Malformed URL, remove it\n        return '[MALFORMED_URL]';\n      }\n    });\n  }\n  \n  private async detectAdvancedXSS(content: string): Promise\u003CXSSThreat[]> {\n    const threats: XSSThreat[] = [];\n    \n    // Check for encoded attacks\n    const decodedContent = this.decodeCommonEncodings(content);\n    if (decodedContent !== content) {\n      // Re-check decoded content for threats\n      for (const pattern of this.dangerousPatterns) {\n        if (pattern.test(decodedContent)) {\n          threats.push({\n            type: 'encoded_attack',\n            pattern: pattern.toString(),\n            matches: decodedContent.match(pattern) || [],\n            severity: 'high'\n          });\n        }\n      }\n    }\n    \n    // Check for polyglot attacks\n    if (this.detectPolyglotAttack(content)) {\n      threats.push({\n        type: 'polyglot_attack',\n        pattern: 'polyglot_detection',\n        matches: [content],\n        severity: 'critical'\n      });\n    }\n    \n    return threats;\n  }\n  \n  private decodeCommonEncodings(content: string): string {\n    let decoded = content;\n    \n    // HTML entity decoding\n    decoded = decoded\n      .replace(/&lt;/g, '\u003C')\n      .replace(/&gt;/g, '>')\n      .replace(/&quot;/g, '\"')\n      .replace(/&#x27;/g, \"'\")\n      .replace(/&amp;/g, '&');\n    \n    // URL decoding\n    try {\n      decoded = decodeURIComponent(decoded);\n    } catch (e) {\n      // Invalid encoding, keep original\n    }\n    \n    // Base64 decoding (simple cases)\n    const base64Pattern = /[A-Za-z0-9+/]{20,}={0,2}/g;\n    decoded = decoded.replace(base64Pattern, (match) => {\n      try {\n        const decodedBase64 = atob(match);\n        // Only return if it contains suspicious patterns\n        return this.containsSuspiciousPatterns(decodedBase64) ? decodedBase64 : match;\n      } catch (e) {\n        return match;\n      }\n    });\n    \n    return decoded;\n  }\n}\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"SQL Injection Prevention\">\n```typescript\nexport class SQLInjectionPrevention {\n  private sqlPatterns = [\n    // Union-based attacks\n    /\\bunion\\b.*\\bselect\\b/gi,\n    /\\bselect\\b.*\\bunion\\b/gi,\n    \n    // Boolean-based attacks\n    /\\b(and|or)\\b\\s*\\d+\\s*=\\s*\\d+/gi,\n    /\\b(and|or)\\b\\s*'[^']*'\\s*=\\s*'[^']*'/gi,\n    \n    // Time-based attacks\n    /\\bwaitfor\\b\\s+\\bdelay\\b/gi,\n    /\\bsleep\\s*\\(/gi,\n    /\\bbenchmark\\s*\\(/gi,\n    \n    // Comment-based attacks\n    /\\/\\*.*\\*\\//gi,\n    /--[^\\r\\n]*/gi,\n    /#[^\\r\\n]*/gi,\n    \n    // System function calls\n    /\\bexec\\s*\\(/gi,\n    /\\bexecute\\s*\\(/gi,\n    /\\bsp_executesql\\b/gi,\n    /\\bxp_cmdshell\\b/gi,\n    \n    // Information gathering\n    /\\btable_name\\b/gi,\n    /\\bcolumn_name\\b/gi,\n    /\\binformation_schema\\b/gi,\n    /\\bsysobjects\\b/gi,\n    /\\bsyscolumns\\b/gi\n  ];\n  \n  async preventSQLInjection(\n    input: string,\n    context: SecurityContext\n  ): Promise\u003CSQLInjectionResult> {\n    const detectedPatterns: SQLPattern[] = [];\n    let threatLevel: ThreatLevel = 'none';\n    \n    // Check for SQL injection patterns\n    for (const pattern of this.sqlPatterns) {\n      const matches = input.match(pattern);\n      if (matches) {\n        const patternThreat = this.assessSQLPatternThreat(pattern, matches);\n        detectedPatterns.push({\n          pattern: pattern.toString(),\n          matches,\n          threat: patternThreat,\n          description: this.getPatternDescription(pattern)\n        });\n        \n        if (patternThreat > threatLevel) {\n          threatLevel = patternThreat;\n        }\n      }\n    }\n    \n    // Advanced analysis for obfuscated attacks\n    const obfuscatedThreats = await this.detectObfuscatedSQL(input);\n    detectedPatterns.push(...obfuscatedThreats);\n    \n    // Calculate final threat assessment\n    const finalThreatLevel = this.calculateFinalThreat(detectedPatterns, context);\n    \n    return {\n      input,\n      threatLevel: finalThreatLevel,\n      detectedPatterns,\n      recommendation: this.getRecommendation(finalThreatLevel),\n      sanitizedInput: this.sanitizeSQL(input, detectedPatterns)\n    };\n  }\n  \n  private sanitizeSQL(input: string, patterns: SQLPattern[]): string {\n    let sanitized = input;\n    \n    // Remove or escape dangerous patterns\n    for (const pattern of patterns) {\n      if (pattern.threat === 'critical' || pattern.threat === 'high') {\n        // Remove completely for high-risk patterns\n        sanitized = sanitized.replace(new RegExp(pattern.pattern, 'gi'), '[FILTERED]');\n      } else if (pattern.threat === 'medium') {\n        // Escape for medium-risk patterns\n        sanitized = this.escapeSQLCharacters(sanitized);\n      }\n    }\n    \n    return sanitized;\n  }\n  \n  private escapeSQLCharacters(input: string): string {\n    return input\n      .replace(/'/g, \"''\")    // Escape single quotes\n      .replace(/\"/g, '\"\"')    // Escape double quotes\n      .replace(/\\\\/g, '\\\\\\\\') // Escape backslashes\n      .replace(/;/g, '\\\\;')   // Escape semicolons\n      .replace(/--/g, '\\\\--') // Escape SQL comments\n      .replace(/\\/\\*/g, '\\\\/\\\\*') // Escape block comments\n      .replace(/\\*\\//g, '\\\\*\\\\/');\n  }\n  \n  private async detectObfuscatedSQL(input: string): Promise\u003CSQLPattern[]> {\n    const threats: SQLPattern[] = [];\n    \n    // Check for character encoding obfuscation\n    const decodedInput = this.decodeVariousEncodings(input);\n    if (decodedInput !== input) {\n      // Re-scan decoded content\n      for (const pattern of this.sqlPatterns) {\n        if (pattern.test(decodedInput)) {\n          threats.push({\n            pattern: 'obfuscated_' + pattern.toString(),\n            matches: decodedInput.match(pattern) || [],\n            threat: 'high',\n            description: 'Obfuscated SQL injection attempt'\n          });\n        }\n      }\n    }\n    \n    // Check for concatenation-based obfuscation\n    if (this.detectConcatenationObfuscation(input)) {\n      threats.push({\n        pattern: 'concatenation_obfuscation',\n        matches: [input],\n        threat: 'high',\n        description: 'String concatenation obfuscation detected'\n      });\n    }\n    \n    return threats;\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ›¡ï¸ Advanced Threat Detection\n\nNUBI employs sophisticated threat detection mechanisms for emerging attack patterns:\n\n\u003CTabs>\n  \u003CTabItem label=\"Behavioral Analysis\">\n```typescript\nexport class BehavioralThreatDetector {\n  private userBehaviorProfiles = new Map\u003Cstring, UserBehaviorProfile>();\n  private anomalyThresholds = {\n    messageFrequency: 0.3,\n    contentSimilarity: 0.8,\n    platformSwitching: 0.4,\n    timePatterns: 0.25\n  };\n  \n  async analyzeBehavioralThreats(\n    userId: string,\n    message: string,\n    context: BehaviorContext\n  ): Promise\u003CBehavioralThreatResult> {\n    const profile = await this.getUserBehaviorProfile(userId);\n    const currentBehavior = await this.extractCurrentBehavior(message, context);\n    \n    const anomalies = await this.detectAnomalies(profile, currentBehavior);\n    const threatScore = this.calculateBehavioralThreatScore(anomalies);\n    \n    // Update profile with current behavior\n    await this.updateBehaviorProfile(userId, profile, currentBehavior);\n    \n    return {\n      userId,\n      threatScore,\n      anomalies,\n      recommendations: this.generateRecommendations(anomalies),\n      profileConfidence: profile.confidence\n    };\n  }\n  \n  private async detectAnomalies(\n    profile: UserBehaviorProfile,\n    current: CurrentBehavior\n  ): Promise\u003CBehavioralAnomaly[]> {\n    const anomalies: BehavioralAnomaly[] = [];\n    \n    // Message frequency analysis\n    if (this.isFrequencyAnomaly(profile.messageFrequency, current.messageFrequency)) {\n      anomalies.push({\n        type: 'frequency_anomaly',\n        severity: this.calculateFrequencyAnomalySeverity(profile, current),\n        description: 'Unusual messaging frequency detected',\n        baseline: profile.messageFrequency,\n        current: current.messageFrequency,\n        zscore: this.calculateZScore(profile.messageFrequency, current.messageFrequency)\n      });\n    }\n    \n    // Content pattern analysis\n    const contentSimilarity = await this.calculateContentSimilarity(\n      profile.contentPatterns, \n      current.contentPattern\n    );\n    \n    if (contentSimilarity \u003C this.anomalyThresholds.contentSimilarity) {\n      anomalies.push({\n        type: 'content_anomaly',\n        severity: this.calculateContentAnomalySeverity(contentSimilarity),\n        description: 'Unusual content pattern detected',\n        baseline: profile.contentPatterns,\n        current: current.contentPattern,\n        similarity: contentSimilarity\n      });\n    }\n    \n    // Time pattern analysis\n    if (this.isTimePatternAnomaly(profile.activityPatterns, current.timeContext)) {\n      anomalies.push({\n        type: 'temporal_anomaly',\n        severity: 'medium',\n        description: 'Unusual activity timing detected',\n        baseline: profile.activityPatterns,\n        current: current.timeContext\n      });\n    }\n    \n    // Platform behavior analysis\n    if (this.isPlatformBehaviorAnomaly(profile.platformBehaviors, current.platform)) {\n      anomalies.push({\n        type: 'platform_anomaly',\n        severity: 'low',\n        description: 'Unusual cross-platform behavior detected',\n        baseline: profile.platformBehaviors,\n        current: current.platform\n      });\n    }\n    \n    return anomalies;\n  }\n  \n  private calculateBehavioralThreatScore(anomalies: BehavioralAnomaly[]): number {\n    if (anomalies.length === 0) return 0;\n    \n    const severityWeights = {\n      'low': 0.2,\n      'medium': 0.5,\n      'high': 0.8,\n      'critical': 1.0\n    };\n    \n    const weightedSum = anomalies.reduce((sum, anomaly) => {\n      return sum + severityWeights[anomaly.severity];\n    }, 0);\n    \n    // Normalize by number of anomalies and apply scaling\n    const baseScore = weightedSum / anomalies.length;\n    \n    // Apply anomaly count multiplier (more anomalies = higher threat)\n    const countMultiplier = Math.min(1.5, 1 + (anomalies.length - 1) * 0.1);\n    \n    return Math.min(1.0, baseScore * countMultiplier);\n  }\n  \n  async detectCoordinatedAttacks(\n    recentEvents: SecurityEvent[]\n  ): Promise\u003CCoordinatedAttackResult> {\n    // Group events by time windows\n    const timeWindows = this.groupEventsByTimeWindows(recentEvents, 300000); // 5-minute windows\n    \n    const suspiciousWindows = [];\n    \n    for (const window of timeWindows) {\n      const coordination = await this.analyzeCoordination(window);\n      \n      if (coordination.suspicionScore > 0.7) {\n        suspiciousWindows.push({\n          timeWindow: window.timeRange,\n          events: window.events,\n          coordination,\n          participants: this.extractParticipants(window.events),\n          patterns: this.identifyAttackPatterns(window.events)\n        });\n      }\n    }\n    \n    return {\n      coordinatedAttackDetected: suspiciousWindows.length > 0,\n      suspiciousWindows,\n      overallThreatLevel: this.calculateOverallCoordinationThreat(suspiciousWindows),\n      recommendations: this.generateCoordinationRecommendations(suspiciousWindows)\n    };\n  }\n  \n  private async analyzeCoordination(window: EventWindow): Promise\u003CCoordinationAnalysis> {\n    const events = window.events;\n    \n    // Analyze message similarity\n    const contentSimilarity = await this.analyzeContentSimilarity(events);\n    \n    // Analyze timing patterns\n    const timingPatterns = this.analyzeTimingPatterns(events);\n    \n    // Analyze source patterns\n    const sourcePatterns = this.analyzeSourcePatterns(events);\n    \n    // Analyze network patterns (if available)\n    const networkPatterns = await this.analyzeNetworkPatterns(events);\n    \n    const suspicionScore = this.calculateCoordinationScore({\n      contentSimilarity,\n      timingPatterns,\n      sourcePatterns,\n      networkPatterns\n    });\n    \n    return {\n      suspicionScore,\n      contentSimilarity,\n      timingPatterns,\n      sourcePatterns,\n      networkPatterns,\n      confidence: this.calculateCoordinationConfidence(events.length)\n    };\n  }\n}\n```\n  \u003C/TabItem>\n\n  \u003CTabItem label=\"Threat Intelligence\">\n```typescript\nexport class ThreatIntelligenceSystem {\n  private threatFeeds = new Map\u003Cstring, ThreatFeed>();\n  private indicatorCache = new Map\u003Cstring, ThreatIndicator>();\n  private updateInterval = 3600000; // 1 hour\n  \n  constructor() {\n    this.initializeThreatFeeds();\n    this.startPeriodicUpdates();\n  }\n  \n  async checkThreatIntelligence(\n    content: string,\n    metadata: ThreatContext\n  ): Promise\u003CThreatIntelligenceResult> {\n    const indicators = await this.extractIndicators(content, metadata);\n    const threatMatches: ThreatMatch[] = [];\n    \n    for (const indicator of indicators) {\n      const threats = await this.queryThreatFeeds(indicator);\n      if (threats.length > 0) {\n        threatMatches.push({\n          indicator,\n          threats,\n          confidence: this.calculateMatchConfidence(indicator, threats),\n          severity: this.calculateMaxSeverity(threats)\n        });\n      }\n    }\n    \n    const overallRisk = this.calculateOverallRisk(threatMatches);\n    \n    return {\n      riskLevel: overallRisk,\n      threatMatches,\n      recommendations: this.generateThreatRecommendations(threatMatches),\n      indicators,\n      lastUpdate: await this.getLastUpdateTime()\n    };\n  }\n  \n  private async extractIndicators(\n    content: string,\n    metadata: ThreatContext\n  ): Promise\u003CThreatIndicator[]> {\n    const indicators: ThreatIndicator[] = [];\n    \n    // Extract URLs\n    const urlMatches = content.match(/https?:\\/\\/[^\\s]+/g);\n    if (urlMatches) {\n      for (const url of urlMatches) {\n        indicators.push({\n          type: 'url',\n          value: url,\n          source: 'message_content',\n          confidence: 0.9\n        });\n        \n        // Also extract domain\n        try {\n          const domain = new URL(url).hostname;\n          indicators.push({\n            type: 'domain',\n            value: domain,\n            source: 'url_extraction',\n            confidence: 0.95\n          });\n        } catch (e) {\n          // Invalid URL, skip domain extraction\n        }\n      }\n    }\n    \n    // Extract IP addresses\n    const ipMatches = content.match(/\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b/g);\n    if (ipMatches) {\n      for (const ip of ipMatches) {\n        if (this.isValidIP(ip)) {\n          indicators.push({\n            type: 'ip',\n            value: ip,\n            source: 'message_content',\n            confidence: 0.85\n          });\n        }\n      }\n    }\n    \n    // Extract email addresses\n    const emailMatches = content.match(/\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/g);\n    if (emailMatches) {\n      for (const email of emailMatches) {\n        indicators.push({\n          type: 'email',\n          value: email,\n          source: 'message_content',\n          confidence: 0.8\n        });\n      }\n    }\n    \n    // Extract crypto addresses\n    const cryptoMatches = this.extractCryptoAddresses(content);\n    indicators.push(...cryptoMatches);\n    \n    // Extract file hashes\n    const hashMatches = this.extractFileHashes(content);\n    indicators.push(...hashMatches);\n    \n    return indicators;\n  }\n  \n  private async queryThreatFeeds(\n    indicator: ThreatIndicator\n  ): Promise\u003CThreatIntelligenceItem[]> {\n    const threats: ThreatIntelligenceItem[] = [];\n    \n    // Check cache first\n    const cacheKey = `${indicator.type}:${indicator.value}`;\n    const cached = this.indicatorCache.get(cacheKey);\n    if (cached && this.isCacheValid(cached)) {\n      return cached.threats;\n    }\n    \n    // Query all active threat feeds\n    const feedPromises = Array.from(this.threatFeeds.values()).map(async (feed) => {\n      if (feed.isActive && feed.supportsIndicatorType(indicator.type)) {\n        try {\n          return await feed.query(indicator);\n        } catch (error) {\n          logger.warn(`Threat feed ${feed.name} query failed:`, error);\n          return [];\n        }\n      }\n      return [];\n    });\n    \n    const feedResults = await Promise.all(feedPromises);\n    const allThreats = feedResults.flat();\n    \n    // Cache result\n    this.indicatorCache.set(cacheKey, {\n      threats: allThreats,\n      timestamp: Date.now(),\n      ttl: 3600000 // 1 hour\n    });\n    \n    return allThreats;\n  }\n  \n  private initializeThreatFeeds(): void {\n    // Malware domain feed\n    this.threatFeeds.set('malware_domains', new ThreatFeed({\n      name: 'Malware Domains',\n      url: process.env.MALWARE_DOMAINS_FEED,\n      type: 'domain_blacklist',\n      updateInterval: 3600000,\n      isActive: true,\n      supportedTypes: ['domain', 'url']\n    }));\n    \n    // Phishing URL feed\n    this.threatFeeds.set('phishing_urls', new ThreatFeed({\n      name: 'Phishing URLs',\n      url: process.env.PHISHING_URLS_FEED,\n      type: 'url_blacklist',\n      updateInterval: 1800000, // 30 minutes\n      isActive: true,\n      supportedTypes: ['url']\n    }));\n    \n    // Crypto scam addresses\n    this.threatFeeds.set('crypto_scams', new ThreatFeed({\n      name: 'Crypto Scam Addresses',\n      url: process.env.CRYPTO_SCAM_FEED,\n      type: 'crypto_blacklist',\n      updateInterval: 7200000, // 2 hours\n      isActive: true,\n      supportedTypes: ['crypto_address']\n    }));\n    \n    // IP reputation feed\n    this.threatFeeds.set('ip_reputation', new ThreatFeed({\n      name: 'IP Reputation',\n      url: process.env.IP_REPUTATION_FEED,\n      type: 'ip_reputation',\n      updateInterval: 3600000,\n      isActive: true,\n      supportedTypes: ['ip']\n    }));\n  }\n  \n  async generateThreatReport(): Promise\u003CThreatReport> {\n    const recentThreats = await this.getRecentThreats(86400000); // Last 24 hours\n    \n    const report = {\n      timeRange: {\n        start: Date.now() - 86400000,\n        end: Date.now()\n      },\n      summary: {\n        totalThreats: recentThreats.length,\n        blockedThreats: recentThreats.filter(t => t.action === 'blocked').length,\n        flaggedThreats: recentThreats.filter(t => t.action === 'flagged').length,\n        byCategory: this.groupThreatsByCategory(recentThreats),\n        bySeverity: this.groupThreatsBySeverity(recentThreats)\n      },\n      trends: await this.calculateThreatTrends(),\n      topThreats: this.getTopThreats(recentThreats, 10),\n      emergingThreats: await this.identifyEmergingThreats(),\n      feedHealth: await this.assessFeedHealth(),\n      recommendations: await this.generateSecurityRecommendations(recentThreats)\n    };\n    \n    return report;\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n## ðŸ“Š Security Analytics & Monitoring\n\nComprehensive monitoring and analytics for security events:\n\n\u003CTabs>\n  \u003CTabItem label=\"Real-time Monitoring\">\n```typescript\nexport class SecurityMonitor {\n  private eventBuffer: SecurityEvent[] = [];\n  private alertConfigs: AlertConfiguration[] = [];\n  private metricsCollector = new SecurityMetricsCollector();\n  \n  async processSecurityEvent(event: SecurityEvent): Promise\u003Cvoid> {\n    // Add to buffer for batch processing\n    this.eventBuffer.push(event);\n    \n    // Check for immediate alerts\n    await this.checkImmediateAlerts(event);\n    \n    // Update real-time metrics\n    await this.metricsCollector.updateMetrics(event);\n    \n    // Flush buffer if needed\n    if (this.eventBuffer.length >= 100) {\n      await this.flushEventBuffer();\n    }\n  }\n  \n  private async checkImmediateAlerts(event: SecurityEvent): Promise\u003Cvoid> {\n    for (const config of this.alertConfigs) {\n      if (this.eventMatchesAlertConfig(event, config)) {\n        await this.triggerAlert(config, event);\n      }\n    }\n  }\n  \n  async generateSecurityDashboard(): Promise\u003CSecurityDashboard> {\n    const metrics = await this.metricsCollector.getCurrentMetrics();\n    \n    return {\n      overview: {\n        threatsBlocked: metrics.threatsBlocked,\n        activeUsers: metrics.activeUsers,\n        systemHealth: this.calculateSystemHealth(metrics),\n        alertLevel: this.calculateAlertLevel(metrics)\n      },\n      threatBreakdown: {\n        byType: metrics.threatsByType,\n        bySeverity: metrics.threatsBySeverity,\n        byPlatform: metrics.threatsByPlatform,\n        trending: await this.getTrendingThreats()\n      },\n      performance: {\n        averageProcessingTime: metrics.avgProcessingTime,\n        successRate: metrics.successRate,\n        errorRate: metrics.errorRate,\n        throughput: metrics.messagesPerSecond\n      },\n      alerts: {\n        active: await this.getActiveAlerts(),\n        recent: await this.getRecentAlerts(3600000), // Last hour\n        escalated: await this.getEscalatedAlerts()\n      }\n    };\n  }\n}\n```\n  \u003C/TabItem>\n\u003C/Tabs>\n\n---\n\n\u003Cdiv class=\"nubi-note\">\n  \u003Cstrong>ðŸ›¡ï¸ Security Benefits:\u003C/strong> This comprehensive security layer ensures NUBI maintains robust protection against diverse threats while delivering optimal performance and user experience across all platforms.\n\u003C/div>\n\n\u003CAside type=\"tip\">\n  **Architecture Complete**: You've now explored NUBI's complete UX Integration system. Continue with the [Database System](/database/overview/) to understand the data layer architecture.\n\u003C/Aside>","src/content/docs/ux-integration/security.mdx","44a6d92665a5478d","ux-integration/security.mdx"]